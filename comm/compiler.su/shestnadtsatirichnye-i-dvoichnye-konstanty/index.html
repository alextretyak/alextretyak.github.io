<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 190%; line-height: 120%;}
h2 {font-size: 160%;}
h3 {font-size: 137.5%;}
h4 {font-size: 120%;}
h5 {font-size: 110%;}
h6 {font-size: 100%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php">Шестнадцатиричные и двоичные константы (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
<b>2019-08-12</b> <i>alextretyak</i><br />
<br />
Идеи занятные (и с кавычками и со скобками)...<br />
<br />
В свою очередь, предлагаю <!--[[[рассмотреть/]]]-->посмотреть на <!--[[[мой ]]]--><!--[[[вариант/]]]--><a href="http://11l-lang.org/doc/ru/integer-literals">способ записи шестнадцатеричных чисел/констант в языке программирования 11l</a>.<br />
<br />
А не думал ли кто-нибудь <!--[[[о красивом синтаксисе]]]-->об обратной операции? <span class="sq"><span class="sq_brackets">[</span><span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">Речь о конвертировании/преобразовании значения числовой переменной в произвольную систему счисления. Согласен, что она требуется гораздо реже и специальный синтаксис в языке для неё выделять — это излишество, но вот функцию добавить в стандартную библиотеку языка — почему бы и нет <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">на данный момент из популярных языков программирования такая функция есть лишь в Си (itoa), и то она нестандартна</span><span class="cu_brackets_b">}</span></span>.</span><span class="cu_brackets_b">}</span></span><span class="sq_brackets">]</span></span><br />
А также о <!--[[[синтаксисе]]]-->задаче преобразования числа из любой произвольной системы счисления в любую произвольную. Удивительно, но ни в одном языке программирования нет встроенной функции для такого преобразования.<br />
<br />
<blockquote>Иногда ещё 10, но в особых случаях.</blockquote>
Эм... не совсем понял данное предложение\sentence. <!--[[[ИМХО]]]-->Насколько я вижу по реальным проектам, десятичная система счисления является самой востребованной в проектах любого рода. Затем идёт шестнадцатеричная<!--[[[, а]]]-->. Двоичная и восьмеричная же практически не используются. <span class="sq"><span class="sq_brackets">[</span>Или тут речь о явном указании на десятичную систему? Т.е. о записи 10'123 вместо просто 123? Такое, конечно, не востребовано, но имхо это просто какая-то глупость <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">это всё равно что добавить в язык префикс <pre class="inline_code">0d</pre> и писать 0d123 вместо 123</span><span class="cu_brackets_b">}</span></span>.<span class="sq_brackets">]</span></span><br />
<br />
Кстати, <!--[[[я когда выбирал , смотрел примеры реальных программ (на Python и C/C++)]]]-->по хорошему, нужно смотреть примеры реальных проектов/программ, чтобы понять насколько будет удачно/красиво выглядеть тот или иной вариант синтаксиса. <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">Кстати, давно у меня зреет идея <!--[[[мега/]]]-->большого проекта по формированию базы хорошего/красивого кода (в т.ч. псевдокода). Не интересует ли автора сайта работа в этом направлении, в формировании такой базы? <span class="sq"><span class="sq_brackets">[</span>А то мне и самому, признаться, надоело уже быть голословным — хочется бац, и дать ссылку на результат анализа всего хорошего кода на планете, "результат" — в смысле, например, процентное соотношение используемых числовых констант различных систем счисления.<span class="sq_brackets">]</span></span></span><span class="cu_brackets_b">}</span></span><br />
<hr />
<b>2019-08-14</b> <i>Автор сайта</i><br />
<br />
Не понятно, что у Вас является признаком шестнадцатеричного числа. Апостроф? Нет, иначе бы 255\\\'000 не было бы десятичным числом.<br />
<blockquote>Кстати, по хорошему, нужно смотреть примеры реальных проектов/программ, чтобы понять насколько будет удачно/красиво выглядеть тот или иной вариант синтаксиса. <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">Кстати, давно у меня зреет идея большого проекта по формированию базы хорошего/красивого кода (в т.ч. псевдокода). Не интересует ли автора сайта работа в этом направлении, в формировании такой базы? ...</span><span class="cu_brackets_b">}</span></span></blockquote>
Читал я Вашу дискуссию с читателями статьи «Каркас нового языка программирования». Вам заметили, что предлагать новый язык программирования имеет смысл, если в этом языке есть новые концепции. Вы ответили, что желание улучшить синтаксис достаточно для того, что новый язык имел право на существование.<br />
<br />
В принципе, с Вами можно было бы согласиться, вот только «пространства» для улучшения синтаксиса всё меньше и меньше. Число комбинаций одного и того же набора символов ограничено. Так что без новых концепций новым языкам трудно пробиться.<br />
<br />
Вот вам пример лаконичного и красивого синтаксиса. Допустим, в нижеприведённом коде переменной «текущая координата» присвоено значение функции, читающей положение курсора мыши:<br />
<pre class="code_block">
текущие координаты = читать координаты курсора ()
</pre>
А если мы хотим установить новые координаты? Обычно это делается так<br />
<pre class="code_block">
записать координаты курсора (новые координаты)
</pre>
Если язык поддерживает перезагрузку имён функций, то это может выглядеть короче:<br />
<pre class="code_block">
текущие координаты = координаты курсора ()  // чтение
координаты курсора (новые координаты)       // запись
</pre>
Выше две разных функции с одинаковым именем имеют разную семантику. Моя идея заключается в том, что эти одноимённые функции могут менять семантику в зависимости от местоположения:<br />
<pre class="code_block">
текущие координаты = координаты курсора ()  // чтение
координаты курсора () = новые координаты    // запись
</pre>
<hr />
<b>2019-08-15</b> <i>alextretyak</i><br />
<br />
<blockquote>Непонятно, что у Вас является признаком шестнадцатеричного числа. Апостроф? Нет, иначе бы 255\\\'000 не было бы десятичным числом.</blockquote>
3 обратных слэша тут лишние, верно?<br />
А признак очень простой — <b>количество</b> цифр, разделённых апострофом. Если 1, 2 или 4, тогда число шестнадцатеричное. Если 3, либо если нет разделителей<!--[[[/апострофов]]]-->, то число десятичное. Если оканчивается на ‘b’ или русскую ‘д’, тогда двоичное. Если оканчивается на ‘o’, тогда восьмеричное.<br />
<br />
Но благодарю за Вашу реакцию — я подумаю над тем, чтобы <!--[[[дописать/]]]-->добавить это пояснение в документацию языка.<br />
<br />
<blockquote>Читал я Вашу дискуссию с читателями статьи «Каркас нового языка программирования»...</blockquote>
Ну, со времени написания той статьи много воды утекло.<!--[[[ С тех пор, я больше структурировал информацию, написал документацию к языку, пересмотрел своё]]]--> <span class="sq"><span class="sq_brackets">[</span>И с тех пор я <!--[[[по многим вопросам]]]-->во многом поменял своё мнение, в частности, я решил делать больше упор на анализ существующих языков программирования, а также на формирование рационального/логического обоснования для элементов синтаксиса языка<!--[[[ программирования]]]-->, нежели на массовое <span class="sq"><span class="sq_brackets">[</span>и в <!--[[[подавляющем ]]]-->большинстве случаев — не аргументированное<span class="sq_brackets">]</span></span> мнение по тем или иным вопросам, так как мнение любого человека слишком уж завязано на его привычки, и непривычные вещи априори будут <!--[[[приниматься со скрипом]]]-->восприниматься с отторжением.<span class="sq_brackets">]</span></span><br />
<br />
Предлагаю познакомиться с новой статьёй <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">теперь статью можно скачать <a href="http://forum.11l-lang.org/threads/Разработка-когнитивно-эргономического-синтаксиса-для-нового-аппаратно-ориентированного-языка-программирования.8/#post-11">отсюда</a></span><span class="cu_brackets_b">}</span></span>, черновик которой я отправил Вам на почту <span class="sq"><span class="sq_brackets">[</span>можете высказать свои соображения по <!--[[[данной/]]]-->этой статье здесь же (если это будет уместно), или прошу на <a href="http://forum.11l-lang.org/threads/Разработка-когнитивно-эргономического-синтаксиса-для-нового-аппаратно-ориентированного-языка-программирования.8/">форуме</a> (можете написать и эл. письмо, но предупреждаю заранее, что я оставляю за собой право разместить его текст <span class="sq"><span class="sq_brackets">[</span>или его часть<span class="sq_brackets">]</span></span> на форуме<!--[[[время кулуарных обсуждений прошло, только открытые дискуссии!]]]-->)<span class="sq_brackets">]</span></span>.<br />
<br />
<blockquote>вот только «пространства» для улучшения синтаксиса всё меньше и меньше. ... Так что без новых концепций новым языкам трудно пробиться.</blockquote>
Полностью с Вами согласен.<br />
Вот только число новых/нереализованных значимых/существенных концепций, по-моему, ‘уже близко к <span class="sq"><span class="sq_brackets">[</span>абсолютному<span class="sq_brackets">]</span></span> нулю’/‘ещё меньше, чем улучшений синтаксиса’.<br />
Поэтому <!--[[[данный/]]]-->новый язык <span class="sq"><span class="sq_brackets">[</span>в идеале<span class="sq_brackets">]</span></span> должен включить в себя все оставшиеся удачные/подходящие нереализованные идеи по улучшению синтаксиса.<!--[[[ И это реально трудная задача. [[[Но улучшить/‘создать новую’ концепцию — задача нереально трудная.]]]]]]--> А также взять концепции, лучшие из существующих<!--[[[ (по моему мнению, это смесь С++, Rust[[[‘lifetimes’]]] и Swift[[[‘ARC, `&`’]]] [[а также щепотка Go[[[‘-‘concurrency’[https://habr.com/ru/post/464741/]:‘Golang is well known for the coroutine’’]]], D[[[‘templates/metaprogramming’]]], Nim[[[‘AST based macroses, metaprogramming’]]], Nemerle[[[‘type params infered from usage’]]], C# и Kotlin[[[‘как улучшение Java’]]]/Java]])]]]-->.<!--[[[ В данный момент её можно выразить словами Juarez: ]]]--><br />
<br />
<blockquote>Моя идея заключается в том, что эти одноимённые функции могут менять семантику в зависимости от местоположения</blockquote>
Так ведь это уже есть в C++<!--[[[ Да в C++ всё уже есть. Он такой крутой, что даже/уже не интересно. :)(:]]]-->. Оператор <pre class="inline_code">[]</pre> в <pre class="inline_code">std::vector&lt;bool></pre> (который на самом деле не массив из <pre class="inline_code">bool</pre>, а битовый массив) возвращает прокси объект, который можно читать (за счёт <!--[[[перегруженного/]]]-->перегрузки operator <pre class="inline_code">bool</pre>), и в который можно писать (за счёт перегрузки оператора <!--[[[равенства/]]]-->равно). Чтобы понять как устроен оператор <pre class="inline_code">[]</pre> в <pre class="inline_code">std::vector&lt;bool></pre> изнутри, можно <!--[[[по шагам ]‘по шагам — это F10, а тут имеется в виду F11 (а впрочем, F11 в MSVC называется ‘Шаг с заходом’ — т.е. тоже ‘шаг’ как-никак)’]]-->по шагам пройти в отладчике такой код:<br />
<pre class="code_block">
std::vector&lt;bool> v(1);
v[0] = true;
bool b = v[0];
</pre>
<br />
И хочу ещё <!--[[[сделать замечание]]]-->высказаться <!--[[[на тему]]]-->по поводу возможности разделения идентификаторов пробелом. Лично мне, <!--[[[также ]]]-->как и автору, тоже не нравится, <!--[[[как/]]]-->что символы подчёркивания бросаются в глаза в именах. Но я вижу другое решение этой проблемы — в IDE/‘среде разработки’ отображать символы подчёркивания в идентификаторах немного по-другому, в таком виде, который не так бросается в глаза:<br />
<img src="https://habrastorage.org/webt/gw/kz/es/gwkzes4_vqnxphhxqspvgzitw-i.png" /><!--[[[
nesting_level (стандартный Courier New 10)

nesting_level (подчёркивание приподнято на 2 пикселя и сокращено слева и справа на 1 пиксель)

nesting_level (аналогично предыдущему, только подчёркивание полупрозрачно (opacity: 0.5))
]]]--><!--[[[P‘./[c.txt]/9.08.14/nesting_level.png’]]]--><!--[[[Если автор опять заменит это на текст ссылки на картинку, попрошу его: ‘А почему Вы не хотите заменять ссылки на картинку тегом <img src="ссылка-на-картинку" />? Она [эта картинка] ведь совсем небольшая. [[[И/]]]А руками копировать ссылку в адресную строку, чтобы посмотреть на [[[неё/]]]картинку, очень неудобно.’]]]--><br />
<br />
А если разрешить пробелы в идентификаторах, то, боюсь, <!--[[[что будет конфликтовать]]]-->будет конфликт с ключевыми словами. Например, у меня в парсере есть переменная <pre style="display: inline">type_name</pre>. Но <pre style="display: inline">type name</pre> написать уже не получится, так как это корректное объявление нового типа. <span class="sq"><span class="sq_brackets">[</span>Впрочем, об этом автор уже <a href="http://compiler.su/utilita-transliteratsii-russkogo-Si-SiPlusPlus-v-standartnyj.php">писал</a>, только там <!--[[[был/]]]-->приводится пример с ‘int’.<span class="sq_brackets">]</span></span><br />
<br />
И к тому же, слышал ли автор<!--[[[ну не люблю я обращение на Вы с большой буквы]]]--> что-нибудь про "poetry mode" в Ruby? Там можно написать такое:<br />
<pre class="code_block">
puts value
# или даже так:
puts Integer value
</pre>
что является сокращённой записью такого кода:<br />
<pre class="code_block">
puts(value)
puts(Integer(value))
</pre>
<br />
P.S. Кстати, синтаксис форматирования сообщений/отзывов, <!--[[[выбранный/]]]-->разработанный автором, очень даже <!--[[[недурен/]]]-->неплох<!--[[[ [по мне так даже [[[чем-то/в чём-то ]]]лучше, чем Markdown!]]]]-->.<br />
Единственное, для текста программ я бы выбрал (##символы решётки##) или (``обратные апострофы``), а не знаки равенства (равенство больше подходит для обозначения двойного зачёркивания).<!--[[[

P.P.S. И ещё маленькое замечание. Такая запись
(&#61;&#61;
код
&#61;&#61;)
не должна генерировать пустую строку вначале.[[[А то получается:
┌──────────────────┐
│                  │
│ код              │
└──────────────────┘
]]]]]]--><br />
<hr />
<b>2019-08-16</b> <i>Автор сайта</i><br />
<br />
<blockquote><i>alextretyak</i>:<br />
А признак очень простой — количество цифр</blockquote>
Так признак, на мой взгляд, не так уж и прост. Но всё относительно. Вы субъективны в своих оценках, а я в своих. <i>«Каждый пишет, как он слышит. Каждый слышит, как он дышит».</i><br />
<br />
По поводу статьи я выскажусь чуть позже. Просто пока что зреют мысли.<br />
<br />
<blockquote>число новых/нереализованных значимых/существенных концепций, по-моему, «уже близко к абсолютному нулю»</blockquote>
Не хотите ли Вы сказать, что уже ничто не ново, всё Вам настолько знакомо, что в каждом новом языке Вы видите отголоски старых?<br />
<br />
<blockquote>Так ведь это уже есть в C++.</blockquote>
Ну так приведите пример. Как я должен определить функцию <pre class="inline_code">func</pre>, чтобы я мог записать:<br />
<pre class="code_block">
func() = 123;
</pre>
<br />
Спрятать символ подчёркивания, чтобы он не так бросался в глаза... Зачем? Лучше, если программист увидит «честный» текст. Но пробелы внутри идентификаторов — это вызов, это головоломка для лексического/синтаксического анализа. И тут у каждого простого решения есть свои минусы.<br />
<br />
<blockquote>я бы выбрал (##символы решётки##)</blockquote>
Я думал ещё и об эргономике. Хотелось, чтобы символы форматирования были на обеих раскладках клавиатуры на одинаковых клавишах. Остался только «!», но это НЗ на тот случай, когда ещё что-то захочется.<br />
<hr />
<b>2019-08-18</b> <i>alextretyak</i><br />
<br />
<blockquote>Не хотите ли Вы сказать, что уже ничто не ново</blockquote>
Ну... я бы немного по-другому сказал. Всё новое — довольно<!--[[[/достаточно]]]--> спорно. Взять тот же Rust с его lifetimes/borrowing (я, кстати, до сих пор не могу найти пример хорошего кода на Rust, где эти lifetimes оправданны, <!--[[[другими словами — я не понимаю, чем эта модель лучше C++]]]-->все приводимые примеры в статьях по Rust либо надуманны, либо их можно <!--[[[спокойно/]]]-->легко переписать на C++ безо всяких lifetimes).<!--[[[Или нововведения в C++ (привет ‘export import’).]]]--><br />
<br />
<blockquote>всё Вам настолько знакомо, что в каждом новом языке Вы видите отголоски старых?</blockquote>
Отчасти и это тоже.<br />
Но если посмотреть на эволюцию естественных языков, то можно заметить, например, что русский язык <!--[[[почти]]]-->существенно не менялся уже более ста лет с реформы 1918 года, и практически/фактически не менялся с 1956 года. А с наступлением цифровой эпохи ни русский, ни английский, никакие другие естественные языки, скорее всего, меняться уже <!--[[[практически ]]]-->не будут. И я боюсь, что языки программирования постигнет та же участь — <!--[[[с некоторого момента]]]-->они "заморозятся" и их эволюция завершится (также как когда-то завершилась эволюция чисел <span class="sq"><span class="sq_brackets">[</span>ведь, никто не будет спорить с тем, что числа больше не будут эволюционировать? и не только/просто числа, а язык математики, скорее всего, тоже не будет больше эволюционировать!<!--[[[ (кто не согласен — попробуйте привести новшества[?] в математике за последние лет 30[?])]]]--><span class="sq_brackets">]</span></span>).<br />
<br />
<blockquote>Ну так приведите пример. Как я должен определить функцию <pre class="inline_code">func</pre>, чтобы я мог записать: <pre class="inline_code">func() = 123;</pre></blockquote>
<pre class="code_block">
#include &lt;iostream>

void func(int i) { std::cout &lt;&lt; i; }

class Proxy
{
public:
    void operator=(int i) { func(i); }
    operator int() {
        int r;
        std::cin >> r;
        return r;
    }
};

Proxy func() { return Proxy(); }

int main()
{
    func() = 123;   // заменяется на func(123)
    int i = func(); // возвращает число из cin
}
</pre>
<br />
<blockquote>Хотелось, чтобы символы форматирования были на обеих раскладках клавиатуры на одинаковых клавишах.</blockquote>
А я использую AutoHotkey и у меня в обеих раскладках одинаковое поведение при наборе <!--[[[спец]]]-->символов (например, Shift+2 — это всегда @, Alt+2 — это всегда кавычка ", Shift+3 — это всегда решётка #, а Alt+3 — это всегда № и т.д.).<br />
Соответствующий скрипт можно посмотреть тут: <a href="http://pqmarkup.org/ru">http://pqmarkup.org/ru</a> → «‘Советы по набору’/‘способы набора’ символов одиночных парных кавычек ‘ и ’...» → «В этот же файл-скрипт можно дополнительно ещё добавить:».<br />
<br />
И, если честно, я считаю проблему переключения раскладок <!--[[[— ]]]-->несколько надуманной. Также <!--[[[как и]]]-->весьма сомнительным считаю чрезмерное стремление повысить скорость набора кода <span class="sq"><span class="sq_brackets">[</span>речь про слепую печать и т.д.<!--[[[т.д. — это [[[минимизация переключений раскладки](уже упоминается в этом предложении)]]макросы, горячие клавиши, автодополнение[‘это удобно само по себе, а не с целью повышения скорости набора’]]]]--><span class="sq_brackets">]</span></span>. На первом месте должно быть <b>качество</b> кода или текста, а не его количество. Причём я <!--[[[зачастую]]]--> наблюдал<!--[[[ именно]]]--> такую картину, что чем больше программист пишет кода, тем менее он качественный<!--[[[не обижайся Заккер, но код Саши Котляра мне больше нравится]]]-->.<br />
Вот пример из Вашей же <a href="https://habr.com/ru/post/208474/">статьи</a>:<br />
<blockquote>Ховик Меликян приводит пример, когда программа из 80000 строк кода на Си++ и 55000 строк кода на VB заменялась 10 строками на шелл-скрипте.</blockquote>
<br />
И чтобы получить более качественный текст <!--[[[сообщений]]]--><span class="sq"><span class="sq_brackets">[</span>комментариев или писем<span class="sq_brackets">]</span></span>, лично я использую два приёма:<br />
<ol>
<li>Откладываю его отправку примерно на одни сутки<!--[[[ [в течение этого срока подсознание наиболее[?] активно[?] присылает мысли по улучшению текста комментария]]]]-->.</li>
<li>Периодически перечитываю этот текст. Суммарно получается больше 10 раз точно. Ну и к чему мне эта пресловутая скорость набора, если на ревью и обдумывание/придумывание<!--[[[/составление]]]--> текста я трачу времени гораздо больше?</li>
</ol>
<br />
А что касается кириллицы в программировании, то, как можно видеть, например в языке КуМир (<a href="http://bsosh6.shkola.hc.ru/teachers_pashut/tuzov/kumir/manual.pdf">http://bsosh6.shkola.hc.ru/teachers_pashut/tuzov/kumir/manual.pdf</a>) хотя и используются кириллические ключевые слова, но математические функции оставлены на английском (например, sqrt или sin<!--[[[или sin — на уроках математики мы же пишем `sin x`, а не `син х` и ничего, к тому же это слово не английское, а латинское]]]--> <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">на уроках математики мы же пишем <pre class="inline_code">sin x</pre>, а не <pre class="inline_code">син х</pre> и ничего</span><span class="cu_brackets_b">}</span></span>). И я считаю это <!--[[[правильным/]]]-->оправданным.<br />
<br />
<blockquote>... который не так бросается в глаза:<br />
https://habrastorage.org/webt/gw/kz/es/gwkzes4_vqnxphhxqspvgzitw-i.png</blockquote>
А почему Вы не хотите заменять ссылку на картинку тегом &lt;img src="ссылка-на-картинку" />? Она <span class="sq"><span class="sq_brackets">[</span>эта картинка<span class="sq_brackets">]</span></span> ведь совсем небольшая. <!--[[[И/]]]-->А руками копировать ссылку в адресную строку, чтобы посмотреть на <!--[[[неё/]]]-->картинку, очень неудобно.<br />
</div>
</body>
</html>