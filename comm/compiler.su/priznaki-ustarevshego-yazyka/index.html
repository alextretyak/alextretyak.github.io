<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/priznaki-ustarevshego-yazyka.php">Признаки устаревшего языка (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
2021-01-16 <i><b>alextretyak</b></i><br />
<br />
На первый взгляд эта тема действительно очень актуальна и пример с устаревшим самолётом звучит крайне убедительно (можно ещё добавить к ‘последние достижения науки и техники’ в скобочках: интернет на борту и большой LCD тач экран на спинке каждого кресла самолёта).<br />
<br />
Но.<br />
Если погрузиться в детали, то не всё так однозначно/просто.<br />
<br />
Разберу конкретные признаки, приведённые в статье:<br />
<blockquote>оператор «goto»;</blockquote>
В целом согласен, т.к. достаточно break/continue с меткой, а также конструкции defer (как в Go и Swift). Все остальные варианты использования goto порождают спагетти-код.<br />
<br />
<blockquote>такая обработка исключений, которая ещё хуже «goto», когда исключение неизвестно где возникает и неизвестно куда передаёт управление;</blockquote>
Очень больная/большая тема.<br />
По вопросу исключений я и сам менял свою позицию, но решить этот вопрос одними рассуждениями — невозможно. Требуется проанализировать много-много реальных примеров, практического кода, самого разного, на разных языках программирования, с разными способами обработки ошибок, чтобы хоть как-то приблизиться к окончательному решению по данному вопросу. Лично я пока остановился на «устаревшей» модели, принятой в Python и C++, так как ничего реально лучшего (не ‘на словах’/‘в теории’ (см. моё <a href="http://web.archive.org/web/20191218102909/https://bitbucket.org/pqmarkup/pqmarkup/commits/0b7f9590718e928063a5b0d07ff35195c387ecb3">предложение</a>), а на практике) я посоветовать не могу.<br />
<br />
<blockquote>постфиксные операции «++» и «--», которые для большинства — загадочны;</blockquote>
Ещё один спорный момент. <span class="sq"><span class="sq_brackets">[</span>В Swift 3 вообще убрали «++» и «--».<span class="sq_brackets">]</span></span><br />
Но если я правильно понимаю автора, то против префиксных «++» и «--» он ничего не имеет? Тогда готов согласиться, хотя и считаю запись <pre class="inline_code">i++</pre> красивее <pre class="inline_code">++i</pre>.<br />
<br />
<blockquote>приведения типов, влекущие «тайное» изменения значения;</blockquote>
Не совсем понятно, о каком приведении типов идёт речь. Лично я считаю разумным отказ от неявного приведения типов в большинстве случаев, но оставить возможность явного приведения типов (например, строку в число и наоборот).<br />
<br />
<blockquote>нулевой указатель</blockquote>
Также непонятно, о чём речь. Автор против nullable-типов? Или имеется в виду решение этой проблемы в стиле Kotlin (<a href="https://kotlinlang.ru/docs/reference/null-safety.html">https://kotlinlang.ru/docs/reference/null-safety.html</a>), с обязательной проверкой на null?<br />
<br />
<blockquote>возможность присвоить неинициализированное значение</blockquote>
А что плохого, если язык поддерживает явное указание создания неинициализированной переменной, как например D:<br />
<blockquote><a href="https://dlang.org/spec/declaration.html#void_init"><i>https://dlang.org/spec/declaration.html#void_init</i></a>:<br />
<pre class="code_block">
int x = void;
</pre></blockquote>
Это может быть полезно для создания очень больших массивов, в которых реально использоваться будет лишь небольшая часть элементов.<br />
<br />
<blockquote>визуальный мусор типа «begin» и «end», особенно ЗАГЛАВНЫМИ буквами;</blockquote>
Согласен.<br />
<span class="sq"><span class="sq_brackets">[</span>Сюда же <span class="sq"><span class="sq_brackets">[</span>в визуальный мусор<span class="sq_brackets">]</span></span> можно добавить обязательные точки с запятой в конце строк.<span class="sq_brackets">]</span></span><br />
<br />
<blockquote>контроля возможного переполнения при арифметических операциях;</blockquote>
Уже обсуждалось <a href="http://compiler.su/filosofiya-yazyka.php#46">здесь</a>.<br />
Как итог: пока процессоры не будут поддерживать генерацию исключения при переполнении аппаратно и без оверхеда, не стоит ожидать такого контроля <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">включенного по-умолчанию, а не опционального</span><span class="cu_brackets_b">}</span></span> в языках программирования, ориентированных на высокую производительность.<br />
<br />
<blockquote>приоритетов операций а-ля Lisp или Forth;<br />
контроля границ массивов а-ля Си;<br />
возможности вернуть из функций объекты как скалярные, так и не скалярные, как фиксированного, так и переменного размера;<br />
функций — объектов первого класса;<br />
оператора «for each»;<br />
вывода типов;</blockquote>
Согласен.<br />
<br />
<blockquote>обращения по абсолютным адресам<br />
синтаксис, прогибающий под себя программистов, а-ля Forth;<br />
программирования в стиле доказательств;<br />
зрительных ориентиров в тексте, позволяющих отличить операции от операндов;</blockquote>
Не <span class="sq"><span class="sq_brackets">[</span>совсем<span class="sq_brackets">]</span></span> понял, о чём это.<br />
<hr />
2021-01-16 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>то против префиксных «++» и «--» он ничего не имеет?</blockquote>
Я протестую не против синтаксиса — префиксного или постфиксного, а <a href="http://compiler.su/postfiksnye-inkrement-i-dekrement.php">против семантики постфиксных «++» и «--»</a>.<br />
<br />
<blockquote>о каком приведении типов идёт речь</blockquote>
Например, присвоение переменной типа int значения типа long, float или double часто делается с искажением значения. В таких случаях надо или явно «убивать» лишние биты значения, либо должно быть реагирование на ошибку, если что-то теряем в лишних битах:<br />
<pre class="code_block">
char a = выбрать 8 младших битов (9876543210);  // явное обрезание лишних битов
char b =  9876543210;                           // неявная потеря битов. Если потеря и вправду
                                                // случается, возбуждаем исключение
</pre>
<br />
<blockquote>Автор против nullable-типов?</blockquote>
Да. Адрес, указывающий на незаконный участок памяти, сам незаконен. Но если обнаружилась такая незаконная ситуация, то должна быть немедленная реакция на ошибку, это описано в статье «<a href="http://compiler.su/obrabotka-oshibok.php">Обработка ошибок</a>».<!--[[[

> А что плохого, если язык поддерживает явное указание создания неинициализированной переменной… Это может быть полезно для создания очень больших массивов, в которых реально использоваться будет лишь небольшая часть элементов.
Скалярные объекты однозначно должны создаваться инициализацией. С контейнерами сложнее и пока однозначного решения не надумано.
]]несколько спорное утверждение {а что если скалярный объект определяется внутри типа, который затем помещается в контейнер/массив}, но дискутировать на эту тему не хочется]--><br />
<br />
<blockquote>пока процессоры не будут поддерживать генерацию исключения при переполнении аппаратно и без оверхеда, не стоит ожидать такого контроля в языках программирования, ориентированных на высокую производительность.</blockquote>
Биты переполнения и так устанавливаются, хотим мы этого или нет. А вот условный переход по условию «переполнение» замедляет код не в разы, а лишь на проценты — даже не на десятки процентов. Дмитрий Караваев на этом сайте <a href="http://compiler.su/ob-isklyuchyonnyh-komandah-ili-za-chto-spisali-instruktsiyu-into.php#_6">озвучивал цифры</a> на сей счёт.<br />
<br />
<blockquote>Не <span class="sq"><span class="sq_brackets">[</span>совсем<span class="sq_brackets">]</span></span> понял, о чём это<br />
<blockquote>обращения по абсолютным адресам</blockquote>
</blockquote>
<pre class="code_block">
int* ptr = (int*) 1234; // запросто получаем абсолютный адрес
*ptr = anything;        // и пишем по нему
</pre>
Неужели это нормально?<br />
<br />
<blockquote>синтаксис, прогибающий под себя программистов, а-ля Forth</blockquote>
В Форте все слова должны быть разделены пробелами, нельзя написать, например<br />
<pre class="code_block">
A+B-C
</pre>
Обязательно<br />
<pre class="code_block">
A + B — C
</pre>
А постфиксная запись? На неё мозги надо особо настраивать.<br />
<br />
<blockquote>зрительных ориентиров в тексте, позволяющих отличить операции от операндов</blockquote>
Форт вполне допускает такую запись:<br />
<pre class="code_block">
  blabla_1 blabla_2 blabla_3 
</pre>
Но что тут функция, а что операнд? Сколько было операндов в стеке до слова «blabla_2» и сколько после? Вы этого не узнаете, пока не загляните в описание каждого слова.<br />
<hr />
2021-01-19 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Я протестую не против синтаксиса — префиксного или постфиксного, а против семантики постфиксных «++» и «--».</blockquote>
Здорово, что протестуете :)(:, но что конкретно вы предлагаете?<br />
<ol>
<li>чтобы <pre class="inline_code">i++</pre> работало точно также как и <pre class="inline_code">++i</pre>;</li>
<li>запретить <pre class="inline_code">i++</pre>, оставив только <pre class="inline_code">++i</pre>;</li>
<li><span class="sq"><span class="sq_brackets">[</span>или что мне больше всего нравится:<span class="sq_brackets">]</span></span> разрешить <pre class="inline_code">++i</pre>, <pre class="inline_code">i++</pre> и <pre class="inline_code">arr[++i]</pre>, но запретить <pre class="inline_code">arr[i++]</pre>.</li>
</ol>
<br />
<blockquote>Например, присвоение переменной типа int значения типа long, float или double часто делается с искажением значения. В таких случаях надо или явно «убивать» лишние биты значения, либо должно быть реагирование на ошибку</blockquote>
С этим согласен.<br />
<br />
<blockquote><blockquote>Автор против nullable-типов?</blockquote>
Да. Адрес, указывающий на незаконный участок памяти, сам незаконен.</blockquote>
И какие альтернативы?<br />
Давайте разбирать конкретные примеры.<br />
Вот в 11l есть тип <pre class="inline_code">Словарь</pre>\<pre class="inline_code">Dict</pre> (в C++ это <pre class="inline_code">std::map</pre>). У этого типа есть метод <pre class="inline_code">find()</pre>, который по заданному ключу возвращает либо N/null\Н/нуль (если такого ключа в словаре нет), либо соответствующее значение. (Т.е. метод <pre class="inline_code">find()</pre> возвращает nullable-тип <pre class="inline_code">ValueType?</pre>.) Но чтобы использовать значение, которое вернул <pre class="inline_code">find()</pre>, необходимо либо явно проверить его на N/null\Н/нуль, либо использовать оператор <pre class="inline_code">?</pre> (например так: <pre class="inline_code">dict.find(key) ? default_value</pre>). Как вы предлагаете изменить это? Какая сигнатура и тип возвращаемого значения должны быть у метода <pre class="inline_code">find()</pre>?<br />
<br />
Вот примеры кода на 11l, где используется метод <pre class="inline_code">find()</pre>:<br />
<ol>
<li><a href="https://www.dropbox.com/sh/2i0t6hg33z14qt0/AAAvVZ6AyI9ahLju-A-i63Sva/3/3%D0%90?dl=0&amp;preview=111771%2B.11l&amp;subfolder_nav_tracking=1">111771+.11l</a> (это решение <a href="https://informatics.msk.ru/mod/statements/view.php?chapterid=111771">задачи «Множества»</a>)</li>
<li><!--[[[https://github.com/11l-lang/_11l_to_cpp/blob/master/tests/parser/Rosetta%20Code.txt#L1851]]]--><a href="https://rosettacode.org/wiki/Knapsack_problem/Bounded#11l">https://rosettacode.org/wiki/Knapsack_problem/Bounded#11l</a><!--[[[Не зря я столько времени потратил на Rosetta Code! :)(:]]]--></li>
<li><!--[[[https://github.com/11l-lang/_11l_to_cpp/blob/master/tests/parser/Rosetta%20Code.txt#L2015]]]--><a href="https://rosettacode.org/wiki/Longest_common_substring#11l">https://rosettacode.org/wiki/Longest_common_substring#11l</a></li>
<li><pre class="inline_code">V dot_pos = token.value(source). {.find(‘.’) ? .len}</pre> (данная строка соответствует 3-м строкам Python-кода <a href="https://github.com/11l-lang/_11l_to_cpp/blob/8734a745d6086c55269576674fb248c74d727222/keyletters_to_keywords.py#L22-L24">отсюда</a><!--[[[ссылка получена через ‘...’ -> ‘Copy permalink’]]]-->)</li>
</ol>
<br />
<blockquote>Но если обнаружилась такая незаконная ситуация, то должна быть немедленная реакция на ошибку, это описано в статье «<a href="http://compiler.su/obrabotka-oshibok.php">Обработка ошибок</a>».</blockquote>
Не могли бы вы указать, где именно это описано в статье «Обработка ошибок».<br />
<br />
<blockquote>Биты переполнения и так устанавливаются, хотим мы этого или нет.</blockquote>
Да, но проверка этих битов далеко не бесплатна. На современных суперскалярных процессорах <!--[[[бранчи/]]]-->условные переходы стоят дорого и, вероятно, со временем будут становиться ещё дороже.<br />
<br />
<a href="http://compiler.su/filosofiya-yazyka.php#46">Здесь</a> есть ссылка на <a href="https://news.ycombinator.com/item?id=11595398">обсуждение</a>, в котором говорится о <!--[[[двукратной просадке]]]-->двукратном падении производительности:<br />
<i>... a 2x slowdown, which isn't acceptable if Rust wants to compete with C++.</i><br />
<br />
<blockquote>А вот условный переход по условию «переполнение» замедляет код не в разы, а лишь на проценты — даже не на десятки процентов. Дмитрий Караваев на этом сайте <a href="http://compiler.su/ob-isklyuchyonnyh-komandah-ili-za-chto-spisali-instruktsiyu-into.php#_6">озвучивал цифры</a> на сей счёт.</blockquote>
Откуда эти результаты? Можно исходный код тестирующей программы, с помощью которой получены эти данные? <span class="sq"><span class="sq_brackets">[</span>Хотя, и самих конкретных данных в цифрах я не вижу в самой статье (хотя они есть в комментариях и противоречат высказыванию «замедляет код лишь на проценты»).<span class="sq_brackets">]</span></span><!--[[[
К тому же, инструкции для контроля границ и проверки переполнения (BOUND и INTO), о которых говорит Дмитрий, исключены[https://en.wikipedia.org/wiki/X86-64#Architectural_features] из системы команд x86-64.]]]--><br />
<br />
В случае озвученного мной выше замедления в 2 раза, <a href="http://web.archive.org/web/20141224183129/http://danluu.com/integer-overflow/" title="<- http://danluu.com/integer-overflow/">источник</a> приводит такой код:<br />
<pre class="code_block">
Без проверки на переполнение:
...
add     %esi, %edi
...
С проверкой на переполнение:
...
add     %esi, %edi
jo      &lt;handle_overflow>
...
</pre>
<br />
Из того же источника:<br />
Для компрессии bzip2 <!--[[[просадка в]]]-->падение производительности <span class="sq"><span class="sq_brackets">[</span>при включении контроля целочисленного переполнения<span class="sq_brackets">]</span></span> составляет 28%.<br />
А код<!--[[[ вида]]]-->:<br />
<pre class="code_block">
for (int i = 0; i &lt; n; ++i) {
  sum += a[i];
}
</pre>
выполняется в 6 раз медленнее при включении <!--[[[signed-integer-overflow]]]-->контроля переполнения!<br />
<hr />
<br />
<i>...Прошло 3 года...</i><br />
<br />
<hr />
2024-04-13 <i><b>alextretyak</b></i><br />
<br />
<!--[[[> В PDP машинные операции инкремента и декремента соответствовали исключительно *‘префиксным’ операциям Си. Никаких постфиксных операций inc/dec в ассемблере PDP быть просто не могло.
Хм. Т.е. в PDP не было инструкции *‘pop’?
В x86-32[[[, в ARM[[[
>[https://stackoverflow.com/questions/27095099/push-and-pop-in-arm <- google:‘arm pop’]:‘
    PUSH {r3}
    POP {r3}

are aliases for

    str r3, [sp, #-4]!
    ldr r3, [sp], #4
’
]]]
, да и не только]]] *‘pop eax’ означает по сути *‘eax = *esp++’[[[
>[https://asm-dvfu.ru/2]:‘
В свою очередь, инструкции `push` и `pop` также можно "разложить" на примитивные операции mov и add/sub’
]]]. Т.е. тут именно постфиксный инкремент.]]]--><b>Автор сайта</b><br />
<blockquote>В PDP машинные операции инкремента и декремента соответствовали исключительно <b>префиксным</b> операциям Си. Никаких постфиксных операций inc/dec в ассемблере PDP быть просто не могло.</blockquote>
<b>Ильдар</b><br />
<blockquote>Ахинея. Постфиксные инкремент или декремент вычисляются после ...</blockquote>
Ого, сколько тут <!--[[[экспертов в ассемблере PDP]]]-->знатоков <!--[[[архитектуры/]]]-->ассемблера PDP собралось<!--[[[, я смотрю]]]-->.<br />
Ну ладно, не обижайтесь, но <!--[[[в этом вопросе]]]-->по существу, <b>void</b><!--[[[, похоже,]]]--> оказался прав: в PDP-11 действительно есть пост<!--[[[фиксный ]]]-->инкремент <span class="sq"><span class="sq_brackets">[</span>постфиксным его называть не очень корректно, т.к. слово «постфиксный» <!--[[[может быть только]]]--><!--[[[называют]]]-->обозначает способ записи<span class="sq_brackets">]</span></span>.<br />
И хотя нужен он, в основном, для загрузки<!--[[[/сохранении]]]--> констант в регистры и для реализации выталкивания из стека (для понимания: в x86 инструкция <b>pop eax</b> означает по сути <b>eax = *esp++</b>), но архитектура набора команд PDP-11 позволяет применять <!--[[[его/]]]-->пост<!--[[[фиксный ]]]-->инкремент к любому регистру.<br />
По ссылке на wikibooks.org, которую дал <b>void</b>, <!--[[[про постинкремент ничего не понятно]]]-->полезного мало, да и в целом, его сообщения, очевидно, не располагают к вдумчивому изучению, поэтому приведу простой и наглядный пример ассемблерного кода <!--[[[на ]]]-->для PDP-11:<br />
<pre class="code_block">
clr r0           ; r0 = 0
mov #000100 r1   ; r1 = 000100
movb (r0)+ (r1)+ ; *r1++ = *r0++
movb (r0)+ (r1)+ ; *r1++ = *r0++
movb (r0)+ (r1)+ ; *r1++ = *r0++
movb (r0)+ (r1)+ ; *r1++ = *r0++
</pre>
(Обратите внимание, что приёмник указывается после источника, в отличие от Intel-синтаксиса.)<br />
Проверить код можно в симуляторе. Я нашёл симулятор PDP-11 на JavaScript, который работает в браузере и его не нужно скачивать/устанавливать<!--[[[, но его [[[автор/]]]разработчик почему-то не удосужился [[[оформить/]]]сделать HTML-страницу с симулятором, а просто опубликовал исходный код в виде текста. Для удобства я [[[оформил этот код в виде HTML-страницы и загрузил его к себе на сайт]]]сделал HTML-страницу с симулятором у себя на сайте. Вот ссылка: https://alextretyak.ru/comm/compiler.su/priznaki-ustarevshego-yazyka/pdp-11-asmsim]]]-->. Вот <a href="./pdp-11-asmsim" target="_self">ссылка</a><!--[[[: https://www.se.rit.edu/~llk/pdp11.html]]]--><!--[[[<- google:‘pdp-11 simulator’]]]-->.<br />
После копирования асм-кода в текстовое поле ‘Code’ нужно нажать кнопку ‘Compile’, а затем ‘Run’.<br />
В результате выполнения кода 4 байта по адресам 000100, 000101, 000102 и 000103 (в восьмеричной системе счисления) получат значение первых 4-х байт памяти — это машинный код <!--[[[первой инструкции (а точнее, псевдо-инструкции)]]]-->первых двух инструкций.<br />
Вообще, все инструкции в PDP-11 занимают 2 байта (<!--[[[включая/]]]-->в том числе и <b>movb (r0)+ (r1)+</b>), но для псевдо-инструкции <b>mov #000100 r1</b> <a href="https://en.wikibooks.org/wiki/Software_Engineers_Handbook/Language_Dictionary/DEC_PDP-11#Registers">используется</a> занятный <!--[[[хак/]]]-->трюк<!--[[[:]]]-->. Т.к. это по сути инструкция <b>mov (pc)+, r1</b>, после которой идёт двухбайтовая константа 000100:<br />
<pre class="code_block">
mov (pc)+, r1
.word 000100
</pre>
(Если нажать кнопочку ‘View Binary’, можно заметить, что машинный код для этой пары <!--[[[инструкций/]]]-->строк совпадает с тем, что генерируется для одной строки <b>mov #000100 r1</b>.)<br />
<br />
Для понимания работы этого <!--[[[хака/]]]-->трюка дам небольшую теоретическую справку (которая, правда, относится к процессорам CISC-архитектуры с инструкциями переменной длины, но в данном случае эта логика подходит и для PDP-11).<br />
<b>pc</b> (program counter, он же r7) — это аналог регистра eip/rip <!--[[[в]]]-->из x86. В нём хранится адрес <span class="sq"><span class="sq_brackets">[</span>номер байта в памяти<span class="sq_brackets">]</span></span> текущей выполняемой инструкции. Первая фаза <!--[[[исполнения/]]]-->обработки инструкции процессором (если не учитывать fetch) — декодирование. В процессе декодирования инструкции <!--[[[при её выполнении ]]]-->процессор увеличивает значение в регистре <!--[[[*‘pc’]]]-->pc/eip/rip на величину, равную размеру этой инструкции в байтах (в случае PDP-11 это всегда 2 байта) <span class="sq"><span class="sq_brackets">[</span>таким образом, <!--[[[при выполнении]]]-->к началу следующей фазы — выполнения инструкции — регистр pc/eip/rip будет указывать уже на следующую инструкцию<span class="sq_brackets">]</span></span>. После того, как текущая инструкция будет выполнена, процессор начинает <!--[[[исполнение/]]]-->обработку следующей инструкции, т.е. той инструкции, на которую ссылается/указывает новое значение регистра <!--[[[*‘pc’]]]-->pc/eip/rip. Если в процессе исполнения инструкции значение регистра pc/eip/rip было изменено (например, в x86 инструкция <b>jmp &lt;метка></b> <!--[[[— это по сути]]]-->по логике это просто <b>mov eip, &lt;адрес_метки></b>), то следующей исполняемой процессором инструкцией будет та, которой соответствует уже новое значение pc/eip/rip.<br />
<br />
Так вот, после декодирования инструкции <b>mov (pc)+, r1</b>, регистр <b>pc</b> увеличивается на 2 и указывает на <b>.word 000100</b>, т.е. на <!--[[[ячейку/]]]-->слово памяти в котором вместо команды хранится число 000100. В процессе исполнения инструкции <b>mov (pc)+, r1</b> это число будет прочитано из памяти и записано в регистр <b>r1</b>. В завершение исполнения инструкции сработает постинкремент и значение регистра <b>pc</b> ещё раз увеличится на 2 (не на 1, т.к. это инструкция <b>mov</b>, а не <b>movb</b>), т.е. процессор как бы <!--[[[перескочит/]]]-->«перепрыгнет» слово в памяти, в котором располагается число 000100, и начнёт <!--[[[исполнение/]]]-->обработку следующей за ним инструкции.<br />
<br />
<!--[[[Так вот, этот]]]-->Этот <!--[[[хак/]]]-->трюк возможен только благодаря поддержке пост<!--[[[фиксного ]]]-->инкремента, который в данном случае применяется к регистру <b>pc</b>.<br />
<span class="sq"><span class="sq_brackets">[</span>В архитектуре ARM64, к примеру, все инструкции имеют размер 4 байта, и чтобы загрузить в регистр 32-х или 64-х разрядную константу приходится <!--[[[извращаться с]]]-->выкручиваться с <a href="https://stackoverflow.com/questions/74477112/how-to-load-an-immediate-value-to-the-register-in-arm64" title="<- google:‘arm mov 64-bit immediate’ <- google:‘arm mov immediate to register’">literal pool</a>, либо генерировать цепочку из 16-разрядных mov-ов <span class="sq"><span class="sq_brackets">[</span><span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none"><br />
<blockquote><a href="https://developer.arm.com/documentation/dui0801/h/A64-General-Instructions/MOVL-pseudo-instruction" title="<- https://developer.arm.com/documentation/dui0801/h/A64-General-Instructions/MOV--wide-immediate- <- google:‘arm mov 64-bit immediate’"><i>https://developer.arm.com/documentation/...</i></a>:<br />
<br />
<pre class="inline_code">MOVL</pre> generates either two or four instructions.</blockquote>
</span><span class="cu_brackets_b">}</span></span><span class="sq_brackets">]</span></span>. Ну<!--[[[,]]]--> а в x86-64 проблема загрузки в регистр 32-х или 64-х разрядных констант решается переменной длиной инструкций.<span class="sq_brackets">]</span></span><br />
<br />
<!--[[[Занятно/]]]-->Примечательно, что пост<!--[[[фиксного ]]]-->декремента и пре<!--[[[фиксного ]]]-->инкремента в PDP-11 нет: есть только пост<!--[[[фиксный ]]]-->инкремент и пре<!--[[[фиксный ]]]-->декремент, который обозначается как <b>−(r0)</b>.<br />
<hr />
2024-04-13 <i><b>Автор сайта</b></i><br />
<br />
Всё, что Вы так подробно описываете, справедливо с точки зрения микропрограммного управления. К примеру, <b>push</b> сперва заталкивает что-то в стек, а потом изменяет адрес вершины стека. Но программист, даже системный, не имеет доступа к микропрограммам. Самый низкий уровень, к которому он имеет доступ, — это машинные операции, которые с точки зрения программирования в машинных кодах <b>монолитны</b>. Невозможно между первым этапом <b>push</b> (запись чего-то в стек) и вторым (изменение адреса вершины стека) втиснуть что-то ещё. Точно так же монолитны инкременты и декременты. Невозможно на уровне машинного кода между этапами выполнения этих операций втиснуть ещё какие-то действия, которые вам хочется.<br />
<br />
Поэтому говорить о постдекрементах и преинкрементах совершенно бессмысленно. По форме они префиксные (как на языке ассемблера в синтаксисе Intel, так и на уровне битов операций: коды операций идут впереди операндов), а по семантике они монолитны (что в принципе совпадает с семантикой префиксных «++» и «--» в Си).<br />
<br />
А вот постфиксные «++» и «--» в Си вычурны по семантике: их операнды могут принадлежать сразу двум операциям: например, операции присваивания и этим постфиксным операциям, которые выполняются в конце, в последнюю очередь.<br />
<pre class="code_block">
while (*dst++ = *src++);
</pre>
В этом примере получается, что сперва идёт выборка операндов, потом втискивается присвоение, потом проверка на ненулевое значение, потом выход в случае нулевого значения. И только в самом конце — постфиксные инкременты. Префиксные операции не позволяют такого разбиения на этапы.<br />
<hr />
2024-04-15 <i><b>alextretyak</b></i><br />
<br />
Позвольте немного побыть педантом.<br />
<blockquote>Всё, что Вы так подробно описываете, справедливо с точки зрения микропрограммного управления.</blockquote>
<!--[[[А что вы понимаете под микропрограммным управлением в данном случае? (Можно дать просто ссылку.) [[[Если это то, что описано в статье (https://habr.com/ru/articles/733984/[[[<- google:‘микропрограммное управление’]]]), то [[[у/]]]в ранних реализациях архитектуры PDP-11 [[[вообще нет блока]]]ещё не применялось микропрограммное управление, [[[если я правильно]]]насколько я понимаю.]]]Но ]]]-->Судя по тому, что написано <a href="https://en.wikipedia.org/wiki/PDP-11#Models">в Википедии</a>, в первых реализациях архитектуры PDP-11 (PDP–11/20 и PDP–11/15) ещё не применялось микропрограммное управление.<br />
Как реализована инструкция <b>push</b> в процессорах x86 я точно не знаю <span class="sq"><span class="sq_brackets">[</span>сколько и какие именно микрооперации ей соответствуют<span class="sq_brackets">]</span></span>, но суть в том, что в PDP-11 нет специальной инструкции <b>push</b>! И<!--[[[ его]]]--> логику <b>push</b> необходимо задавать явно в коде инструкци<!--[[[й]]]-->и, что позволяет использовать любой другой регистр в качестве адреса вершины стека, <!--[[[либо вообще]]]-->а также выбрать нестандартное направление роста стека. И при всём при этом эта логика умещается в <b>одной</b> машинной инструкции <span class="sq"><span class="sq_brackets">[</span>речь, очевидно, идёт об инструкции <b>mov</b><span class="sq_brackets">]</span></span>.<br />
<br />
<blockquote>К примеру, <b>push</b> сперва заталкивает что-то в стек, а потом изменяет адрес вершины стека.</blockquote>
<b>push eax</b> работает как <b>*--esp = eax</b>, т.е. сначала уменьшает адрес вершины стека, а затем помещает данные по этому адресу. <!--[[[Т.о. *‘esp’ всегда указывает на значение в вершине стека[[[, а не рядом]]].]]]--> Т.е. образно говоря, в <b>push</b> используется предекремент, а в <b>pop</b> — постинкремент. (И это не только в x86, а такое соглашение принято также <a href="https://stackoverflow.com/questions/27095099/push-and-pop-in-arm" title="<- google:‘arm pop’">в ARM</a> и большинстве других архитектур.)<br />
<br />
<blockquote>Самый низкий уровень, к которому он имеет доступ, — это машинные операции</blockquote>
Да, именно об этом уровне и идёт речь. PDP-11 поддерживает постинкремент и предекремент на уровне машинных операций.<br />
Машинные инструкции PDP-11 с двумя операндами имеют следующий формат:<br />
<pre class="code_block">
BOOOsssSSSdddDDD
│└┬┘└┬┘└┬┘└┬┘└┬┘
│ │  │  │  │  └─ 0-2 биты: регистр-приёмник
│ │  │  │  └──── 3-5 биты: режим адресации регистра-приёмника
│ │  │  └─────── 6-8 биты: регистр-источник
│ │  └───────── 9-11 биты: режим адресации регистра-источника
│ └─────────── 12-14 биты: код операции
└───────────────── 15 бит: признак byte-инструкций
</pre>
Например, инструкция <b>mov r3 r5</b> кодируется как 010305. 1 — код операции, 03 — источник, 05 — приёмник.<br />
Среди всех режимов адресации нам интересны следующие четыре:<!--[[[таблица составлена на основе документации[http://pdos.csail.mit.edu/6.828/2005/readings/pdp11-40.pdf][-11] (стр. 32 и 38)]]]--><br />
<pre class="code_block">
┌───┬───┬────────────────┐
│Bin│Oct│Assembler Syntax│
├───┼───┼────────────────┤
│000│ 0 │ Rn             │
│001│ 1 │(Rn)            │
│010│ 2 │(Rn)+           │
│100│ 4 │-(Rn)           │
└───┴───┴────────────────┘
</pre>
Несмотря на термин «режим адресации», режимы 2 и 4 фактически имеют семантику постфиксного инкремента и префиксного декремента из языка Си.<br />
Вот <!--[[[ещё ]]]-->примеры инструкций<!--[[[,]]]--> (в т.ч. с использованием постинкремента и предекремента):<br />
<pre class="code_block">
; Во второй колонке соответствующий код на языке Си
; В третьей колонке машинный код в восьмеричной сис. сч.
movb r3    r5   ;  r5 =  r3      ; 11│0│3│0│5
mov  r3    r5   ;  r5 =  r3      ; 01│0│3│0│5
mov (r3)   r5   ;  r5 = *r3      ; 01│1│3│0│5
mov  r3   (r5)  ; *r5 =  r3      ; 01│0│3│1│5
mov (r3)  (r5)  ; *r5 = *r3      ; 01│1│3│1│5

mov (r3)+ (r5)  ; *r5   = *r3++  ; 01│2│3│1│5
mov (r3)  (r5)+ ; *r5++ = *r3    ; 01│1│3│2│5
mov (r3)+ (r5)+ ; *r5++ = *r3++  ; 01│2│3│2│5

mov (r3) -(r5)  ; *--r5 = *r3    ; 01│1│3│4│5
...

add  r3    r5   ;  r5   +=  r3   ; 06│0│3│0│5
...
add (r3)  (r5)  ; *r5   += *r3   ; 06│1│3│1│5
add (r3)+ (r5)  ; *r5   += *r3++ ; 06│2│3│1│5
add (r3)  (r5)+ ; *r5++ += *r3   ; 06│1│3│2│5
add (r3)+ (r5)+ ; *r5++ += *r3++ ; 06│2│3│2│5
add -(r3) (r5)  ; *r5   += *--r3 ; 06│4│3│1│5
...

sub  r3    r5   ;  r5   -=  r3   ; 16│0│3│0│5
...
</pre>
<!--[[[
> Невозможно на уровне машинного кода между этапами выполнения этих операций втиснуть ещё какие-то действия, которые вам хочется.
Возможно, у нас просто различие в понимании на уровне терминологии. [[[Прошу быть конкретнее и приводить]]]Но программирование и архитектура компьютера вполне конкретные вещи, поэтому для лучшего понимания
]]]--><br />
<blockquote>Поэтому говорить о постдекрементах и преинкрементах совершенно бессмысленно.</blockquote>
<!--[[[Тут опять же]]]-->Это вопрос терминологии. Называть режимы адресации (Rn)+ и -(Rn) постинкрементом и предекрементом<!--[[[ соответственно]]]--> придумал не я. Это хотя и не официальное их наименование <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">официально в <a href="http://pdos.csail.mit.edu/6.828/2005/readings/pdp11-40.pdf" title="<- https://programmer209.wordpress.com/2011/08/03/the-pdp-11-assembly-language/ <- google:‘PDP-11 push pop’">документации</a> DEC они называются автоинкремент и автодекремент<!--[[[, соответственно]]]--></span><span class="cu_brackets_b">}</span></span>, но вполне распространённое:<br />
<blockquote><a href="https://news.ycombinator.com/item?id=24817321" title="<- google:‘pdp-11 post increment’"><i>https://news.ycombinator.com/item?id=24817321</i></a>:<br />
<br />
... pre/post-increment/decrement addressing is baked into the instruction set...<br />
...<br />
... 4 is the pre-decrement mode ...</blockquote>
<blockquote><a href="https://stackoverflow.com/questions/17436141/kr-seems-to-prefer-pre-increment" title="<- google:‘pdp-11 post increment’"><i>https://stackoverflow.com/questions/17436141/...</i></a>:<br />
<br />
PDP-11 had post-increment and pre-decrement.</blockquote>
<br />
<blockquote><pre class="code_block">
while (*dst++ = *src++);
</pre>
... потом выход в случае нулевого значения. И только в самом конце — постфиксные инкременты.</blockquote>
И всё-таки инкременты выполняются <b>перед</b> выходом. <!--[[[Иначе бы [[в случае выхода они бы не выполнялись.]]
Как это в конце? Инкременты dst++ и src++ производятся на каждой итерации цикла, а не один раз после его завершения. Вот пруф:]]]-->А если посмотреть на ассемблерный код, который генерирует компилятор gcc для данного примера (<a href="https://godbolt.org/z/zT4EoTh6W">https://godbolt.org/z/zT4EoTh6W</a>), то видно, что инкременты выполняются даже перед присваиванием (причём выполняются полностью — компилятор не только инкрементирует значение в регистрах, соответствующих dst и src, но и <!--[[[записывает/]]]-->сохраняет их в отведённой для них памяти для локальных переменных <b>перед</b> присвоением *dst<!--[[[
Странно как-то. Как же тогда запись осуществляется по старому значению dst, если dst инкрементируется перед присваиванием?
А, теперь понятно: компилятор хранит копию неинкрементированного значения src и dst в регистрах.
]]]-->). <span class="sq"><span class="sq_brackets">[</span>Почему компилятору разрешено так поступать — это уже другой вопрос, который разбирать в деталях здесь будет уже неуместно, как я считаю.<span class="sq_brackets">]</span></span><br />
<!--[[[Давайте перепишем]]]-->Вообще, если переписать этот пример с использованием <b>if</b> и <b>goto</b><!--[[[, [[[т.к. в ассемблере нет *‘while’]]]то окажется :]]]--><br />
<pre class="code_block">
begin_while:
bool while_condition = (*dst++ = *src++) != 0;
if (!while_condition) goto end_while;
// Здесь располагается тело цикла while, но в данном случае оно пустое
goto begin_while;
end_while:
</pre>
то окажется, что система команд PDP-11 может в точности повторить этот Сишный код:<br />
<!--[[[
mov #000001, r0
;mov #000000, r0

beq iszero
br notzero

iszero:
mov #1, 00100
halt

notzero:
mov #1, 00102
halt
]]]--><pre class="code_block">
mov #100 r0 ; r0 - src
mov #200 r1 ; r1 - dst

begin_while:
movb (r0)+ (r1)+ ; bool while_condition = (*dst++ = *src++) != 0;
beq end_while    ; if (!while_condition) goto end_while;
br begin_while   ; goto begin_while;
end_while:
halt

.= 100
; Копируемые данные:
.word 123456
.word 007700
.word 000000

.= 200
; Область памяти назначения забиваем мусором
; (для проверки того, что данные из источника
; скопировались полностью, включая завершающий
; нулевой байт)
.word 111111
.word 111111
.word 111111
.word 111111
</pre>
После выполнения <!--[[[данной/](тавтология: через слово идёт слово «данные»)]]-->этой программы данные по адресу 100 (включая завершающий нулевой байт) скопируются в память по адресу 200.<br />
<hr />
2024-04-18 <i><b>void</b></i><br />
<br />
<blockquote>Почему компилятору разрешено так поступать — это уже другой вопрос, который разбирать в деталях здесь будет уже неуместно, как я считаю</blockquote>
Уместно-уместно. Причина одна, и это тоже один из признаков <b>устаревшего языка</b>: <i>Undefined Behaviour</i> в стандарте, причём <i>UB is not error</i>, а намёки компилятору:<br />
<div class="note">Вот здесь есть дырка в понимании поведения абстрактного исполнителя интерпретатором/модели памяти и верификатора стандарта компилятором.</div>
В нормально, корректно определённом языке на мой взгляд — не должно быть UB в принципе. Как, например, определено в Ada. В С же эта <i>дыра в понимании</i> вполне приемлема — в контексте того, что поведение по умолчанию в случае UB будет такое, как в нижележащем варианте абстрактного исполнителя:<br />
<ol>
<li>интерпретируемого BCPL, откуда в Си пришла семантика указателей (дырявая),</li>
<li>вот этот пример с ассемблером CISC процессоров PDP-11 либо MC68k.</li>
</ol>
Налицо <i>протечка абстракций</i> из более нижележащего уровня или просто исторически раннего. Chris Lattner, автор компилятора LLVM где-то писал в рассылке, что на самом деле это мешает. Действительно низкоуровневый язык мог бы более эффективно загрузить вычислительные узлы.<br />
<br />
Но у компилятора Си нет такой информации. Из-за UB он должен перебирать варианты, пытаться оптимизировать, самостоятельно догадываться, как именно это UB следует понимать. Что на мой взгляд довольно глупо — более корректно было бы более правильно определить операционную семантику абстрактного исполнителя, затыкая эту <b>дыру в понимании</b> стандарта, чтобы никакого UB <b>в принципе</b> в правильно определённом языке не возникало, <i>по определению</i>.<br />
<hr />
2024-04-19 <i><b>Автор сайта</b></i><br />
<br />
<b>alextretyak</b><br />
<blockquote>И всё-таки инкременты выполняются перед выходом.</blockquote>
Да, здесь Вы правы, когда выход сделан, то поздно <s>пить Боржоми</s> делать инкремент. Но как инкремент может делаться <b>перед</b> присвоением? ...<br />
...<br />
Выполню этот цикл:<br />
<pre class="code_block">
    while (*dst++ = *src++);
</pre>
...<br />
То есть произошло следующее:<br />
<ul>
<li>были скопированы байты 0 — 7, включая седьмой с содержимым 0,</li>
<li>содержимое 0 седьмого байта послужило сигналом в выходу; этот факт процессор запомнил,</li>
<li>был выполнен постинкремент переменных src и dst и они стали отличиться от исходных значений не на 7, а на 8!</li>
<li>и, наконец, выход.</li>
</ul>
<br />
То есть постинкременты делаются <b>после</b> присваивания! Да и как они сделались бы после инкремента? Ведь тогда бы произошло присвоение 8-го байта! А этого не было.<br />
<br />
... постфиксный инкремент в Си позволяет втискивать перед финальным увеличением много чего. В отличие от машинной команды, которой нельзя передать другую машинную команду, которую надо выполнить до завершения первой. Поэтому правильно Вы говорите, что для машинных кодов постинкременты — это вопрос терминологии. Видимо разработчики, реализуя в железе машинные команды, вынесли терминологию со своей кухни на всеобщее обозрение.<br />
<br />
<b>void</b><br />
<blockquote>это тоже один из признаков устаревшего языка: Undefined Behaviour в стандарте, причём UB is not error</blockquote>
Так и есть!!! Спасибо, что Вы взяли меня за руку и подвели к слону, которого я и не заметил. И сам нарывался на неопределённое поведение и возмущался этим. И коллеги. И сколько пишут про это. Это должно идти первым пунктом в этой статье! А я не замечал слона в центре комнаты. И Ada, конечно, хороший пример.<br />
<hr />
2024-04-23 <i><b>alextretyak</b></i><br />
<br />
<b>void</b><br />
<blockquote>Уместно-уместно. Причина одна, и это тоже один из признаков устаревшего языка: Undefined Behaviour</blockquote>
Undefined behaviour — штука, конечно, скверная. Вот только в коде <b>while (*dst++ = *src++);</b> нет никакого undefined behaviour<!--[[[, т.е.]]]-->. У выражения <b>*dst++ = *src++</b> вполне себе определённое поведение и его <!--[[[результат]]]-->производимый эффект не зависит от порядка <!--[[[вычисления/]]]-->выполнения инкрементов и присваивания, т.к. инкрементируются и присваиваются <!--[[[разные/]]]-->различные сущности: инкрементируется <b>dst</b>, а присваивается <b>*dst</b>. Вот если написать <b>dst++ = src++</b>, тогда здесь будет UB, т.к. <b>dst</b> меняется более одного раза (в <b>++</b> и в <b>=</b>) между соседними точками следования. <b>(*dst)++ = (*src)++</b> — это также UB. И <!--[[[даже ]]]--><b>++dst = 0</b><!--[[[ UB]]]-->. И <b>dst++ = 0</b>. Но не <b>*dst++ = 0</b>!<br />
Подробнее можно почитать <a href="https://stackoverflow.com/a/4176333/2692494">здесь</a> (там же есть комментарий, почему <b>*p++ = 4</b> не является UB<!--[[[.]]]-->).<br />
<br />
<b>Автор сайта</b><!--[[[
Как-то вы не очень ясно выражаетесь, Юрий. То ли я не до конца понимаю ваши формулировки, то ли имеет место быть неверное понимание работы данного цикла.
]]]--><!--[[[>‘
То есть произошло следующее:

• были скопированы байты 0 — 7, включая седьмой с содержимым 0,
’
Это верно.
> • содержимое 0 седьмого байта послужило сигналом в выходу; этот факт процессор запомнил,
Что значит «этот факт процессор запомнил»? Куда запомнил, зачем запомнил?
]]]--><br />
<blockquote>То есть произошло следующее:<br />
<br />
• были скопированы байты 0 — 7, включая седьмой с содержимым 0,<br />
• содержимое 0 седьмого байта послужило сигналом в выходу; этот факт процессор запомнил,<br />
• был выполнен постинкремент переменных src и dst и они стали отличиться от исходных значений не на 7, а на 8!<br />
• и, наконец, выход.</blockquote>
Почему-то в первом пункте вы говорите о результате работы всего цикла, а последние три относятся только к последней итерации цикла.<br />
<!--[[[
Выше я уже переписывал этот цикл с использованием *‘if’ и *‘goto’. Давайте перепишу ещё и таким образом:
#(C)‘
while (true) {
    bool while_condition = (*dst++ = *src++) != 0;
    if (!while_condition)
        break;
}
’
Сгенерированный код во всех трёх случаях одинаковый.]]]--><br />
Давайте я разберу ассемблерный код, который сгенерировал компилятор gcc (ссылку я уже приводил: <a href="https://godbolt.org/z/zT4EoTh6W">https://godbolt.org/z/zT4EoTh6W</a>).<br />
<pre class="code_block">
.L2:
        mov     rdx, QWORD PTR [rbp-8]  ; rdx = src   ; prev_src = src
        lea     rax, [rdx+1]            ; rax = rdx+1
        mov     QWORD PTR [rbp-8], rax  ; src = rax   ; ++src
        mov     rax, QWORD PTR [rbp-16] ; rax = dst   ; prev_dst = dst
        lea     rcx, [rax+1]            ; rcx = rax+1
        mov     QWORD PTR [rbp-16], rcx ; dst = rcx   ; ++dst
        movzx   edx, BYTE PTR [rdx]     ; dl = *rdx
        mov     BYTE PTR [rax], dl      ; *rax = dl   ; *prev_dst = *prev_src
        movzx   eax, BYTE PTR [rax]     ; al = *rax
        test    al, al                  ; if (al != 0)
        jne     .L2                     ;     goto .L2
</pre>
(Оптимизации были выключены, чтобы компилятор генерировал максимально понятный код.)<br />
Как можете сами убедиться, оба инкремента (<b>src++</b> и <b>dst++</b>) выполняются перед присвоением<!--[[[, но код отрабатывает корректно, т.к.]]]-->. Как же тогда запись осуществляется по старому значению <b>dst</b>, если <b>dst</b> инкрементируется перед присваиванием? Всё просто: компилятор<!--[[[
#rec##audio#[REC_0003090.wav]
Не «компилятор» хранит копию неинкрементированного значения src и dst, а «процессор». А компилятор *‘сохраняет’ копию неинкрементированного з...
]]]--> <!--[[[хранит/]]]-->сохраняет копию неинкрементированного значения <b>src</b> и <b>dst</b> в регистрах.<br />
<br />
Вот цитата из стандарта C++ (раздел 7.6.1 Postfix expressions, 7.6.1.5 Increment and decrement):<br />
<blockquote>The value computation of the <b>++</b> expression is sequenced before the modification of the operand object.</blockquote>
Google-перевод:<!--[[[Deep перевёл хуже:
[Вчера вроде как по-другому переводил, слова ‘модификацией’ в переводе не было.]
> Вычисление значения выражения ++ происходит перед модификацией объекта-операнда.
]]]--><br />
<blockquote>Вычисление значения выражения <b>++</b> выполняется до модификации объекта операнда.</blockquote>
<!--[[[Т.е. сначала компилятор вычисляет выражение dst, затем *dst и только потом [[[увеличивает/]]]инкрементирует dst [и аналогично для src]. При этом порядок выполнения инкрементов и присваивания не определён, хотя в данном случае это роли не играет, т.к. присвоение *dst = *src в любом случае будет выполняться для *‘не’инкрементированных значений dst и src.
]]]--><br />
Помните я приводил код функции <b>postfix_increment()</b> в <a href="http://compiler.su/postfiksnye-inkrement-i-dekrement.php#25">этом сообщении</a>?<br />
Компилятор делает буквально следующее:<br />
<pre class="code_block">
while (*postfix_increment(dst) = *postfix_increment(src));
</pre>
Т.е. сначала полностью выполняется правая сторона присваивания — функция <b>postfix_increment(src)</b>, при этом значение <b>src</b> инкрементируется, а предыдущее (неинкрементированное) значение, которое вернула функция (назову его <b>prev_src</b>), сохраняется в регистре. Затем полностью выполняется левая сторона присваивания — <b>postfix_increment(dst)</b>. И только потом присваивание <b>*prev_dst = *prev_src</b>, и значение <b>*prev_dst</b> сравнивается с нулём.<br />
</div>
</body>
</html>