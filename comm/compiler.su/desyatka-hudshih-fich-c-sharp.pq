Н‘‘Десятка худших фич C# (ссылка на статью)’[http://compiler.su/desyatka-hudshih-fich-c-sharp.php]’

Комментарии:
---
2022-05-22 ~‘*‘alextretyak’’

> Было бы неплохо иметь при определении, допустим, «>» и «==» получать уже определённую «>=»
Если определён оператор «>», то операторы «<», «>=», «<=» и даже «==» можно получить из[[[/через]]] него:
#‘
fn `<`(T a, T b) {return b > a}
fn `>=`(T a, T b) {return !(a < b)}
fn `<=`(T a, T b) {return !(b < a)}
fn `!=`(T a, T b) {return a < b or b < a} // равнозначно return a < b or a > b
fn `==`(T a, T b) {return !(a != b)}
’
---
2022-05-23 ~‘*‘Автор сайта’’

*‘alextretyak’

То, что Вы написали — это замечательно. Правда, я хотел сказать о другом. О том, что после описания «>» (если опираться на Ваш пример), неплохо бы иметь уже описанными остальные операторы: «<», «>=», «<=», «!=», «==» — без необходимости их описания. Например:
#‘
fn `>`(T a, T b) {. . .}        // Описание «>» (в Вашей нотации)
// После этого «<», «>=», «<=», «!=», «==» являются описанными
if (a == b)                     // Применяем «==», которую не пришлось описывать
’
Хотя этот код не будет максимально эффективным. Например, оператор «==» разворачивается в
#‘
!(a != b)
’
который, в свою очередь разворачивается в
#‘
!(a < b or a > b)
’
То, что Вы написали, просто замечательно для математиков. А системный программист увидет в этом изъяны [[[(]]]:)
