<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/postfiksnye-inkrement-i-dekrement.php">Постфиксные инкремент и декремент (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
2024-03-27 <i><b>alextretyak</b></i><br />
<br />
И всё-таки, иногда постфиксные операции <!--[[[довольно удобны]]]-->значительно удобнее.<br />
<br />
Вот у меня есть такой метод в классе:<br />
<pre class="code_block">
    uint8_t read_byte()
    {
        return buffer[buffer_pos++];
    }
</pre><!--[[[
Ну ладно, не совсем такой. Но если так хотите, можно и реальный код записать в одну строку:
#(C++)‘
    uint8_t read_byte()
    {
        return !at_eof() ? buffer[buffer_pos++] : throw UnexpectedEOF();
    }
’
(Но я не люблю использовать #(C++)‘throw’ в выражениях.)
]]]-->
Если отказаться от постфиксного инкремента, тогда придётся этот метод переписать так:<br />
<pre class="code_block">
    uint8_t read_byte()
    {
        uint8_t result = buffer[buffer_pos];
        ++buffer_pos;
        return result;
    }
</pre>
<br />
Мало того, что строчек кода в теле метода стало в три раза больше, так ещё и пришлось вводить лишнюю сущность и давать ей имя <span class="sq"><span class="sq_brackets">[</span>временная переменная result<span class="sq_brackets">]</span></span>.<br />
<br />
<blockquote>..., а свойство таких операций выполнять действие над операндом по окончании всех остальных операций.</blockquote>
А <!--[[[что ]]]-->если лишить эти операции такого свойства<!--[[[, сделав их полностью определёнными]]]-->?<br />
<br />
Что, если постфиксные инкремент и декремент <b>всегда</b> будут определены таким образом:<br />
<pre class="code_block">
template &lt;typename T> T operator++(T&amp; a, int)
{
    T temp = a; // для типа `T` должен быть определён конструктор копирования
    ++a;        // для типа `T` должен быть определён префиксный оператор `++`
    return temp;
}
// и аналогично для `--`
</pre>
<!--[[[
Нужно ещё придумать, что делать с
>[https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith <- https://en.cppreference.com/w/cpp/language/operator_incdec <- google:‘c++ postfix increment’]:‘
. operator++() performs atomic pre-increment. Equivalent to #(С++)‘return fetch_add(1) + 1;’.
. operator++(int) performs atomic post-increment. Equivalent to #(С++)‘return fetch_add(1);’.
’
< Что-что. Просто использовать специальные методы в таком случае (fetch_increment() или что-то вроде того). Как будто это так часто требуется, чтобы менять семантику постфиксных ++/-- из-за такой мелочи.
]]]--><br />
В этом случае появляется сразу несколько плюсов:<br />
<ul>
<li>поведение постфиксных операций становится полностью детерминированным: <!--[[[запись/]]]-->выражение <b>a++ − a++</b> всегда <!--[[[вычисляется как]]]-->возвращает <b>-1</b> и при этом увеличивает <b>a</b> на 2 <span class="sq"><span class="sq_brackets">[</span>правда при условии, что компилятор при расчёте разности вычисляет уменьшаемое (левый <!--[[[аргумент/]]]-->операнд) всегда перед вычитаемым (правы<!--[[[й]]]-->м операндом)<span class="sq_brackets">]</span></span>;</li>
<li>исчезает различие в поведении постфиксных операций для встроенных в язык типов (int, float и др. — для них «++» и «--» выполняются после выполнения всего выражения) и для пользовательских типов (для них <!--[[[будут применяться]]]-->применяются переопределённые постфиксные «++» и «--»);</li>
<li>пропадает «<!--[[[магия/]]]-->шаманство» в виде дополнительного неиспользуемого аргумента при переопределении постфиксных операций «++» и «--», т.к. <!--[[[пользователь/]]]-->программист вообще не может переопределить постфиксные «++» и «--», а только префиксные (постфиксные всегда генерируются компилятором автоматически);</li>
<li><!--[[[
Дополнительно[[[,]]] ]]]-->это <!--[[[упростит/]]]-->упрощает <!--[[[компилятор/]]]-->реализацию, т.к. запись <b>a++</b> компилятор может просто заменять на вызов служебной функции <b>postfix_increment(a)</b>, которая реализована <!--[[[следующим образом]]]-->аналогично<!--[[[ постфиксному инкременту]]]-->:<br />
<pre class="code_block">
template &lt;typename T> T postfix_increment(T&amp; a)
{
    T temp = a;
    ++a;
    return temp;
}
</pre></li>
</ul>
<br />
Ну и в качестве оптимизации, считаю, что <!--[[[запись/]]]-->операция<!--[[[/выражение]]]--> <b>a++</b> должна <!--[[[быть равнозначна]]]-->автоматически заменяться компилятором на <b>++a</b> в том случае, когда результат операции не используется. Всё-таки постфиксный инкремент<!--[[[ в коде]]]--> выглядит красивее префиксного. Неспроста же Бьёрн назвал язык C++, а не ++C<!--[[[ (хотя по смыслу последний подходит больше)]]]-->. :)(: <!--[[[Хотя тут скорее дело в произношении: «си-плас-плас» явно лучше, чем «плас-плас-си».]]]--><!--[[[

Хотя, выражения вида #(С)‘a++ - a++’ лучше запретить.
Ещё, я бы запретил #(C)‘dst[i] = src[i++]’, но разрешил #(C)‘dst[i++] = src[i]’.
]]]--><br />
<hr />
2024-03-27 <i><b>MihalNik</b></i><br />
<br />
<blockquote>Если отказаться от постфиксного инкремента, тогда придётся этот метод переписать так</blockquote>
Есть ещё один "крамольный" вариант — разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных. А return можно переименовать в result.<br />
<hr />
2024-04-01 <i><b>veector</b></i><br />
<br />
<blockquote>Вот у меня есть такой метод в классе:<br />
<pre class="code_block">
    uint8_t read_byte()
    {
        return buffer[buffer_pos++];
    }
</pre></blockquote>
Когда я вижу такой код на ревью (проверке), то сразу выдаю минус в карму.<br />
<br />
<blockquote>Есть ещё один "крамольный" вариант — разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных. А return можно переименовать в result.</blockquote>
<b>MihalNik</b>, кстати, это один из самых правильных вариантов, даже в одном известном языке применяется, но нынче не очень популярном.<br />
<hr />
2024-04-02 <i><b>Автор сайта</b></i><br />
<br />
<pre class="code_block">
buffer_pos++
</pre>
<blockquote>разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных.</blockquote>
В приведённых выше примерах есть неясность. Если <b>buffer_pos</b> локальная, то вообще непонятно, зачем её увеличивать перед выходом из функции, ведь её значение не возвращается оператором return. Если она глобальная, то смысл увеличения есть, но есть резонный вопрос — зачем она глобальная?!<br />
<br />
Есть ещё вариант, когда <b>buffer_pos</b> — волатильная, тогда изменять её могут для произведения побочного эффекта. Но этот вариант вообще ни в какие ворота не лезет.<br />
<hr />
2024-04-04 <i><b>alextretyak</b></i><br />
<br />
<b>MihalNik</b><br />
<blockquote>Есть ещё один "крамольный" вариант — разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных. А return можно переименовать в result.</blockquote>
Хороший вариант, согласен. Жаль только, что не так много языков программирования, которые поддерживают специальную переменную result.<br />
<br />
<b>Автор сайта</b><br />
<blockquote>Если <b>buffer_pos</b> локальная</blockquote>
Как же она может быть локальной, когда в теле метода она не объявляется?<br />
(Да, приведённая строка кода является <b>полным</b> <!--[[[кодом реализации]]]-->телом метода <b>read_byte()</b>.)<br />
<br />
<blockquote>Если она глобальная, то смысл увеличения есть, но есть резонный вопрос — зачем она глобальная?!</blockquote>
<!--[[[ну можно ж]]]-->Из моих слов «такой метод в классе» можно было догадаться, что в коде речь идёт о переменных-членах класса. И <b>buffer</b>, и <b>buffer_pos</b> являются переменными-членами.<br />
<br />
<b>veector</b><br />
<blockquote>то сразу выдаю минус в карму.</blockquote>
Просто выдаёте и всё?<br />
А <i>конкретные</i> советы/рекомендации (о том, какой код был бы лучше в данном случае)<!--[[[,]]]--> вы не даёте из принципа, я так полагаю<!--[[[/понимаю]]]--><!--[[[?/]]]-->. :)(:<br />
<br />
<blockquote>даже в одном известном языке применяется, но нынче не очень популярном.</blockquote>
Почему вы так не любите конкретику? Что мешало сразу просто указать название этого языка программирования, как будто это прям какая-то коммерческая тайна.<br />
<br />
Из более-менее популярных языков программирования, которые поддерживают специальную переменную для возврата значения, я могу назвать только BASIC, Pascal/Delphi<!--[[[,]]]--> и Nim (причём в <!--[[[первом/]]]-->первых двух эта переменная является именем функции, а в последнем используется специальная переменная <b>result</b>).<br />
Но в C++ такой возможности нет, а потому вопрос ‘а как более правильно реализовать <b>return buffer[buffer_pos++];</b>’ остаётся открытым.<br />
<hr />
2024-04-05 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b>, не, я добрый, всегда, всем, все разъясняю.<br />
<hr />
2024-04-07 <i><b>alextretyak</b></i><br />
<br />
<blockquote>всегда, всем, все разъясняю.</blockquote>
Ну, в таком случае,<!--[[[/тогда]]]--> хотелось бы услышать <span class="sq"><span class="sq_brackets">[</span>хотя бы краткое<span class="sq_brackets">]</span></span> разъяснение, что именно вас не устраивает в <!--[[[таком/]]]-->процитированном коде <span class="sq"><span class="sq_brackets">[</span>в сообщении от 2024-04-01<span class="sq_brackets">]</span></span> и какой код был бы лучше в данном случае?<br />
<hr />
2024-04-08 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b>, ну тут всё же просто: Вы же считываете значение из массива, 1 байт, не проверяя номер элемента.<br />
<hr />
2024-04-08 <i><b>Автор сайта</b></i><br />
<br />
<b>alextretyak</b>, поделитесь тайным знанием, почему ваши сообщения в последнее время всегда делаются в 00:00 🙃<br />
<hr />
2024-04-10 <i><b>alextretyak</b></i><br />
<br />
<b>veector</b><br />
<blockquote>Вы же считываете значение из массива, 1 байт, не проверяя номер элемента.</blockquote>
Ах, вот оно в чём дело.<br />
Просто <!--[[[тема/]]]-->название<!--[[[/заголовок]]]--> <!--[[[данной/]]]-->обсуждаемой<!--[[[ тут]]]--> статьи — «Постфиксные инкремент и декремент», поэтому я решил немного сократить тело метода <b>read_byte()</b> для наглядности<!--[[[, чтобы не отвлекаться на несущественные детали]]]-->.<br />
Тем более, что в C++ такой код вполне может быть допустим в том случае, когда <b>buffer</b> — это не <!--[[[голый/]]]-->просто указатель или массив в стиле Си, а объект-экземпляр<!--[[[
>[https://ru.stackoverflow.com/questions/2723/Чем-отличается-экземпляр-класса-от-объекта-класса <- google:‘объект класса’]:‘`class object` — этот объект, в котором хранится, так сказать, информация о классе.’
]]]--> класса массива с контролем выхода за границы. Тогда внутри перегруженного <b>operator[]</b> будет та самая «проверка номера элемента», о которой вы говорите и которую в языке Си пришлось бы вставлять в код явно.<br />
<br />
Вообще, полный код метода <b>read_byte()</b>, который используется в <a href="https://github.com/alextretyak/file_for_humans/blob/master/IFile.hpp">реальном <!--[[[коде/]]]-->проекте</a>, выглядит так:<br />
<pre class="code_block">
    uint8_t read_byte()
    {
        if (at_eof())
            throw UnexpectedEOF();
        return buffer[buffer_pos++];
    }
</pre>
<span class="sq"><span class="sq_brackets">[</span>Метод <b>at_eof()</b>, несмотря на название, не только проверяет на конец файла, а очень много чего делает: аллоцирует buffer, если он ещё не был проаллоцирован, читает из файла данные в buffer<!--[[[/‘заполняет buffer данными из файла’]]]-->, если buffer_pos указывает на конец буфера, и при этом сбрасывает buffer_pos в 0 и <!--[[[сдвигает файловый указатель]]]-->обновляет позицию начала буфера в файле для корректной работы метода tell(), а если прочитать файл не удалось, то <!--[[[возбуждает/]]]-->порождает исключение (таким образом, к моменту выполнения кода buffer[buffer_pos++] содержимое buffer уже подготовлено и buffer_pos гарантированно <!--[[[указывает/]]]-->находится в допустимых пределах).<span class="sq_brackets">]</span></span><br />
Но даже <!--[[[такой код]]]-->тако<!--[[[е тело]]]--><!--[[[й код тела]]]-->е тело метода вполне можно <!--[[[записать в одну строку кода]
(Вообще, в C++ любой код без директив препроцессора можно записать в одну строку:
#(С++)‘
if (at_eof()) throw UnexpectedEOF(); return buffer[buffer_pos++];
’)
]]-->впихнуть в один return:<br />
<pre class="code_block">
    uint8_t read_byte()
    {
        return !at_eof() ? buffer[buffer_pos++] : throw UnexpectedEOF();
    }
</pre>
<!--[[[Но/]]]-->Просто я не люблю использовать <b>throw</b> в выражениях, поэтому <!--[[[я]]]-->и не стал так писать в реальном коде.<br />
<br />
Но возвращаясь к теме статьи: против использования постфиксного инкремента в теле метода <b>read_byte()</b> вы ничего не имеете?<br />
<br />
<b>Автор сайта</b><br />
<blockquote>поделитесь тайным знанием, почему ваши сообщения в последнее время всегда делаются в 00:00</blockquote>
Ну, <!--[[[как]]]-->не сказать, что<!--[[[ ]]]-->бы в «последнее». Уже более 4-х с половиной лет,<!--[[[ в каждом своём сообщении/комментарии](не уверен, что в каждом {например, вот[http://compiler.su/pravila-yazyka-strokovye-literaly.php#7] дополнительное сообщение, опубликованное в 04:00})]]--> начиная с <a href="http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php#12">этого <!--[[[комментария/]]]-->сообщения</a>. :)(:<br />
<br />
А тайного знания тут никакого нет: просто я давно заметил, что если отправлять сообщения не сразу же после написания, а <!--[[[давать им немного полежать]]]-->отложить их отправку/публикацию хотя бы на несколько часов и периодически перечитывать текст<!--[[[ сообщений]]]--> перед отправкой, то качество сообщений при этом<!--[[[ существенно]]]--> повышается. Мозг в фоновом режиме вспоминает какие-то дополнительные детали/уточнения, которые так и просятся добавить<!--[[[ себя [уточнения]]]]--> в сообщение в процессе его перечитывания. Если в сообщении были какие-то излишне эмоциональные/резкие высказывания, то по прошествии времени это становится хорошо заметно и получается либо <!--[[[перевести/]]]-->перефразировать их в более конструктивном ключе, либо появляется решимость вообще вырезать/удалить их из сообщения. <!--[[[Ну и](чуть ниже уже есть ‘ну’[:‘Ну, с одной стороны’])]]-->Также ошибки/опечатки в тексте лучше обнаруживаются и исправляются.<br />
Почему я выбрал время отправки сообщений именно 00:00 <span class="sq"><span class="sq_brackets">[</span>по Москве<span class="sq_brackets">]</span></span>? Ну, с одной стороны, в этом есть что-то <!--[[[математически-программистически]/]]-->програм<i>мистически</i> красивое. А с другой, это оказалось ещё и очень удобное для меня время: во Владивостоке это 7:00 утра, и я успеваю на свежую голову ещё разок хорошенько обдумать сообщение перед отправкой<!--[[[ на свежую голову]]]-->.<br />
<span class="sq"><span class="sq_brackets">[</span>Если интересует техническая сторона вопроса, то никакими скриптами/ботами я не пользуюсь. Просто сверяю системное время с https://time.is и нажимаю кнопку отправки сообщения примерно в 7:00:30. Вероятность того, что время на сервере, куда я отправляю сообщение, расходится с time.is более<!--[[[,]]]--> чем на 30 секунд очень мала, поэтому пока что получалось отправлять сообщения без ошибок точно в 0x:00<!--[[[
> Почему 0x:00, а не 00:00?
< [:‘дополнительное сообщение, опубликованное в 04:00’] (и там же рядом есть опубликованное в 01:00)
]]]-->.<span class="sq_brackets">]</span></span><!--[[[
Откуда у меня столько времени на перепроверку сообщений? ‘Так я же пишу сообщения даже не каждый день.’/‘Ну я предпочитаю писать очень редко, но очень качественно.’]]]--><br />
<hr />
2024-04-10 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b>, я не занимаюсь разработкой языков и компиляторов, хотя потенциально умею это делать. Т.е. я как бы являюсь пользователем языков программирования и компиляторов, поэтому, мои ответы стоит воспринимать как "просто скромное мнение одного из пользователей".<br />
<br />
К конструкциям языка вида "var++" и "--var" у меня очень простое отношение, как к удобному инструменту (типа "синтаксического сахара"), а не как к смысловой части языка (и/или компилятора). Соответственно, как любой инструмент, его можно приметь в дело и не в дело.<br />
<br />
Мой критерий применения инструмента также простой — инструмент не должен усложнять программу. Т.е. любой другой программист, кто будет читать программу, не обязан разбираться и помнить тонкости, потому что это вредит конечной цели — логике работы программы.<br />
<br />
Вот так я НЕ делаю:<br />
<pre class="code_block">
 do { *dst++ = *src++;} while (*src);
</pre>
А вот так делаю:<br />
<pre class="code_block">
 do { *dst = *src; dst++; src++; ) while (*src);
</pre>
<br />
<blockquote>Но возвращаясь к теме статьи: против использования постфиксного инкремента в теле метода <b>read_byte()</b> вы ничего не имеете?</blockquote>
Я не против постфискного и префиксного инкрементов, но считаю, что в теле метода <b>read_byte()</b> в виде <b>buffer[buffer_pos++]</b> он неуместен, а программа, которой вместо простой проверки границ приходится отлавливать исключения — плохо спроектирована (не обижайтесь, но это мое мнение). Как бы ни было принято большинством в мире, наличие в тексте программы исключений и ассертов рантайма, для меня это признаки плохо спроектированной программы.<br />
<br />
Вместо чтения <b>read_byte()</b> и буфера я использую другие методы и понятия: поток и извлечение информации из потока.<br />
<pre class="code_block">
// Простите, но я люблю Си, поэтому, будет чистый Си, а в C++ вы уж сами переведете.
bool stream_get_byte(stream_t *stream, uint8_t *byte_ptr);
int stream_get_byte(stream_t *stream); // + #define STREAM_EMPTY (-1), результат вне кодировки байта.

// К буферам это всё тоже применимо и тоже использую:
bool buffer_get_byte(buffer_t *buffer, uint8_t *byte_ptr);
int buffer_get_byte(buffer_t *buffer); // + #define BUFFER_EMPTY (-1), результат вне кодировки байта.
</pre>
Причем, слово <b>get</b> означает извлечение байта и это, на мой скромный взгляд, очень правильная по смыслу и достаточно частая операция с потоками и буферами.<br />
<br />
<blockquote>Просто я не люблю использовать <b>throw</b> в выражениях, поэтому и не стал так писать в реальном коде.</blockquote>
Мое отношение к любым исключениям строго негативное. Исключения этот как параллельная вселенная ко всей логике программы. При кажущейся простоте применения исключений в тексте, человеку очень трудно спроектировать алгоритм правильно с учетом работы этих исключений потому что они нарушают порядок выполнения алгоритма программы и программа зачастую ведет себя слишком не предсказуемо (не предусмотрено программистом).<br />
<br />
Так исторически сложилось, что я больше пишу на Си с применением парадигмы ООП и мне ни разу не потребовалось применять исключения ни в одном крупном проекте. Крупным я считаю проект, состоящий из десятков разнотипных взаимодействующих программ, с общим числом запущенных экземпляров около сотни и все программ созданы с применением парадигмы ООП. Ибо парадигма ООП не зависит от языка и больше относится к архитектуре программы, а текст программы можно делать на любом языке (хоть на C++, хоть на Си и ассемблере), это просто синтаксис самого C++ сделан в парадигме ООП.<br />
<br />
PS. Да простит меня <b>Автор сайта</b> за англицизмы, но они точно отражают мою мысль и я считаю, что их использование уместно и никак не ущемляет русский язык.<br />
<hr />
2024-04-11 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Ах, вот оно в чём дело.</blockquote>
Вот поэтому не стал вмешиваться в дискуссию, потому что вариантов было много, и какой из них имелся в виду — знали только Вы.<br />
<br />
<blockquote>Уже более 4-х с половиной лет</blockquote>
Только недавно обратил внимание.<br />
<br />
<blockquote>если ... отложить их отправку/публикацию ... и периодически перечитывать текст перед отправкой, то качество сообщений при этом повышается.</blockquote>
Без сомнения. Но тогда голова занята ответом. А ответы не всегда хочется давать, потому что они неоднократно давались, а одни и те же вопросы всё равно задаются и поднимаются. А на это уходит драгоценное время, которое могло бы быть потречено с большей пользой. Но Ваше мнение всё равно приветствуется. 🤣<br />
<br />
<blockquote>наличие в тексте программы исключений и ассертов рантайма, для меня это признаки плохо спроектированной программы.</blockquote>
Джоэл Спольски справедливо указывает, что <a href="http://compiler.su/obrabotka-oshibok.php#41">исключения значительно хуже, чем «goto»</a>. Впрочем, можно обойтись без них, решения есть.<br />
</div>
</body>
</html>