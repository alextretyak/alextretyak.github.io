Н‘‘Постфиксные инкремент и декремент (ссылка на статью)’[http://compiler.su/postfiksnye-inkrement-i-dekrement.php]’

Комментарии:
---
2024-03-27 ~‘*‘alextretyak’’

И всё-таки, иногда постфиксные операции [[[довольно удобны]]]значительно удобнее.

Вот у меня есть такой метод в классе:
#(C++)‘
    uint8_t read_byte()
    {
        return buffer[buffer_pos++];
    }
’[[[
Ну ладно, не совсем такой. Но если так хотите, можно и реальный код записать в одну строку:
#(C++)‘
    uint8_t read_byte()
    {
        return !at_eof() ? buffer[buffer_pos++] : throw UnexpectedEOF();
    }
’
(Но я не люблю использовать #(C++)‘throw’ в выражениях.)
]]]
Если отказаться от постфиксного инкремента, тогда придётся этот метод переписать так:
#(C++)‘
    uint8_t read_byte()
    {
        uint8_t result = buffer[buffer_pos];
        ++buffer_pos;
        return result;
    }
’

Мало того, что строчек кода в теле метода стало в три раза больше, так ещё и пришлось вводить лишнюю сущность и давать ей имя [временная переменная result].

> ..., а свойство таких операций выполнять действие над операндом по окончании всех остальных операций.
А [[[что ]]]если лишить эти операции такого свойства[[[, сделав их полностью определёнными]]]?

Что, если постфиксные инкремент и декремент *‘всегда’ будут определены таким образом:
#(C++)‘
template <typename T> T operator++(T& a, int)
{
    T temp = a; // для типа `T` должен быть определён конструктор[[[ или оператор]]|] копирования
    ++a;        // для типа `T` должен быть определён префиксный оператор `++`
    return temp;
}
// и аналогично для `--`
’
[[[
Нужно ещё придумать, что делать с
>[https://en.cppreference.com/w/cpp/atomic/atomic/operator_arith <- https://en.cppreference.com/w/cpp/language/operator_incdec <- google:‘c++ postfix increment’]:‘
. operator++() performs atomic pre-increment. Equivalent to #(С++)‘return fetch_add(1) + 1;’.
. operator++(int) performs atomic post-increment. Equivalent to #(С++)‘return fetch_add(1);’.
’
< Что-что. Просто использовать специальные методы в таком случае (fetch_increment() или что-то вроде того). Как будто это так часто требуется, чтобы менять семантику постфиксных ++/-- из-за такой мелочи.
]]]
В этом случае появляется сразу несколько плюсов:
. поведение постфиксных операций становится полностью детерминированным: [[[запись/]]]выражение *‘a++ − a++’ всегда [[[вычисляется как]]]возвращает *‘-1’ и при этом увеличивает *‘a’ на 2 [правда при условии, что компилятор при расчёте разности вычисляет уменьшаемое (левый [[[аргумент/]]]операнд) всегда перед вычитаемым (правы[[[й]]]м операндом)];
. исчезает различие в поведении постфиксных операций для встроенных в язык типов (int, float и др. — для них «++» и «--» выполняются после выполнения всего выражения) и для пользовательских типов (для них [[[будут применяться]]]применяются переопределённые постфиксные «++» и «--»);
. пропадает «[[[магия/]]]шаманство» в виде дополнительного неиспользуемого аргумента при переопределении постфиксных операций «++» и «--», т.к. [[[пользователь/]]]программист вообще не может переопределить постфиксные «++» и «--», а только префиксные (постфиксные всегда генерируются компилятором автоматически);
.‘[[[
Дополнительно[[[,]]] ]]]это [[[упростит/]]]упрощает [[[компилятор/]]]реализацию, т.к. запись *‘a++’ компилятор может просто заменять на вызов служебной функции *‘postfix_increment(a)’, которая реализована [[[следующим образом]]]аналогично[[[ постфиксному инкременту]]]:
#(C++)‘
template <typename T> T postfix_increment(T& a)
{
    T temp = a;
    ++a;
    return temp;
}
’’

Ну и в качестве оптимизации, считаю, что [[[запись/]]]операция[[[/выражение]]] *‘a++’ должна [[[быть равнозначна]]]автоматически заменяться компилятором на *‘++a’ в том случае, когда результат операции не используется. Всё-таки постфиксный инкремент[[[ в коде]]] выглядит красивее префиксного. Неспроста же Бьёрн назвал язык C++, а не ++C[[[ (хотя по смыслу последний подходит больше)]]]. :)(: [[[Хотя тут скорее дело в произношении: «си-плас-плас» явно лучше, чем «плас-плас-си».]]][[[

Хотя, выражения вида #(С)‘a++ - a++’ лучше запретить.
Ещё, я бы запретил #(C)‘dst[i] = src[i++]’, но разрешил #(C)‘dst[i++] = src[i]’.
]]]
---
2024-03-27 ~‘*‘MihalNik’’

> Если отказаться от постфиксного инкремента, тогда придётся этот метод переписать так
Есть ещё один "крамольный" вариант — разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных. А return можно переименовать в result.
---
2024-04-01 ~‘*‘veector’’

>‘Вот у меня есть такой метод в классе:
#(C++)‘
    uint8_t read_byte()
    {
        return buffer[buffer_pos++];
    }
’’
Когда я вижу такой код на ревью (проверке), то сразу выдаю минус в карму.

> Есть ещё один "крамольный" вариант — разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных. А return можно переименовать в result.
*‘MihalNik’, кстати, это один из самых правильных вариантов, даже в одном известном языке применяется, но нынче не очень популярном.
---
2024-04-02 ~‘*‘Автор сайта’’

#(С++)‘
buffer_pos++
’
> разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных.
В приведённых выше примерах есть неясность. Если *‘buffer_pos’ локальная, то вообще непонятно, зачем её увеличивать перед выходом из функции, ведь её значение не возвращается оператором return. Если она глобальная, то смысл увеличения есть, но есть резонный вопрос — зачем она глобальная?!

Есть ещё вариант, когда *‘buffer_pos’ — волатильная, тогда изменять её могут для произведения побочного эффекта. Но этот вариант вообще ни в какие ворота не лезет.
---
2024-04-04 ~‘*‘alextretyak’’

*‘MihalNik’
> Есть ещё один "крамольный" вариант — разрешить операторы после "return", тогда строки будет две, а не три, без лишних переменных. А return можно переименовать в result.
Хороший вариант, согласен. Жаль только, что не так много языков программирования, которые поддерживают специальную переменную result.

*‘Автор сайта’
> Если *‘buffer_pos’ локальная
Как же она может быть локальной, когда в теле метода она не объявляется?
(Да, приведённая строка кода является *‘полным’ [[[кодом реализации]]]телом метода *‘read_byte()’.)

> Если она глобальная, то смысл увеличения есть, но есть резонный вопрос — зачем она глобальная?!
[[[ну можно ж]]]Из моих слов «такой метод в классе» можно было догадаться, что в коде речь идёт о переменных-членах класса. И *‘buffer’, и *‘buffer_pos’ являются переменными-членами.

*‘veector’
> то сразу выдаю минус в карму.
Просто выдаёте и всё?
А ~‘конкретные’ советы/рекомендации (о том, какой код был бы лучше в данном случае)[[[,]]] вы не даёте из принципа, я так полагаю[[[/понимаю]]][[[?/]]]. :)(:

> даже в одном известном языке применяется, но нынче не очень популярном.
Почему вы так не любите конкретику? Что мешало сразу просто указать название этого языка программирования, как будто это прям какая-то коммерческая тайна.

Из более-менее популярных языков программирования, которые поддерживают специальную переменную для возврата значения, я могу назвать только BASIC, Pascal/Delphi[[[,]]] и Nim (причём в [[[первом/]]]первых двух эта переменная является именем функции, а в последнем используется специальная переменная *‘result’).
Но в C++ такой возможности нет, а потому вопрос ‘а как более правильно реализовать *‘0‘return buffer[buffer_pos++];’’’ остаётся открытым.
---
2024-04-05 ~‘*‘veector’’

*‘alextretyak’, не, я добрый, всегда, всем, все разъясняю.
---
2024-04-07 ~‘*‘alextretyak’’

> всегда, всем, все разъясняю.
Ну, в таком случае,[[[/тогда]]] хотелось бы услышать [хотя бы краткое] разъяснение, что именно вас не устраивает в [[[таком/]]]процитированном коде [в сообщении от 2024-04-01] и какой код был бы лучше в данном случае?
---
2024-04-08 ~‘*‘veector’’

*‘alextretyak’, ну тут всё же просто: Вы же считываете значение из массива, 1 байт, не проверяя номер элемента.
---
2024-04-08 ~‘*‘Автор сайта’’

*‘alextretyak’, поделитесь тайным знанием, почему ваши сообщения в последнее время всегда делаются в 00:00 🙃
---
2024-04-10 ~‘*‘alextretyak’’

*‘veector’
> Вы же считываете значение из массива, 1 байт, не проверяя номер элемента.
Ах, вот оно в чём дело.
Просто [[[тема/]]]название[[[/заголовок]]] [[[данной/]]]обсуждаемой[[[ тут]]] статьи — «Постфиксные инкремент и декремент», поэтому я решил немного сократить тело метода *‘read_byte()’ для наглядности[[[, чтобы не отвлекаться на несущественные детали]]].
Тем более, что в C++ такой код вполне может быть допустим в том случае, когда *‘buffer’ — это не [[[голый/]]]просто указатель или массив в стиле Си, а объект-экземпляр[[[
>[https://ru.stackoverflow.com/questions/2723/Чем-отличается-экземпляр-класса-от-объекта-класса <- google:‘объект класса’]:‘`class object` — этот объект, в котором хранится, так сказать, информация о классе.’
]]] класса массива с контролем выхода за границы. Тогда внутри перегруженного *‘0‘operator[]’’ будет та самая «проверка номера элемента», о которой вы говорите и которую в языке Си пришлось бы вставлять в код явно.

Вообще, полный код метода *‘read_byte()’, который используется в ‘реальном [[[коде/]]]проекте’[https://github.com/alextretyak/file_for_humans/blob/master/IFile.hpp], выглядит так:
#(С++)‘
    uint8_t read_byte()
    {
        if (at_eof())
            throw UnexpectedEOF();
        return buffer[buffer_pos++];
    }
’
[Метод *‘at_eof()’, несмотря на название, не только проверяет на конец файла, а очень много чего делает: аллоцирует buffer, если он ещё не был проаллоцирован, читает из файла данные в buffer[[[/‘заполняет buffer данными из файла’]]], если buffer_pos указывает на конец буфера, и при этом сбрасывает buffer_pos в 0 и [[[сдвигает файловый указатель]]]обновляет позицию начала буфера в файле для корректной работы метода tell(), а если прочитать файл не удалось, то [[[возбуждает/]]]порождает исключение (таким образом, к моменту выполнения кода 0‘buffer[buffer_pos++]’ содержимое buffer уже подготовлено и buffer_pos гарантированно [[[указывает/]]]находится в допустимых пределах).]
Но даже [[[такой код]]]тако[[[е тело]]][[[й код тела]]]е тело метода вполне можно [[[записать в одну строку кода]
(Вообще, в C++ любой код без директив препроцессора можно записать в одну строку:
#(С++)‘
if (at_eof()) throw UnexpectedEOF(); return buffer[buffer_pos++];
’)
]]впихнуть в один return:
#(С++)‘
    uint8_t read_byte()
    {
        return !at_eof() ? buffer[buffer_pos++] : throw UnexpectedEOF();
    }
’
[[[Но/]]]Просто я не люблю использовать *‘throw’ в выражениях, поэтому [[[я]]]и не стал так писать в реальном коде.

Но возвращаясь к теме статьи: против использования постфиксного инкремента в теле метода *‘read_byte()’ вы ничего не имеете?

*‘Автор сайта’
> поделитесь тайным знанием, почему ваши сообщения в последнее время всегда делаются в 00:00
Ну, [[[как]]]не сказать, что[[[ ]]]бы в «последнее». Уже более 4-х с половиной лет,[[[ в каждом своём сообщении/комментарии](не уверен, что в каждом {например, вот[http://compiler.su/pravila-yazyka-strokovye-literaly.php#7] дополнительное сообщение, опубликованное в 04:00})]] начиная с ‘этого [[[комментария/]]]сообщения’[http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php#12]. :)(:

А тайного знания тут никакого нет: просто я давно заметил, что если отправлять сообщения не сразу же после написания, а [[[давать им немного полежать]]]отложить их отправку/публикацию хотя бы на несколько часов и периодически перечитывать текст[[[ сообщений]]] перед отправкой, то качество сообщений при этом[[[ существенно]]] повышается. Мозг в фоновом режиме вспоминает какие-то дополнительные детали/уточнения, которые так и просятся добавить[[[ себя [уточнения]]]] в сообщение в процессе его перечитывания. Если в сообщении были какие-то излишне эмоциональные/резкие высказывания, то по прошествии времени это становится хорошо заметно и получается либо [[[перевести/]]]перефразировать их в более конструктивном ключе, либо появляется решимость вообще вырезать/удалить их из сообщения. [[[Ну и](чуть ниже уже есть ‘ну’[:‘Ну, с одной стороны’])]]Также ошибки/опечатки в тексте лучше обнаруживаются и исправляются.
Почему я выбрал время отправки сообщений именно 00:00 [по Москве]? Ну, с одной стороны, в этом есть что-то [[[математически-программистически]/]]програм~‘мистически’ красивое. А с другой, это оказалось ещё и очень удобное для меня время: во Владивостоке это 7:00 утра, и я успеваю на свежую голову ещё разок хорошенько обдумать сообщение перед отправкой[[[ на свежую голову]]].
[Если интересует техническая сторона вопроса, то никакими скриптами/ботами я не пользуюсь. Просто сверяю системное время с https://time.is и нажимаю кнопку отправки сообщения примерно в 7:00:30. Вероятность того, что время на сервере, куда я отправляю сообщение, расходится с time.is более[[[,]]] чем на 30 секунд очень мала, поэтому пока что получалось отправлять сообщения без ошибок точно в 0x:00[[[
> Почему 0x:00, а не 00:00?
< [:‘дополнительное сообщение, опубликованное в 04:00’] (и там же рядом есть опубликованное в 01:00)
]]].][[[
Откуда у меня столько времени на перепроверку сообщений? ‘Так я же пишу сообщения даже не каждый день.’/‘Ну я предпочитаю писать очень редко, но очень качественно.’]]]
---
2024-04-10 ~‘*‘veector’’

*‘alextretyak’, я не занимаюсь разработкой языков и компиляторов, хотя потенциально умею это делать. Т.е. я как бы являюсь пользователем языков программирования и компиляторов, поэтому, мои ответы стоит воспринимать как "просто скромное мнение одного из пользователей".

К конструкциям языка вида "var++" и "--var" у меня очень простое отношение, как к удобному инструменту (типа "синтаксического сахара"), а не как к смысловой части языка (и/или компилятора). Соответственно, как любой инструмент, его можно приметь в дело и не в дело.

Мой критерий применения инструмента также простой — инструмент не должен усложнять программу. Т.е. любой другой программист, кто будет читать программу, не обязан разбираться и помнить тонкости, потому что это вредит конечной цели — логике работы программы.

Вот так я НЕ делаю:
#(C)‘
 do { *dst++ = *src++;} while (*src);
’
А вот так делаю:
#(C)‘
 do { *dst = *src; dst++; src++; ) while (*src);
’

> Но возвращаясь к теме статьи: против использования постфиксного инкремента в теле метода *‘read_byte()’ вы ничего не имеете?
Я не против постфискного и префиксного инкрементов, но считаю, что в теле метода *‘read_byte()’ в виде *‘0‘buffer[buffer_pos++]’’ он неуместен, а программа, которой вместо простой проверки границ приходится отлавливать исключения — плохо спроектирована (не обижайтесь, но это мое мнение). Как бы ни было принято большинством в мире, наличие в тексте программы исключений и ассертов рантайма, для меня это признаки плохо спроектированной программы.

Вместо чтения *‘read_byte()’ и буфера я использую другие методы и понятия: поток и извлечение информации из потока.
#(C)‘
// Простите, но я люблю Си, поэтому, будет чистый Си, а в C++ вы уж сами переведете.
bool stream_get_byte(stream_t *stream, uint8_t *byte_ptr);
int stream_get_byte(stream_t *stream); // + #define STREAM_EMPTY (-1), результат вне кодировки байта.

// К буферам это всё тоже применимо и тоже использую:
bool buffer_get_byte(buffer_t *buffer, uint8_t *byte_ptr);
int buffer_get_byte(buffer_t *buffer); // + #define BUFFER_EMPTY (-1), результат вне кодировки байта.
’
Причем, слово *‘get’ означает извлечение байта и это, на мой скромный взгляд, очень правильная по смыслу и достаточно частая операция с потоками и буферами.

> Просто я не люблю использовать *‘throw’ в выражениях, поэтому и не стал так писать в реальном коде.
Мое отношение к любым исключениям строго негативное. Исключения этот как параллельная вселенная ко всей логике программы. При кажущейся простоте применения исключений в тексте, человеку очень трудно спроектировать алгоритм правильно с учетом работы этих исключений потому что они нарушают порядок выполнения алгоритма программы и программа зачастую ведет себя слишком не предсказуемо (не предусмотрено программистом).

Так исторически сложилось, что я больше пишу на Си с применением парадигмы ООП и мне ни разу не потребовалось применять исключения ни в одном крупном проекте. Крупным я считаю проект, состоящий из десятков разнотипных взаимодействующих программ, с общим числом запущенных экземпляров около сотни и все программ созданы с применением парадигмы ООП. Ибо парадигма ООП не зависит от языка и больше относится к архитектуре программы, а текст программы можно делать на любом языке (хоть на C++, хоть на Си и ассемблере), это просто синтаксис самого C++ сделан в парадигме ООП.

PS. Да простит меня *‘Автор сайта’ за англицизмы, но они точно отражают мою мысль и я считаю, что их использование уместно и никак не ущемляет русский язык.
---
2024-04-11 ~‘*‘Автор сайта’’

> Ах, вот оно в чём дело.
Вот поэтому не стал вмешиваться в дискуссию, потому что вариантов было много, и какой из них имелся в виду — знали только Вы.

> Уже более 4-х с половиной лет
Только недавно обратил внимание.

> если ... отложить их отправку/публикацию ... и периодически перечитывать текст перед отправкой, то качество сообщений при этом повышается.
Без сомнения. Но тогда голова занята ответом. А ответы не всегда хочется давать, потому что они неоднократно давались, а одни и те же вопросы всё равно задаются и поднимаются. А на это уходит драгоценное время, которое могло бы быть потречено с большей пользой. Но Ваше мнение всё равно приветствуется. 🤣

> наличие в тексте программы исключений и ассертов рантайма, для меня это признаки плохо спроектированной программы.
Джоэл Спольски справедливо указывает, что ‘исключения значительно хуже, чем «goto»’[http://compiler.su/obrabotka-oshibok.php#41]. Впрочем, можно обойтись без них, решения есть.
