Н‘‘Продолжение цикла и выход из него (ссылка на статью)’[http://compiler.su/prodolzhenie-tsikla-i-vykhod-iz-nego.php]’

Комментарии:
---
2024-10-23 ~‘*‘bvz’’

Такое чувство, что проблема искусственно создана на ровном месте. Специально, чтобы потом триумфально разрешить её с помощью оператора goto. Кроме циклов for, между прочим, существуют также ещё и циклы while и until. Что мешает использовать один из них? Пусть условие надо_выйти_из_цикла с отрицанием добавлено через конъюнкцию в самый внешний цикл while. И тогда на каждом шаге этого самого внешнего цикла будет проверяться истинность условия надо_выйти_из_цикла.

Собственно говоря, циклы for, по-моему, придумали с одной единственной целью: избавиться от записи i=i+1 внутри цикла и включить её в заголовок. В некоторых случаях это, может, и удобно. Но если в данном конкретном случае цикл for не подходит, зачем нужно насильно его использовать?
---
2024-10-23 ~‘*‘Автор сайта’’

Не знаю, искусственным ли путём образовалась проблема или естественным. Однако до сих пор для выхода из нескольких циклов используют либо «goto»
#‘
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            goto <метка>
    // конец второго цикла
// конец первого цикла
<метка>:
’
либо заменитель «goto» («break» с меткой)
#‘
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            break <метка>
    // конец второго цикла
// конец первого цикла
<метка>:
’
либо пользуются самым длинным вариантом — создают дополнительные переменные с дополнительными танцами с бубнами:
#‘
надо_выйти_из_цикла = ложь
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            надо_выйти_из_цикла = истина
            break
    // конец второго цикла
    если надо_выйти_из_цикла
        break
// конец первого цикла
<метка>:
’
Независимо от вида цикла: «while», «until», «for».

> чтобы потом триумфально разрешить её с помощью оператора goto.
Вы невнимательно читали. Как раз-то этот вариант
#‘
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            break N  // N -число циклов, которые надо покинуть
’
и самый лаконичный, и самый прозрачный. Для него не нужны ни метки (как для «goto» и «break» с меткой), ни дополнительные переменные.
---
2024-10-24 ~‘*‘bvz’’

Автор сайта, ладно, я понял вашу мысль. Лаконичный — это значит, краткий, правильно? Но ведь не всегда краткий = изящный. Изящность, как и красота — вещь довольно субъективная. На мой взгляд, изящно было бы писать программу, придерживаясь один раз принятых принципов. Например, не использовать оператор goto. И никогда не отступая от них. Но вы и не использовали, вы использовали break N.

Короче, я бы всё равно писал по-своему. Я только не понял, предлагал ли кто-нибудь выше мой вариант. А что касается искусственности созданной проблемы — проблема эта возникает в тот момент, когда "бывают такие ситуации, когда условие выхода удобнее проверить не в заголовке цикла, а «по месту требования»." Так вот, я бы просто поместил это условие именно в заголовок каждого цикла. Руки бы у меня от этого не отвалились. Удобство или неудобство может возникнуть на стадии понимания программы. Но опять-таки, не думаю, что такую программу будет намного труднее понять.

И более того. Если вы всегда записываете условие выхода в заголовок цикла, все такие программы будут выглядеть одинаково. Вне зависимости от количества вложенных циклов. Соответственно, исчезает возможность ошибиться на стадии break N. Например, написать break 6 вместо break 5. А может, и вовсе стоит написать рекурсивную процедуру для неограниченного числа вложенных "циклов".

Хотя, строго говоря, такие алгоритмы, наверное, не будут эквивалентными. Если я проверяю некое условие в заголовке каждого цикла, я делаю дополнительное действие, правильно? Значит, программа будет медленнее работать. Но я такими вещами никогда не заморачивался, честно говоря.
---
2024-10-26 ~‘*‘alextretyak’’

> Так вот, я бы просто поместил это условие именно в заголовок каждого цикла.
Не во всех языках программирования в заголовок цикла *‘for’ можно вставить дополнительное условие.
Например, в том же Python нет универсального цикла *‘for’. И для выхода из нескольких циклов приходится, как уже было сказано выше «создавать дополнительные переменные с дополнительными танцами с бубнами».

Вот конкретный пример.
У меня есть Python-скрипт, которому требуется определить директорию с установленной Microsoft Visual Studio, [[[причём самой]]][[[как можно более новой версии]]]причём более новые версии должны быть в приоритете.
Для этого я использовал такой вложенный цикл:
#(Python)‘
for version in ['2022', '2019', '2017', '2015', '2013']:
    for edition in ['BuildTools', 'Community', 'Enterprise', 'Professional']:
        if os.path.isfile('C:\\Program Files (x86)\\Microsoft Visual Studio\\' + version
                          + '\\' + edition + R'\VC\Auxiliary\Build\vcvarsall.bat'):
            ... # здесь нужно выйти из всех циклов
’

Но недавно этот скрипт пришлось поправить, так как оказалось, что 2022-ая студия может быть установлена не в "C:\Program Files (x86)", а в "C:\Program Files".
Вот ссылка на мой коммит с этой правкой: [https://github.com/symasm/symasm/commit/7d2f432a9ef45784646a01662be874abb8ba17e7].
В итоге код получился вот таким:
#(Python)‘
was_break = False
for version in ['2022', '2019', '2017', '2015', '2013']:
    for edition in ['BuildTools', 'Community', 'Enterprise', 'Professional']:
        for x86 in [0, 1]:
            vcvarsall = 'C:\\Program Files' + ' (x86)'*x86 + '\\Microsoft Visual Studio\\' + version + '\\' + edition + R'\VC\Auxiliary\Build\vcvarsall.bat'
            if os.path.isfile(vcvarsall):
                was_break = True
                #print('Using ' + version + '\\' + edition)
                break
        if was_break:
            break
    if was_break:
        break
if was_break:
    masm_pathname = subprocess.check_output('"' + vcvarsall + '" x64 > nul && where ml64', encoding = 'ascii').rstrip()
    open('masm_pathname.txt', 'w').write(masm_pathname)
else:
    print('''Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].''')
    masm_pathname = '-'
’

Видите замечательную лесенку из #(Python)‘if was_break’?
И теперь представьте, что вам запросто может потребоваться добавить ещё один вложенный цикл *‘for’.

А если использовать язык программирования с возможностью выхода из нескольких циклов, например 11l, то код получится значительно проще:
#(11l)‘
loop(version) [‘2022’, ‘2019’, ‘2017’, ‘2015’, ‘2013’]
   loop(edition) [‘BuildTools’, ‘Community’, ‘Enterprise’, ‘Professional’]
      loop(x86) [0, 1]
         var vcvarsall = ‘C:\Program Files’(‘ (x86)’*x86)‘\Microsoft Visual Studio\’version‘\’edition‘\VC\Auxiliary\Build\vcvarsall.bat’
         if fs:is_file(vcvarsall)
            //print(‘Using ’version‘\’edition)
            masm_pathname = os:(‘"’vcvarsall‘" x64 > nul && where ml64’).stdout.rtrim("\n")
            File(‘masm_pathname.txt’, WRITE).write(masm_pathname)
            loop(version).break

loop.was_no_break
   print(‘Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].’)
   masm_pathname = ‘-’
’

Конструкция *‘loop(version).break’ осуществляет выход из соответствующего цикла (в языке 11l меток нет).
Вместо неё можно использовать эквивалентную (при данном количестве вложенных циклов!) конструкцию: *‘^^loop.break’.
Я выбрал символы крышечки (^) вместо числа после *‘break’, так как:
1.‘не очевидно с какого числа начинается отсчёт, с 0 или с 1 (в PHP начинается с 1, т.е. просто *‘break’ равнозначен *‘break 1’, а чтобы прервать внешний цикл, нужно использовать *‘break 2’, но в программировании нумерацию принято начинать с 0, т.е. было бы логично, что просто *‘break’ равнозначен *‘break 0’... в общем, возможна путаница; с крышечками же логика проще — если их нет, то *‘loop.break’ он и в Африке... осуществляет выход только из текущего цикла, если одна крышечка, то выходим из вышестоящего цикла по отношению к текущему, если крышечки две, то идём ещё выше (сам этот символ символизирует направление вверх, потому он и был выбран {
Но ведь *‘^loop.break’ по факту осуществляет переход не выше/вверх, а вниз, сразу к коду после цикла. Как же так?
Дело тут в том, что крышечка (^) относится не к *‘loop.break’, а к *‘loop’. Т.е. имеется в виду *‘(^loop).break’, а не *‘^(loop.break)’.
И использовать крышечку/-ки перед *‘loop’ можно не только для выхода из цикла, но и для продолжения цикла — *‘^loop.continue’, для получения индекса (номера[[[,]]] начиная с 0) текущей итерации цикла — *‘^loop.index’ и т.д.
}) и т.д.);’
2.‘число после *‘break’ создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например *‘break 2+3’ или вообще вставить какую-[[[то/]]]нибудь переменную:
#(11l)‘
loop ...
    loop ...
       loop ...
          int entered_number = int(input(‘Сколько циклов вы хотите покинуть?’))
          break entered_number
’’

Более «монолитно», чем *‘break 2’, выглядит запись *‘break_2’, но так сделать в языке программирования не получится[[[ —]]], т.к. break_2 может быть действительным именем переменной/идентификатором.

Но если вернуться к исходной проблеме — лесенке из #(Python)‘if was_break’, то есть и друго[[[й выход]]]е решение — поместить необходимую логику внутрь функции, которая вместо *‘break’ будет делать *‘return’.
Но мне не нравится такое решение — нужно придумывать имя для новой функции, которая используется только в одном месте и только для обхода ограничения используемого языка программирования. Похоже на костыль.

> Хотя для применения «continue N» не очень легко привести пример из жизни для иллюстрации его полезности. Возможно, читатели этих строк предложат что-то в комментариях к статье.
Предложат-предложат. :)(:

Вот два наиболее интересных встретившихся мне примера, в которых было бы оправдано применение «continue N»:
1. В транспайлере Python → 11l вот ‘эти 4 строки’[https://github.com/11l-lang/python_to_11l/blob/f54b0475ebbceaea280e1b9eca6eab99069f2f4f/parse.py#L3053-L3056] не самого понятного Python-кода можно заменить одной строкой *‘^loop.continue’ (аналог *‘continue 2’).
2. Этот ‘код на языке D’[https://rosettacode.org/wiki/Peaceful_chess_queen_armies#D] использует *‘continue <метка>’ [и, как видно по этой же веб-странице, эту конструкцию поддерживают также языки Go, Java, Kotlin, Swift], но т.к. Python такого не поддерживает, пришлось усложнить логику путём добавления двух else-веток для for — ‘вот этот перевод на Python’[https://github.com/11l-lang/_11l_to_cpp/blob/master/tests/python_to_cpp/Rosetta%20Code/p.txt#L2272].
Там же на rosettacode.org можно поискать ещё хорошие примеры употребления *‘continue <метка>’ (вдруг я что-то упустил).
---
2024-10-26 ~‘*‘Автор сайта’’

> *‘^^loop.break’
Я префиксному «^» собираюсь назначить иную роль. Один такой символ — увеличение области видимости на уровень выше. То есть за пределы скобки [[[(]]]«)»:
#‘
( (^переменная = ... // инициализация переменной с выводом её типа
    ... = переменная // внутри скобок она видна
  )
  ... = переменная   // за пределами первой пары скобок тоже видна
)
... = переменная   // за пределами второй пары скобок не видна
’

> не очевидно с какого числа начинается отсчёт, с 0 или с 1
Число после «break» — это *‘сколько циклов надо покинуть’. Если 0, то значит цикл покидать не надо.

> число после break создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например break 2+3
Компилятор разочарует своими сообщениями об ошибках. Так же, как если бы вместо var4 написали бы var2*2.

> эти 4 строки не самого понятного Python-кода можно заменить одной строкой *‘^loop.continue’
👍
---
2024-10-26 ~‘*‘ИванАс’’

>‘#(Python)‘
for version in ['2022', '2019', '2017', '2015', '2013']:
    for edition in ['BuildTools', 'Community', 'Enterprise', 'Professional']:
        for x86 in [0, 1]
’’
Наверное, можно заменить на product из itertools.
---
2024-10-28 ~‘*‘alextretyak’’

> Я префиксному «^» собираюсь назначить иную роль. Один такой символ — увеличение области видимости на уровень выше.
Так одно другому не мешает.
В 11l, кстати, планируется аналогичный функционал: использовать префиксы *‘^’ для доступа к переменным из внешней области видимости. Особенно это может быть полезно во время отладки (например, есть цикл по *‘i’, внутри него ещё какой-то цикл, внутри которого ещё маленький цикл по *‘i’, находясь в котором хочется получить текущее значение переменной *‘i’ верхнего уровня, это можно сделать посредством записи *‘^i’).[[[
#rec##audio#[REC_0003412.wav][в СвН соборе в углу на лавочке у иконы Арх. Михаилу]
Я об этом писал ещё в статье «Каркас нового языка программирования».
]]] Я об этом писал ещё в статье «Каркас нового языка программирования» на Хабре и в комментариях там по[[[ этому]]] поводу этой возможности велись [[[активные/]]]горячие споры: [https://habr.com/ru/articles/350694/comments/#comment_10701298].
Также хочу обратить внимание на то, что в записи *‘^^loop.break’ крышечки относятся не к *‘break’, а к *‘loop’. Т.е. имеется в виду *‘(‍^^loop).break’, а не *‘^^(loop.break)’.

>‘#‘
( (^переменная = ... // инициализация переменной с выводом её типа
    ... = переменная // внутри скобок она видна
  )
  ... = переменная   // за пределами первой пары скобок тоже видна
)
’’
Ну в чистом виде такой код малополезен — проще создать переменную чуть раньше за скобкой. А на практике может понадобиться создать «внешнюю» переменную в теле условного оператора. Вот только вопрос[[[,]]]: что делать в случае, когда условие не выполняется — [[[ведь обращение к этой переменной осуществляется]]]как должно отрабатывать обращение к этой переменной в последующем коде?

И разве ваш язык не предполагает явное обозначение объявления новой переменной?
В 11l обязательно указывать при инициализации, что объявляется новая переменная, с помощью ключевого слова *‘var’\*‘пер’:
#(11l)‘
если <условие>
   пер имя_новой_переменной1 = ...  // видна только внутри тела условного оператора
   пер ^имя_новой_переменной2 = ... // видна также снаружи,
вывод(имя_новой_переменной2)        // но что делать, если <условие> ложно?
’

Также префикс *‘^’ можно будет использовать для обозначения «внешних» счётчиков цикла:
#(11l)‘
цикл(^н) 0 .< 100 // цикл от 0 до 100, включая 0, но не включая 100
   если <условие>
      цикл.прервать // или цикл.выход

вывод(н) // выводим значение `н` на итерации, в которой цикл был прерван
         // если цикл не был прерван, то в `н` будет число 100
’
И перед точкой:
#‘
.offset = 5
pos1.
   pos2.
      .x = 10 + ^.x + ^^.offset
     └─┬┘      └─┬─┘ └────┬────┘
       │         │        ╘═(^^.).offset = 5
       ╘═pos2.x  ╘═pos1.x
’
И ещё — для внешних return:
#(11l)‘
фн внешняя_функция(...)
   фн локальная_функция()
      ^возврат // возврат из внешней функции
   локальная_функция()
   ... // этот код выполняться не будет, т.к. внутри вызова
   ... // локальной функции осуществляется возврат из внешней
’[[[
На замечание «это приводит к неочевидной логике работы кода функции» я могу ответить, что внешний/глубокий return ничем не хуже исключений, которые возбуждаются при обращении к элементу по индексу за границами массива или при арифметических переполнениях.
]]]

> Число после «break» — это сколько циклов надо покинуть. Если 0, то значит цикл покидать не надо.
А вот разработчики языка PHP с вами не согласны.
В версии до 5.4 *‘break 0’ работал так же как *‘break 1’, а в 5.4 и более новых версиях — писать *‘break 0’ вообще запретили.
[https://php.ru/manual/control-structures.break.html][[[ <- google:‘php "break 0"’]]]

> Компилятор разочарует своими сообщениями об *‘ошибках’. Так же, как если бы вместо var4 написали бы var2*2.
Эмм. Не понял, а в чём ошибка компиляции в записи var2*2? Это же простое умножение значения переменной var2 на число 2.[[[
Если речь про ошибку «переменная не найдена», то если есть переменная var4, то скорее всего есть и var2. :)(:]]]
---
2024-11-04 ~‘*‘Автор сайта’’

*‘alextretyak’, наконец-то отвечаю Вам.
> В 11l, кстати
Кстати, что означает такое название языка? Почему оно такое?

> в записи ^^loop.break крышечки относятся не к break, а к loop. Т.е. имеется в виду (^^loop).break, а не ^^(loop.break).
Не очень понимаю, зачем оператору break нужен loop. И так же ясно, что выйти можно только из цикла. В одних местах Вы стремитесь к наибольшей краткости, а в этом месте — нет. Даже case с двоеточием убираете из конструкции switch, оставляете одну константу. А тут такая расточительность.

> такой код малополезен — проще создать переменную чуть раньше за скобкой.
Если чуть раньше, то значит
. просто её объявить, без инициализации. Тогда придётся делать анализ: а не используется ли эта переменная в правой части присваивания, будучи неинициализированной?
. Или инициализировать, но инициализация за скобкой будет бесполезной: значение в последующем будет изменено, а инициализирующее значение так и не понадобится.
Инициализация же в нужном месте с распространением видимости на уровень выше упрощает применение вывода типа через инициализацию.

> А на практике может понадобиться создать «внешнюю» переменную в теле условного оператора. Вот только вопрос: что делать в случае, когда условие не выполняется — как должно отрабатывать обращение к этой переменной в последующем коде?
Инициализация переменной должна произойти во всех альтернативных ветвях кода во избежание использования неинициализированной переменной в правой части присваивания.

Но лучше это делать конструкцией вроде этой:
#‘
а = (если условие; "это правда" иначе "не верь этому")
’

> не предполагает явное обозначение объявления новой переменной?
Да, не предполагает. Хотя, если требуется, можно уточнить тип инициализирующего значения.

> В 11l обязательно указывать при инициализации, что объявляется новая переменная, с помощью ключевого слова
У Алексея Недори в его Тривиле сделано весьма любопытно
#‘
а = 9  // а — константа, ибо знак равенства
б := 0 // б — переменная, ибо присваивание
’

Да и зачем вообще объявлять новую переменную? Вы же стремитесь к краткости в языке. Ясное дело, что описание типов необходимо для аргументов функции или полей структур данных, без этого не обойтись. С глобальными переменными тоже надо думать, как быть.

> в 5.4 и более новых версиях — писать break 0 вообще запретили.
И правильно сделали. Зачем нужны бессмысленные конструкции? Когда я написал про break 0, то это было «объяснение на пальцах». Я лишь уповал на логику, чтобы исключить путаницу. А не иллюстрировал будущие задумки.

> в чём ошибка компиляции в записи var2*2? Это же простое умножение значения переменной var2 на число 2.
Я имел в виду, что выражение
#‘
var4 = нечто
’
синтаксически правильно, в отличие от
#‘
var2*2 = нечто
’
Точно так же
#‘
break 4
’
не может быть заменено на
#‘
break 2*2
’
Хотя в теории, ничто не мешает ‘во время компиляции вычислить значение’[http://compiler.su/makrosy-eto-chistye-funktsii-ispolnyaemye-vo-vremya-kompilyatsii.php] количества покидаемых циклов, если выражение вычислимо во время компиляции.
#‘
break cos(0) + tg(π/2)
’
Но тогда придётся делать законным
#‘
break 0
’
Но это всё игры разума, можно обойтись без пижонства, одним лишь обычным числом.
---
2024-11-06 ~‘*‘alextretyak’’

*‘ИванАс’
> Наверное, можно заменить на product из itertools.
В данном случае да, можно.
[[[Но читаемость кода, на мой взгяд, при этом ухудшится.]]]Но восприятие кода при этом усложнится[[[ (]]], несмотря на избавление от лесенки из #(Python)‘if was_break’[[[), т.к. itertools.product встречается в реальном коде [[[достаточно/]]]очень редко]]].

*‘Автор сайта’
> Кстати, что означает такое название языка?
Об этом можно догадаться из описания языка на его сайте — [http://11l-lang.org/ru]
[[[Чуть б]]]Более подробно написано об этом на странице языка в Википедии (которую, правда, уже удалили, но есть сохранённая копия — [https://11l-wikipedia.github.io/ru]):
< В отличие от других языков программирования, ключевые слова 11l структурированы в иерархию. На верхнем уровне этой иерархии располагается 11 базовых/корневых ключевых слов. Данная черта легла в основу названия языка программирования 11l, где «l» означает «litterae» в латинском, «logos» в греческом (в значении «слово»), либо «letters» в английском (так как корневые ключевые слова языка можно сокращать до одной буквы).

> Не очень понимаю, зачем оператору break нужен loop.
[[[Таким образом,]]]Поэтому, исходя из названия языка, я не могу добавить в 11l ключевое слово *‘break’, т.к. в [[[таком/]]]этом случае корневых ключевых слов станет больше, чем 11.

> Даже case ... убираете из конструкции switch
С *‘case’ аналогично — добавить это ключевое слово в 11l невозможно [не изменив название языка на 12l :)(:].

> И так же ясно, что выйти можно только из цикла.
Не только. В 11l ещё есть *‘switch.break’. Впрочем, его полезность под вопросом. А вот *‘switch.fallthrough’ может пригодиться.

К тому же, даже если «только из цикла», то остаётся вопрос: «а из какого именно цикла?» И вот тут этот "[[[избыточный/]]]расточительный" синтаксис оказывается очень к месту: *‘loop’ обозначает текущий цикл, *‘^loop’ обозначает вышестоящий цикл, *‘loop(version)’ обозначает цикл с переменной цикла version и т.д. И к любому выбранному циклу можно применить любое ключевое "подслово" [[[цикла]]]корневого слова loop, а именно *‘break’, *‘continue’, *‘index’, *‘first_iteration’ и пр.

> Или инициализировать, но инициализация за скобкой будет бесполезной
А зачем вообще необходимо использовать вложенные скобки в вашем примере?
Можете привести более законченный/практичный пример где требуется запись *‘^переменная = ...’? А то[[[ мне вообще]]] не очень понятно, что вы имели в виду.

> Да и зачем вообще объявлять новую переменную?
Если честно, я даже не рассматривал этот вопрос всерьёз. Практически во всех компилируемых языках переменные необходимо объявлять явно, и я считал этот вопрос решённым и не требующим переосмысления. А сейчас вот даже и не знаю, что ответить, какие [[[реальные/]]]весомые аргументы привести в пользу явного объявления.

Прежде всего, мне нравится чётко видеть в коде, где объявляется/создаётся новая переменная, а где изменяется значение уже существующей.

И компилятор не пропустит случаи, когда в имени переменной была допущена ошибка:
#(11l)‘
fn calc_result()
   var result = 0
   if ...
      rezult = 1 // ошибка компиляции, а не создание новой переменной с именем rezult
   ...
’

[[[Чтобы можно было]]]Также явное объявление позволяет создать новую переменную с уже использующимся именем во внутренней области видимости:
#(11l)‘
fn calc_result()
   var r = 0
   ...
   if ...
      var r = 1 // без `var` будет использоваться внешняя `r`
      print(r)  // выводим значение внутренней `r`
   ...
   return r // возвращаем значение `r`, объявленной в начале функции
’[[[
А также для единообразия области видимости переменных циклов:
#(11l)‘
loop(i)
   ...
   loop(i)
      ...
   ...
’]]]
Или позволяет запретить создание таких переменных (т.н. variable shadowing). [Причём этот запрет лучше вынести из спецификации языка на уровень опций компилятора, чтобы решение принимал руководитель проекта (решение о том, позволять variable shadowing или запрещать в коде проекта).]

> Ясное дело, что описание типов необходимо для аргументов функции
Тип аргументов функции даже в компилируемом языке указывать необязательно.

Так, в C++20 появилась возможность использовать auto вместо типа аргумента функции — в этом случае тип аргумента «определится» в месте вызова функции.
А в 11l такое поведение получается в случае, когда тип аргумента вообще не указан (а только его имя[[[ аргумента]]]).

Хотя для перегрузки функции с одинаковым количеством аргументов указать тип хотя бы некоторых из них, конечно, придётся явно.

> Когда я написал про break 0, то это было «объяснение на пальцах». Я лишь уповал на логику, чтобы исключить путаницу.
Тогда соглашусь. Логика в этом есть.
Правда такую запись — *‘break <число>’ — в других языках (кроме PHP) я не встречал.
---
2024-11-09 ~‘*‘Автор сайта’’

> Данная черта легла в основу названия языка программирования 11l, где «l» означает «litterae» в латинском
Мне кажется, маркетологи убили бы Вас за такое название. 🤣

> я не могу добавить в 11l ключевое слово break, т.к. в этом случае корневых ключевых слов станет больше, чем 11... добавить это ключевое слово в 11l невозможно, не изменив название языка на 12l
Вы сами придумали себе трудности, а потом героически их преодолеваете. Была когда-то такая забава — турнир поэтов. Поэты сперва придумывали какие-нибудь произвольные ограничения, например окончание строк на какие-то строго определённые слова. А потом укладывали свои стихи в такое прокрустово ложе. Вот и Вам, видимо, придётся строить модель парусника внутри стеклянной бутылки. Но Вы автор, Вы творец и Вам виднее.

> Можете привести более законченный/практичный пример где требуется запись ^переменная = ...?
#‘
(^i = 0 цикл i < N; ++ i // i объявлена внутри скобок
   . . .)
j = i                    // но видна за скобками
’

> Практически во всех компилируемых языках переменные необходимо объявлять явно, и я считал этот вопрос решённым и не требующим переосмысления. А сейчас вот даже и не знаю, что ответить, какие весомые аргументы привести в пользу явного объявления.
Вывод типов, то есть инициализация как значения, так и типа, исключает такой класс ошибок, как использование неинициализированных переменных. Вывод типов создаёт иллюзию, что объявлять переменные не надо. Но это только иллюзия, которая придаёт сходство с языками с динамической типизацией.

> мне нравится чётко видеть в коде, где объявляется/создаётся новая переменная, а где изменяется значение уже существующей.
Есть возможность почувствовать вкус иного стиля, попрактиковавшись на языках типа PHP или Basic. Тогда идею вывода типов легче принять. В языках с динамической типизацией тип переменной может меняться по ходу вычислений, а при выводе типов тип переменной задаётся один раз, при инициализации.

> явное объявление позволяет создать новую переменную с уже использующимся именем во внутренней области видимости
Мне кажется, уникальность имён позволяет не париться на эту тему. А если приспичило, то можно неуникальные имена сопровождать именем области видимости. Но, думается, лучше не дублировать имена.

> Хотя для перегрузки функции с одинаковым количеством аргументов указать тип хотя бы некоторых из них, конечно, придётся явно.
И тут склоняюсь к ‘уникальности имён’[http://compiler.su/unikalnost-imyon-funktsij.php]. Хотя полиморфизм времени компиляции даёт некоторую волю, не так уж и сильно ограничивает такая уникальность.

> Правда такую запись — break <число> — в других языках (кроме PHP) я не встречал.
Я уже рассказывал историю своих взаимоотношений с break и continue. Когда-то придумал, что эти ключевые слова надо сделать с числовым параметром. Потом познакомился с PHP и увидел, что break в нём может иметь параметр, а вот continue нет. Потом написал и опубликовал эту идею в статье, которую мы сейчас комментируем. Потом появился язык Jancy, в котором и break, и continue имеют параметр. А автор языка Jancy просит меня включить свой язык в ‘этот список’[http://compiler.su/entuziasty-razrabotchiki-kompilyatorov-i-ikh-proekty.php].
---
2024-11-13 ~‘*‘Неслучайный читатель’’

Если не нравится *‘break 2’, можно заменить на *‘break break’
#‘
цикл
    цикл
        если условие
            break break //выход из обоих циклов
’
То есть *‘break N’ меняется на N штук *‘break’. Как в языках народов Полинезии: если существительное употребляется несколько раз, то столько штук и имелось в виду.

С *‘continue N’ интереснее. Ведь чтобы перейти к продолжению цикла уровня N, надо сперва выйти из N-1 циклов. То есть *‘continue N’ по факту означает *‘break ... break continue’: где *‘break’ повторяется N-1 раз.
---
2024-11-13 ~‘*‘Борис К.’’

*‘Ада’
#‘
цикл1:loop
    ...
    цикл2:loop
        ...
        exit цикл1;
        exit цикл2;
        ...
    end loop цикл2;
    ...
end loop цикл1;
’
---
2024-11-13 ~‘*‘Неслучайный читатель’’

Длинновато с метками.
---
2024-11-14 ~‘*‘alextretyak’’

*‘Автор сайта’
> Вы сами придумали себе трудности, а потом героически их преодолеваете.
[[[Честно говоря, не думал, что можно посмотреть на эту фичу 11l с такой точки зрения.]]]А ведь и правда, можно посмотреть на это и с такой точки зрения. Как-то не думал об этом.
Но всё-таки, синтаксис и возможности языка 11l [[[составлялись/]]]определялись не исходя из его названия (к которому я пришёл далеко не сразу), а наоборот — когда я понял/пришёл к окончательному решению, что корневых ключевых слов достаточно одиннадцати[[[ (и даже решил отказаться от [[[вспомогательного]]] слова *‘extra’ для подслов вне категорий)]]], то решил оставить такое название с целью предотвратить [[[его]]] [[[дальнейшее]]]ненужное раздувание языка.

> Есть возможность почувствовать вкус иного стиля, попрактиковавшись на языках типа PHP или Basic.
Я уже давно напрактиковался в таких языках. Даже свой движок форума написал на PHP и JavaScript.
И если PHP со своими вездесущими «долларами» [перед именем каждой переменной] и "аляповатой" и перегруженной стандартной библиотекой мне никогда не нравился, то JavaScript-ом я поначалу прямо таки восхищался. После C++ (причём версии C++03) с его излишней многословностью, JS ощущался как глоток свежего воздуха. Но восхищение со временем и опытом профессионального программирования [правда не на JS, а на Lua и C++] прошло. И пришло понимание, что строгая типизация всё-таки лучше (а строгая статическая — ещё лучше).
[[[А отсутствием необходимости явного объявления/создания переменных я порядочно «наелся» в Python.]]]Но по опыту программирования на Python я, откровенно говоря, могу признать, что отсутствие необходимости явного объявления/создания переменных — штука весьма удобная.
[[[Более того]]]И вместе с тем, наверное самое большое, что меня в [[[нём/]]]Python раздражает, это смежная/похожая его фича — [[[отсутствие вложенных областей]]]единая область видимости для всех локальных переменных в функции, независимо от того, на каком уровне они создаются.
К примеру, [[[попробуйте догадаться]]]догадываетесь, почему в ‘этой строке кода’[https://sourceforge.net/p/pqmarkup/code/ci/0aafa73f124996c2be99483a4479cd79e1a43d02/tree/pqmarkup.py#l624] [[[используется/]]]написано *‘for ii in ...’, а не просто *‘for i in ...’?
Да потому, что *‘i’ уже используется в этой функции в качестве индекса текущего разбираемого символа входной строки. Но сначала то я в этом месте написал просто *‘i’, в результате чего получилось, что выполнение данного кода приводило к «порче» переменной *‘i’, "объявленной" [[[ранее]]]выше и использующейся в последующем коде. [[[А в другом проекте (не могу точно вспомнить/найти где) я .]]]И я до сих пор [[[порой/]]]иногда забываю про эту "особенность" Python и наступаю на эти грабли (т.е. забываю про то, что добавление невинного цикла *‘for i’ глубоко внутри функции портит значение *‘i’, использующейся в окружающем коде).[[[ Как же это бесит.]]]

> Тогда идею вывода типов легче принять.
Вывод типов в 11l есть. Также как и в новых версиях практически всех популярных компилируемых языков программирования. Вывод типа переменной при её инициализации — это фактически уже стандарт[[[ для всех компилируемых языков программирования]]], им никого не удивишь {и многие им даже злоупотребляют — у нас на работе был программист[[[[речь про Михаила Гасанова]]]], который настолько любил писать всюду *‘auto’, появившийся в C++11 в новом качестве, что вместо *‘int i = 0;’ он писал *‘auto i = 0;’}. [[[Не вижу смысла обсуждать его полезность.]]]Но обсуждаем то мы другое, а именно «необходимость явного обозначения для объявления/создания новой переменной».

> В языках с динамической типизацией тип переменной может меняться по ходу вычислений, а при выводе типов тип переменной задаётся один раз, при инициализации.
Дело не в «динамичности» типизации. В статически типизированном Rust тип переменной тоже может меняться. Эта фича называется “rebinding”. Фактически, Rust позволяет переобъявлять переменную с [[[новым]]]другим типом, скрывая переменную с таким же именем, объявленную ранее. ‘Вот здесь’[https://users.rust-lang.org/t/rebinding-variables-with-let/12959] есть пример кода.
Но аналогичного эффекта можно добиться и в C++ [[[с ]]]использованием фигурных скобок:
#(C++)‘
{auto x = 1;
...
}{auto x = "Hello World!";
...
}
’[[[
>[https://users.rust-lang.org/t/rebinding-variables-with-let/12959 <- google:‘rust var rebind’]:‘
int x = 1;
{
char *x = "hi";
}’
]]]
Единственное, что дополнительно позволяет делать Rust (и что не получится повторить в C++) — это использовать при инициализации новой переменной значение старой/скрываемой переменной с таким же именем:
#(Rust)‘
let s = "123";
...
let s = s.len(); // `s` здесь "меняет" тип на число
// (теперь в `s` [[[количество символов в строке]]|][[[находится/]]|]содержится длина строки `s`)
’[[[Пример навеян [https://www.reddit.com/r/rust/comments/1fx4pse/is_this_an_example_of_shadowing_or_rebinding_in/ <- google:‘rust var rebind’]]]]
Заметьте, что раз ваш язык не предполагает явное обозначение объявления новой переменной, то в вашем языке такой трюк как в Rust повторить не получится.

>‘#‘
(^i = 0 цикл i < N; ++ i // i объявлена внутри скобок
   . . .)
j = i                    // но видна за скобками
’’
Так ведь тут можно, как я уже писал выше «создать переменную чуть раньше за скобкой»:
#‘
i = 0
(цикл i < N; ++ i
   . . .)
j = i
’
Или можно даже так:
#‘
i = 0; (цикл i < N; ++ i
   . . .)
j = i
’
В последнем случае количество строк кода будет такое же.
И даже количество символов такое же.
И даже специальный синтаксис с префиксным «^» не нужен.
И даже читаемость/понятность кода лучше.
