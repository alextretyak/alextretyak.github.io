Н‘‘Продолжение цикла и выход из него (ссылка на статью)’[http://compiler.su/prodolzhenie-tsikla-i-vykhod-iz-nego.php]’

Комментарии:
---
2024-10-23 ~‘*‘bvz’’

Такое чувство, что проблема искусственно создана на ровном месте. Специально, чтобы потом триумфально разрешить её с помощью оператора goto. Кроме циклов for, между прочим, существуют также ещё и циклы while и until. Что мешает использовать один из них? Пусть условие надо_выйти_из_цикла с отрицанием добавлено через конъюнкцию в самый внешний цикл while. И тогда на каждом шаге этого самого внешнего цикла будет проверяться истинность условия надо_выйти_из_цикла.

Собственно говоря, циклы for, по-моему, придумали с одной единственной целью: избавиться от записи i=i+1 внутри цикла и включить её в заголовок. В некоторых случаях это, может, и удобно. Но если в данном конкретном случае цикл for не подходит, зачем нужно насильно его использовать?
---
2024-10-23 ~‘*‘Автор сайта’’

Не знаю, искусственным ли путём образовалась проблема или естественным. Однако до сих пор для выхода из нескольких циклов используют либо «goto»
#‘
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            goto <метка>
    // конец второго цикла
// конец первого цикла
<метка>:
’
либо заменитель «goto» («break» с меткой)
#‘
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            break <метка>
    // конец второго цикла
// конец первого цикла
<метка>:
’
либо пользуются самым длинным вариантом — создают дополнительные переменные с дополнительными танцами с бубнами:
#‘
надо_выйти_из_цикла = ложь
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            надо_выйти_из_цикла = истина
            break
    // конец второго цикла
    если надо_выйти_из_цикла
        break
// конец первого цикла
<метка>:
’
Независимо от вида цикла: «while», «until», «for».

> чтобы потом триумфально разрешить её с помощью оператора goto.
Вы невнимательно читали. Как раз-то этот вариант
#‘
цикл <проверка условия>
    цикл <проверка условия>
        если <дополнительная проверка условия>
            break N  // N -число циклов, которые надо покинуть
’
и самый лаконичный, и самый прозрачный. Для него не нужны ни метки (как для «goto» и «break» с меткой), ни дополнительные переменные.
---
2024-10-24 ~‘*‘bvz’’

Автор сайта, ладно, я понял вашу мысль. Лаконичный — это значит, краткий, правильно? Но ведь не всегда краткий = изящный. Изящность, как и красота — вещь довольно субъективная. На мой взгляд, изящно было бы писать программу, придерживаясь один раз принятых принципов. Например, не использовать оператор goto. И никогда не отступая от них. Но вы и не использовали, вы использовали break N.

Короче, я бы всё равно писал по-своему. Я только не понял, предлагал ли кто-нибудь выше мой вариант. А что касается искусственности созданной проблемы — проблема эта возникает в тот момент, когда "бывают такие ситуации, когда условие выхода удобнее проверить не в заголовке цикла, а «по месту требования»." Так вот, я бы просто поместил это условие именно в заголовок каждого цикла. Руки бы у меня от этого не отвалились. Удобство или неудобство может возникнуть на стадии понимания программы. Но опять-таки, не думаю, что такую программу будет намного труднее понять.

И более того. Если вы всегда записываете условие выхода в заголовок цикла, все такие программы будут выглядеть одинаково. Вне зависимости от количества вложенных циклов. Соответственно, исчезает возможность ошибиться на стадии break N. Например, написать break 6 вместо break 5. А может, и вовсе стоит написать рекурсивную процедуру для неограниченного числа вложенных "циклов".

Хотя, строго говоря, такие алгоритмы, наверное, не будут эквивалентными. Если я проверяю некое условие в заголовке каждого цикла, я делаю дополнительное действие, правильно? Значит, программа будет медленнее работать. Но я такими вещами никогда не заморачивался, честно говоря.
---
2024-10-26 ~‘*‘alextretyak’’

> Так вот, я бы просто поместил это условие именно в заголовок каждого цикла.
Не во всех языках программирования в заголовок цикла *‘for’ можно вставить дополнительное условие.
Например, в том же Python нет универсального цикла *‘for’. И для выхода из нескольких циклов приходится, как уже было сказано выше «создавать дополнительные переменные с дополнительными танцами с бубнами».

Вот конкретный пример.
У меня есть Python-скрипт, которому требуется определить директорию с установленной Microsoft Visual Studio, [[[причём самой]]][[[как можно более новой версии]]]причём более новые версии должны быть в приоритете.
Для этого я использовал такой вложенный цикл:
#(Python)‘
for version in ['2022', '2019', '2017', '2015', '2013']:
    for edition in ['BuildTools', 'Community', 'Enterprise', 'Professional']:
        if os.path.isfile('C:\\Program Files (x86)\\Microsoft Visual Studio\\' + version
                          + '\\' + edition + R'\VC\Auxiliary\Build\vcvarsall.bat'):
            ... # здесь нужно выйти из всех циклов
’

Но недавно этот скрипт пришлось поправить, так как оказалось, что 2022-ая студия может быть установлена не в "C:\Program Files (x86)", а в "C:\Program Files".
Вот ссылка на мой коммит с этой правкой: [https://github.com/symasm/symasm/commit/7d2f432a9ef45784646a01662be874abb8ba17e7].
В итоге код получился вот таким:
#(Python)‘
was_break = False
for version in ['2022', '2019', '2017', '2015', '2013']:
    for edition in ['BuildTools', 'Community', 'Enterprise', 'Professional']:
        for x86 in [0, 1]:
            vcvarsall = 'C:\\Program Files' + ' (x86)'*x86 + '\\Microsoft Visual Studio\\' + version + '\\' + edition + R'\VC\Auxiliary\Build\vcvarsall.bat'
            if os.path.isfile(vcvarsall):
                was_break = True
                #print('Using ' + version + '\\' + edition)
                break
        if was_break:
            break
    if was_break:
        break
if was_break:
    masm_pathname = subprocess.check_output('"' + vcvarsall + '" x64 > nul && where ml64', encoding = 'ascii').rstrip()
    open('masm_pathname.txt', 'w').write(masm_pathname)
else:
    print('''Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].''')
    masm_pathname = '-'
’

Видите замечательную лесенку из #(Python)‘if was_break’?
И теперь представьте, что вам запросто может потребоваться добавить ещё один вложенный цикл *‘for’.

А если использовать язык программирования с возможностью выхода из нескольких циклов, например 11l, то код получится значительно проще:
#(11l)‘
loop(version) [‘2022’, ‘2019’, ‘2017’, ‘2015’, ‘2013’]
   loop(edition) [‘BuildTools’, ‘Community’, ‘Enterprise’, ‘Professional’]
      loop(x86) [0, 1]
         var vcvarsall = ‘C:\Program Files’(‘ (x86)’*x86)‘\Microsoft Visual Studio\’version‘\’edition‘\VC\Auxiliary\Build\vcvarsall.bat’
         if fs:is_file(vcvarsall)
            //print(‘Using ’version‘\’edition)
            masm_pathname = os:(‘"’vcvarsall‘" x64 > nul && where ml64’).stdout.rtrim("\n")
            File(‘masm_pathname.txt’, WRITE).write(masm_pathname)
            loop(version).break

loop.was_no_break
   print(‘Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].’)
   masm_pathname = ‘-’
’

Конструкция *‘loop(version).break’ осуществляет выход из соответствующего цикла (в языке 11l меток нет).
Вместо неё можно использовать эквивалентную (при данном количестве вложенных циклов!) конструкцию: *‘^^loop.break’.
Я выбрал символы крышечки (^) вместо числа после *‘break’, так как:
1.‘не очевидно с какого числа начинается отсчёт, с 0 или с 1 (в PHP начинается с 1, т.е. просто *‘break’ равнозначен *‘break 1’, а чтобы прервать внешний цикл, нужно использовать *‘break 2’, но в программировании нумерацию принято начинать с 0, т.е. было бы логично, что просто *‘break’ равнозначен *‘break 0’... в общем, возможна путаница; с крышечками же логика проще — если их нет, то *‘loop.break’ он и в Африке... осуществляет выход только из текущего цикла, если одна крышечка, то выходим из вышестоящего цикла по отношению к текущему, если крышечки две, то идём ещё выше (сам этот символ символизирует направление вверх, потому он и был выбран {
Но ведь *‘^loop.break’ по факту осуществляет переход не выше/вверх, а вниз, сразу к коду после цикла. Как же так?
Дело тут в том, что крышечка (^) относится не к *‘loop.break’, а к *‘loop’. Т.е. имеется в виду *‘(^loop).break’, а не *‘^(loop.break)’.
И использовать крышечку/-ки перед *‘loop’ можно не только для выхода из цикла, но и для продолжения цикла — *‘^loop.continue’, для получения индекса (номера[[[,]]] начиная с 0) текущей итерации цикла — *‘^loop.index’ и т.д.
}) и т.д.);’
2.‘число после *‘break’ создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например *‘break 2+3’ или вообще вставить какую-[[[то/]]]нибудь переменную:
#(11l)‘
loop ...
    loop ...
       loop ...
          int entered_number = int(input(‘Сколько циклов вы хотите покинуть?’))
          break entered_number
’’

Более «монолитно», чем *‘break 2’, выглядит запись *‘break_2’, но так сделать в языке программирования не получится[[[ —]]], т.к. break_2 может быть действительным именем переменной/идентификатором.

Но если вернуться к исходной проблеме — лесенке из #(Python)‘if was_break’, то есть и друго[[[й выход]]]е решение — поместить необходимую логику внутрь функции, которая вместо *‘break’ будет делать *‘return’.
Но мне не нравится такое решение — нужно придумывать имя для новой функции, которая используется только в одном месте и только для обхода ограничения используемого языка программирования. Похоже на костыль.

> Хотя для применения «continue N» не очень легко привести пример из жизни для иллюстрации его полезности. Возможно, читатели этих строк предложат что-то в комментариях к статье.
Предложат-предложат. :)(:

Вот два наиболее интересных встретившихся мне примера, в которых было бы оправдано применение «continue N»:
1. В транспайлере Python → 11l вот ‘эти 4 строки’[https://github.com/11l-lang/python_to_11l/blob/f54b0475ebbceaea280e1b9eca6eab99069f2f4f/parse.py#L3053-L3056] не самого понятного Python-кода можно заменить одной строкой *‘^loop.continue’ (аналог *‘continue 2’).
2. Этот ‘код на языке D’[https://rosettacode.org/wiki/Peaceful_chess_queen_armies#D] использует *‘continue <метка>’ [и, как видно по этой же веб-странице, эту конструкцию поддерживают также языки Go, Java, Kotlin, Swift], но т.к. Python такого не поддерживает, пришлось усложнить логику путём добавления двух else-веток для for — ‘вот этот перевод на Python’[https://github.com/11l-lang/_11l_to_cpp/blob/master/tests/python_to_cpp/Rosetta%20Code/p.txt#L2272].
Там же на rosettacode.org можно поискать ещё хорошие примеры употребления *‘continue <метка>’ (вдруг я что-то упустил).
