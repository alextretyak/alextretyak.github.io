<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/prodolzhenie-tsikla-i-vykhod-iz-nego.php">Продолжение цикла и выход из него (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
2024-10-23 <i><b>bvz</b></i><br />
<br />
Такое чувство, что проблема искусственно создана на ровном месте. Специально, чтобы потом триумфально разрешить её с помощью оператора goto. Кроме циклов for, между прочим, существуют также ещё и циклы while и until. Что мешает использовать один из них? Пусть условие надо_выйти_из_цикла с отрицанием добавлено через конъюнкцию в самый внешний цикл while. И тогда на каждом шаге этого самого внешнего цикла будет проверяться истинность условия надо_выйти_из_цикла.<br />
<br />
Собственно говоря, циклы for, по-моему, придумали с одной единственной целью: избавиться от записи i=i+1 внутри цикла и включить её в заголовок. В некоторых случаях это, может, и удобно. Но если в данном конкретном случае цикл for не подходит, зачем нужно насильно его использовать?<br />
<hr />
2024-10-23 <i><b>Автор сайта</b></i><br />
<br />
Не знаю, искусственным ли путём образовалась проблема или естественным. Однако до сих пор для выхода из нескольких циклов используют либо «goto»<br />
<pre class="code_block">
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            goto &lt;метка>
    // конец второго цикла
// конец первого цикла
&lt;метка>:
</pre>
либо заменитель «goto» («break» с меткой)<br />
<pre class="code_block">
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            break &lt;метка>
    // конец второго цикла
// конец первого цикла
&lt;метка>:
</pre>
либо пользуются самым длинным вариантом — создают дополнительные переменные с дополнительными танцами с бубнами:<br />
<pre class="code_block">
надо_выйти_из_цикла = ложь
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            надо_выйти_из_цикла = истина
            break
    // конец второго цикла
    если надо_выйти_из_цикла
        break
// конец первого цикла
&lt;метка>:
</pre>
Независимо от вида цикла: «while», «until», «for».<br />
<br />
<blockquote>чтобы потом триумфально разрешить её с помощью оператора goto.</blockquote>
Вы невнимательно читали. Как раз-то этот вариант<br />
<pre class="code_block">
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            break N  // N -число циклов, которые надо покинуть
</pre>
и самый лаконичный, и самый прозрачный. Для него не нужны ни метки (как для «goto» и «break» с меткой), ни дополнительные переменные.<br />
<hr />
2024-10-24 <i><b>bvz</b></i><br />
<br />
Автор сайта, ладно, я понял вашу мысль. Лаконичный — это значит, краткий, правильно? Но ведь не всегда краткий = изящный. Изящность, как и красота — вещь довольно субъективная. На мой взгляд, изящно было бы писать программу, придерживаясь один раз принятых принципов. Например, не использовать оператор goto. И никогда не отступая от них. Но вы и не использовали, вы использовали break N.<br />
<br />
Короче, я бы всё равно писал по-своему. Я только не понял, предлагал ли кто-нибудь выше мой вариант. А что касается искусственности созданной проблемы — проблема эта возникает в тот момент, когда "бывают такие ситуации, когда условие выхода удобнее проверить не в заголовке цикла, а «по месту требования»." Так вот, я бы просто поместил это условие именно в заголовок каждого цикла. Руки бы у меня от этого не отвалились. Удобство или неудобство может возникнуть на стадии понимания программы. Но опять-таки, не думаю, что такую программу будет намного труднее понять.<br />
<br />
И более того. Если вы всегда записываете условие выхода в заголовок цикла, все такие программы будут выглядеть одинаково. Вне зависимости от количества вложенных циклов. Соответственно, исчезает возможность ошибиться на стадии break N. Например, написать break 6 вместо break 5. А может, и вовсе стоит написать рекурсивную процедуру для неограниченного числа вложенных "циклов".<br />
<br />
Хотя, строго говоря, такие алгоритмы, наверное, не будут эквивалентными. Если я проверяю некое условие в заголовке каждого цикла, я делаю дополнительное действие, правильно? Значит, программа будет медленнее работать. Но я такими вещами никогда не заморачивался, честно говоря.<br />
<hr />
2024-10-26 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Так вот, я бы просто поместил это условие именно в заголовок каждого цикла.</blockquote>
Не во всех языках программирования в заголовок цикла <b>for</b> можно вставить дополнительное условие.<br />
Например, в том же Python нет универсального цикла <b>for</b>. И для выхода из нескольких циклов приходится, как уже было сказано выше «создавать дополнительные переменные с дополнительными танцами с бубнами».<br />
<br />
Вот конкретный пример.<br />
У меня есть Python-скрипт, которому требуется определить директорию с установленной Microsoft Visual Studio, <!--[[[причём самой]]]--><!--[[[как можно более новой версии]]]-->причём более новые версии должны быть в приоритете.<br />
Для этого я использовал такой вложенный цикл:<br />
<style>
span.keyword {color: #0000FF; font-weight: bold;}
span.identifier {color: #00009F;}
span.string-literal {color: #800000;}
span.numeric-literal {color: #008000;}
span.constant {color: #008000;}
span.comment {color: #808080;}
</style><pre class="code_block">
<span class="keyword">for</span> <span class="identifier">version</span> <span class="keyword">in</span> [<span class="string-literal">'2022'</span>, <span class="string-literal">'2019'</span>, <span class="string-literal">'2017'</span>, <span class="string-literal">'2015'</span>, <span class="string-literal">'2013'</span>]:
    <span class="keyword">for</span> <span class="identifier">edition</span> <span class="keyword">in</span> [<span class="string-literal">'BuildTools'</span>, <span class="string-literal">'Community'</span>, <span class="string-literal">'Enterprise'</span>, <span class="string-literal">'Professional'</span>]:
        <span class="keyword">if</span> <span class="identifier">os</span>.<span class="identifier">path</span>.<span class="identifier">isfile</span>(<span class="string-literal">'C:\\Program Files (x86)\\Microsoft Visual Studio\\'</span> + <span class="identifier">version</span>
                          + <span class="string-literal">'\\'</span> + <span class="identifier">edition</span> + <span class="string-literal">R'\VC\Auxiliary\Build\vcvarsall.bat'</span>):
            ... <span class="comment"># здесь нужно выйти из всех циклов</span>
</pre>
<br />
Но недавно этот скрипт пришлось поправить, так как оказалось, что 2022-ая студия может быть установлена не в "C:\Program Files (x86)", а в "C:\Program Files".<br />
Вот ссылка на мой коммит с этой правкой: <a href="https://github.com/symasm/symasm/commit/7d2f432a9ef45784646a01662be874abb8ba17e7">https://github.com/symasm/symasm/commit/7d2f432a9ef45784646a01662be874abb8ba17e7</a>.<br />
В итоге код получился вот таким:<br />
<pre class="code_block">
<span class="identifier">was_break</span> = <span class="constant">False</span>
<span class="keyword">for</span> <span class="identifier">version</span> <span class="keyword">in</span> [<span class="string-literal">'2022'</span>, <span class="string-literal">'2019'</span>, <span class="string-literal">'2017'</span>, <span class="string-literal">'2015'</span>, <span class="string-literal">'2013'</span>]:
    <span class="keyword">for</span> <span class="identifier">edition</span> <span class="keyword">in</span> [<span class="string-literal">'BuildTools'</span>, <span class="string-literal">'Community'</span>, <span class="string-literal">'Enterprise'</span>, <span class="string-literal">'Professional'</span>]:
        <span class="keyword">for</span> <span class="identifier">x86</span> <span class="keyword">in</span> [<span class="numeric-literal">0</span>, <span class="numeric-literal">1</span>]:
            <span class="identifier">vcvarsall</span> = <span class="string-literal">'C:\\Program Files'</span> + <span class="string-literal">' (x86)'</span>*<span class="identifier">x86</span> + <span class="string-literal">'\\Microsoft Visual Studio\\'</span> + <span class="identifier">version</span> + <span class="string-literal">'\\'</span> + <span class="identifier">edition</span> + <span class="string-literal">R'\VC\Auxiliary\Build\vcvarsall.bat'</span>
            <span class="keyword">if</span> <span class="identifier">os</span>.<span class="identifier">path</span>.<span class="identifier">isfile</span>(<span class="identifier">vcvarsall</span>):
                <span class="identifier">was_break</span> = <span class="constant">True</span>
                <span class="comment">#print('Using ' + version + '\\' + edition)</span>
                <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="identifier">was_break</span>:
            <span class="keyword">break</span>
    <span class="keyword">if</span> <span class="identifier">was_break</span>:
        <span class="keyword">break</span>
<span class="keyword">if</span> <span class="identifier">was_break</span>:
    <span class="identifier">masm_pathname</span> = <span class="identifier">subprocess</span>.<span class="identifier">check_output</span>(<span class="string-literal">'"'</span> + <span class="identifier">vcvarsall</span> + <span class="string-literal">'" x64 > nul &amp;&amp; where ml64'</span>, <span class="identifier">encoding</span> = <span class="string-literal">'ascii'</span>).<span class="identifier">rstrip</span>()
    <span class="identifier">open</span>(<span class="string-literal">'masm_pathname.txt'</span>, <span class="string-literal">'w'</span>).<span class="identifier">write</span>(<span class="identifier">masm_pathname</span>)
<span class="keyword">else</span>:
    <span class="identifier">print</span>(<span class="string-literal">'''Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].'''</span>)
    <span class="identifier">masm_pathname</span> = <span class="string-literal">'-'</span>
</pre>
<br />
Видите замечательную лесенку из <pre style="display: inline"><span class="keyword">if</span> <span class="identifier">was_break</span></pre>?<br />
И теперь представьте, что вам запросто может потребоваться добавить ещё один вложенный цикл <b>for</b>.<br />
<br />
А если использовать язык программирования с возможностью выхода из нескольких циклов, например 11l, то код получится значительно проще:<br />
<pre class="code_block">
<span class="keyword">loop</span>(<span class="identifier">version</span>) [<span class="string-literal">‘2022’</span>, <span class="string-literal">‘2019’</span>, <span class="string-literal">‘2017’</span>, <span class="string-literal">‘2015’</span>, <span class="string-literal">‘2013’</span>]
   <span class="keyword">loop</span>(<span class="identifier">edition</span>) [<span class="string-literal">‘BuildTools’</span>, <span class="string-literal">‘Community’</span>, <span class="string-literal">‘Enterprise’</span>, <span class="string-literal">‘Professional’</span>]
      <span class="keyword">loop</span>(<span class="identifier">x86</span>) [<span class="numeric-literal">0</span>, <span class="numeric-literal">1</span>]
         <span class="keyword">var</span> <span class="identifier">vcvarsall</span> = <span class="string-literal">‘C:\Program Files’</span>(<span class="string-literal">‘ (x86)’</span>*<span class="identifier">x86</span>)<span class="string-literal">‘\Microsoft Visual Studio\’</span><span class="identifier">version</span><span class="string-literal">‘\’</span><span class="identifier">edition</span><span class="string-literal">‘\VC\Auxiliary\Build\vcvarsall.bat’</span>
         <span class="keyword">if</span> <span class="identifier">fs</span>:<span class="identifier">is_file</span>(<span class="identifier">vcvarsall</span>)
            <span class="comment">//print(‘Using ’version‘\’edition)</span>
            <span class="identifier">masm_pathname</span> = <span class="identifier">os</span>:(<span class="string-literal">‘"’</span><span class="identifier">vcvarsall</span><span class="string-literal">‘" x64 > nul &amp;&amp; where ml64’</span>).<span class="identifier">stdout</span>.<span class="identifier">rtrim</span>(<span class="string-literal">"\n"</span>)
            <span class="identifier">File</span>(<span class="string-literal">‘masm_pathname.txt’</span>, <span class="identifier">WRITE</span>).<span class="identifier">write</span>(<span class="identifier">masm_pathname</span>)
            <span class="keyword">loop</span>(<span class="identifier">version</span>).<span class="identifier">break</span>

<span class="keyword">loop.was_no_break</span>
   <span class="identifier">print</span>(<span class="string-literal">‘Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].’</span>)
   <span class="identifier">masm_pathname</span> = <span class="string-literal">‘-’</span>
</pre>
<br />
Конструкция <b>loop(version).break</b> осуществляет выход из соответствующего цикла (в языке 11l меток нет).<br />
Вместо неё можно использовать эквивалентную (при данном количестве вложенных циклов!) конструкцию: <b>^^loop.break</b>.<br />
Я выбрал символы крышечки (^) вместо числа после <b>break</b>, так как:<br />
<ol>
<li>не очевидно с какого числа начинается отсчёт, с 0 или с 1 (в PHP начинается с 1, т.е. просто <b>break</b> равнозначен <b>break 1</b>, а чтобы прервать внешний цикл, нужно использовать <b>break 2</b>, но в программировании нумерацию принято начинать с 0, т.е. было бы логично, что просто <b>break</b> равнозначен <b>break 0</b>... в общем, возможна путаница; с крышечками же логика проще — если их нет, то <b>loop.break</b> он и в Африке... осуществляет выход только из текущего цикла, если одна крышечка, то выходим из вышестоящего цикла по отношению к текущему, если крышечки две, то идём ещё выше (сам этот символ символизирует направление вверх, потому он и был выбран <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none"><br />
Но ведь <b>^loop.break</b> по факту осуществляет переход не выше/вверх, а вниз, сразу к коду после цикла. Как же так?<br />
Дело тут в том, что крышечка (^) относится не к <b>loop.break</b>, а к <b>loop</b>. Т.е. имеется в виду <b>(^loop).break</b>, а не <b>^(loop.break)</b>.<br />
И использовать крышечку/-ки перед <b>loop</b> можно не только для выхода из цикла, но и для продолжения цикла — <b>^loop.continue</b>, для получения индекса (номера<!--[[[,]]]--> начиная с 0) текущей итерации цикла — <b>^loop.index</b> и т.д.<br />
</span><span class="cu_brackets_b">}</span></span>) и т.д.);</li>
<li>число после <b>break</b> создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например <b>break 2+3</b> или вообще вставить какую-<!--[[[то/]]]-->нибудь переменную:<br />
<pre class="code_block">
<span class="keyword">loop</span> ...
    <span class="keyword">loop</span> ...
       <span class="keyword">loop</span> ...
          <span class="identifier">int</span> <span class="identifier">entered_number</span> = <span class="identifier">int</span>(<span class="identifier">input</span>(<span class="string-literal">‘Сколько циклов вы хотите покинуть?’</span>))
          <span class="identifier">break</span> <span class="identifier">entered_number</span>
</pre></li>
</ol>
<br />
Более «монолитно», чем <b>break 2</b>, выглядит запись <b>break_2</b>, но так сделать в языке программирования не получится<!--[[[ —]]]-->, т.к. break_2 может быть действительным именем переменной/идентификатором.<br />
<br />
Но если вернуться к исходной проблеме — лесенке из <pre style="display: inline"><span class="keyword">if</span> <span class="identifier">was_break</span></pre>, то есть и друго<!--[[[й выход]]]-->е решение — поместить необходимую логику внутрь функции, которая вместо <b>break</b> будет делать <b>return</b>.<br />
Но мне не нравится такое решение — нужно придумывать имя для новой функции, которая используется только в одном месте и только для обхода ограничения используемого языка программирования. Похоже на костыль.<br />
<br />
<blockquote>Хотя для применения «continue N» не очень легко привести пример из жизни для иллюстрации его полезности. Возможно, читатели этих строк предложат что-то в комментариях к статье.</blockquote>
Предложат-предложат. :)(:<br />
<br />
Вот два наиболее интересных встретившихся мне примера, в которых было бы оправдано применение «continue N»:<br />
<ol>
<li>В транспайлере Python → 11l вот <a href="https://github.com/11l-lang/python_to_11l/blob/f54b0475ebbceaea280e1b9eca6eab99069f2f4f/parse.py#L3053-L3056">эти 4 строки</a> не самого понятного Python-кода можно заменить одной строкой <b>^loop.continue</b> (аналог <b>continue 2</b>).</li>
<li>Этот <a href="https://rosettacode.org/wiki/Peaceful_chess_queen_armies#D">код на языке D</a> использует <b>continue &lt;метка></b> <span class="sq"><span class="sq_brackets">[</span>и, как видно по этой же веб-странице, эту конструкцию поддерживают также языки Go, Java, Kotlin, Swift<span class="sq_brackets">]</span></span>, но т.к. Python такого не поддерживает, пришлось усложнить логику путём добавления двух else-веток для for — <a href="https://github.com/11l-lang/_11l_to_cpp/blob/master/tests/python_to_cpp/Rosetta%20Code/p.txt#L2272">вот этот перевод на Python</a>.</li>
</ol>
Там же на rosettacode.org можно поискать ещё хорошие примеры употребления <b>continue &lt;метка></b> (вдруг я что-то упустил).<br />
<hr />
2024-10-26 <i><b>Автор сайта</b></i><br />
<br />
<blockquote><b>^^loop.break</b></blockquote>
Я префиксному «^» собираюсь назначить иную роль. Один такой символ — увеличение области видимости на уровень выше. То есть за пределы скобки <!--[[[(]]]-->«)»:<br />
<pre class="code_block">
( (^переменная = ... // инициализация переменной с выводом её типа
    ... = переменная // внутри скобок она видна
  )
  ... = переменная   // за пределами первой пары скобок тоже видна
)
... = переменная   // за пределами второй пары скобок не видна
</pre>
<br />
<blockquote>не очевидно с какого числа начинается отсчёт, с 0 или с 1</blockquote>
Число после «break» — это <b>сколько циклов надо покинуть</b>. Если 0, то значит цикл покидать не надо.<br />
<br />
<blockquote>число после break создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например break 2+3</blockquote>
Компилятор разочарует своими сообщениями об ошибках. Так же, как если бы вместо var4 написали бы var2*2.<br />
<br />
<blockquote>эти 4 строки не самого понятного Python-кода можно заменить одной строкой <b>^loop.continue</b></blockquote>
👍<br />
<hr />
2024-10-26 <i><b>ИванАс</b></i><br />
<br />
<blockquote><pre class="code_block">
<span class="keyword">for</span> <span class="identifier">version</span> <span class="keyword">in</span> [<span class="string-literal">'2022'</span>, <span class="string-literal">'2019'</span>, <span class="string-literal">'2017'</span>, <span class="string-literal">'2015'</span>, <span class="string-literal">'2013'</span>]:
    <span class="keyword">for</span> <span class="identifier">edition</span> <span class="keyword">in</span> [<span class="string-literal">'BuildTools'</span>, <span class="string-literal">'Community'</span>, <span class="string-literal">'Enterprise'</span>, <span class="string-literal">'Professional'</span>]:
        <span class="keyword">for</span> <span class="identifier">x86</span> <span class="keyword">in</span> [<span class="numeric-literal">0</span>, <span class="numeric-literal">1</span>]
</pre></blockquote>
Наверное, можно заменить на product из itertools.<br />
<hr />
2024-10-28 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Я префиксному «^» собираюсь назначить иную роль. Один такой символ — увеличение области видимости на уровень выше.</blockquote>
Так одно другому не мешает.<br />
В 11l, кстати, планируется аналогичный функционал: использовать префиксы <b>^</b> для доступа к переменным из внешней области видимости. Особенно это может быть полезно во время отладки (например, есть цикл по <b>i</b>, внутри него ещё какой-то цикл, внутри которого ещё маленький цикл по <b>i</b>, находясь в котором хочется получить текущее значение переменной <b>i</b> верхнего уровня, это можно сделать посредством записи <b>^i</b>).<!--[[[
#rec##audio#[REC_0003412.wav][в СвН соборе в углу на лавочке у иконы Арх. Михаилу]
Я об этом писал ещё в статье «Каркас нового языка программирования».
]]]--> Я об этом писал ещё в статье «Каркас нового языка программирования» на Хабре и в комментариях там по<!--[[[ этому]]]--> поводу этой возможности велись <!--[[[активные/]]]-->горячие споры: <a href="https://habr.com/ru/articles/350694/comments/#comment_10701298">https://habr.com/ru/articles/350694/comments/#comment_10701298</a>.<br />
Также хочу обратить внимание на то, что в записи <b>^^loop.break</b> крышечки относятся не к <b>break</b>, а к <b>loop</b>. Т.е. имеется в виду <b>(‍^^loop).break</b>, а не <b>^^(loop.break)</b>.<br />
<br />
<blockquote><pre class="code_block">
( (^переменная = ... // инициализация переменной с выводом её типа
    ... = переменная // внутри скобок она видна
  )
  ... = переменная   // за пределами первой пары скобок тоже видна
)
</pre></blockquote>
Ну в чистом виде такой код малополезен — проще создать переменную чуть раньше за скобкой. А на практике может понадобиться создать «внешнюю» переменную в теле условного оператора. Вот только вопрос<!--[[[,]]]-->: что делать в случае, когда условие не выполняется — <!--[[[ведь обращение к этой переменной осуществляется]]]-->как должно отрабатывать обращение к этой переменной в последующем коде?<br />
<br />
И разве ваш язык не предполагает явное обозначение объявления новой переменной?<br />
В 11l обязательно указывать при инициализации, что объявляется новая переменная, с помощью ключевого слова <b>var</b>\<b>пер</b>:<br />
<pre class="code_block">
<span class="keyword">если</span> &lt;<span class="identifier">условие</span>>
   <span class="keyword">пер</span> <span class="identifier">имя_новой_переменной1</span> = ...  <span class="comment">// видна только внутри тела условного оператора</span>
   <span class="keyword">пер</span> ^<span class="identifier">имя_новой_переменной2</span> = ... <span class="comment">// видна также снаружи,</span>
<span class="identifier">вывод</span>(<span class="identifier">имя_новой_переменной2</span>)        <span class="comment">// но что делать, если &lt;условие> ложно?</span>
</pre>
<br />
Также префикс <b>^</b> можно будет использовать для обозначения «внешних» счётчиков цикла:<br />
<pre class="code_block">
<span class="keyword">цикл</span>(^<span class="identifier">н</span>) <span class="numeric-literal">0</span> .&lt; <span class="numeric-literal">100</span> <span class="comment">// цикл от 0 до 100, включая 0, но не включая 100</span>
   <span class="keyword">если</span> &lt;<span class="identifier">условие</span>>
      <span class="keyword">цикл.прервать</span> <span class="comment">// или цикл.выход</span>

<span class="identifier">вывод</span>(<span class="identifier">н</span>) <span class="comment">// выводим значение `н` на итерации, в которой цикл был прерван</span>
         <span class="comment">// если цикл не был прерван, то в `н` будет число 100</span>
</pre>
И перед точкой:<br />
<pre class="code_block">
.offset = 5
pos1.
   pos2.
      .x = 10 + ^.x + ^^.offset
     └─┬┘      └─┬─┘ └────┬────┘
       │         │        ╘═(^^.).offset = 5
       ╘═pos2.x  ╘═pos1.x
</pre>
И ещё — для внешних return:<br />
<pre class="code_block">
<span class="keyword">фн</span> <span class="identifier">внешняя_функция</span>(...)
   <span class="keyword">фн</span> <span class="identifier">локальная_функция</span>()
      ^<span class="identifier">возврат</span> <span class="comment">// возврат из внешней функции</span>
   <span class="identifier">локальная_функция</span>()
   ... <span class="comment">// этот код выполняться не будет, т.к. внутри вызова</span>
   ... <span class="comment">// локальной функции осуществляется возврат из внешней</span>
</pre><!--[[[
На замечание «это приводит к неочевидной логике работы кода функции» я могу ответить, что внешний/глубокий return ничем не хуже исключений, которые возбуждаются при обращении к элементу по индексу за границами массива или при арифметических переполнениях.
]]]-->
<br />
<blockquote>Число после «break» — это сколько циклов надо покинуть. Если 0, то значит цикл покидать не надо.</blockquote>
А вот разработчики языка PHP с вами не согласны.<br />
В версии до 5.4 <b>break 0</b> работал так же как <b>break 1</b>, а в 5.4 и более новых версиях — писать <b>break 0</b> вообще запретили.<br />
<a href="https://php.ru/manual/control-structures.break.html">https://php.ru/manual/control-structures.break.html</a><!--[[[ <- google:‘php "break 0"’]]]--><br />
<br />
<blockquote>Компилятор разочарует своими сообщениями об <b>ошибках</b>. Так же, как если бы вместо var4 написали бы var2*2.</blockquote>
Эмм. Не понял, а в чём ошибка компиляции в записи var2*2? Это же простое умножение значения переменной var2 на число 2.<!--[[[
Если речь про ошибку «переменная не найдена», то если есть переменная var4, то скорее всего есть и var2. :)(:]]]--><br />
<hr />
2024-11-04 <i><b>Автор сайта</b></i><br />
<br />
<b>alextretyak</b>, наконец-то отвечаю Вам.<br />
<blockquote>В 11l, кстати</blockquote>
Кстати, что означает такое название языка? Почему оно такое?<br />
<br />
<blockquote>в записи ^^loop.break крышечки относятся не к break, а к loop. Т.е. имеется в виду (^^loop).break, а не ^^(loop.break).</blockquote>
Не очень понимаю, зачем оператору break нужен loop. И так же ясно, что выйти можно только из цикла. В одних местах Вы стремитесь к наибольшей краткости, а в этом месте — нет. Даже case с двоеточием убираете из конструкции switch, оставляете одну константу. А тут такая расточительность.<br />
<br />
<blockquote>такой код малополезен — проще создать переменную чуть раньше за скобкой.</blockquote>
Если чуть раньше, то значит<br />
<ul>
<li>просто её объявить, без инициализации. Тогда придётся делать анализ: а не используется ли эта переменная в правой части присваивания, будучи неинициализированной?</li>
<li>Или инициализировать, но инициализация за скобкой будет бесполезной: значение в последующем будет изменено, а инициализирующее значение так и не понадобится.</li>
</ul>
Инициализация же в нужном месте с распространением видимости на уровень выше упрощает применение вывода типа через инициализацию.<br />
<br />
<blockquote>А на практике может понадобиться создать «внешнюю» переменную в теле условного оператора. Вот только вопрос: что делать в случае, когда условие не выполняется — как должно отрабатывать обращение к этой переменной в последующем коде?</blockquote>
Инициализация переменной должна произойти во всех альтернативных ветвях кода во избежание использования неинициализированной переменной в правой части присваивания.<br />
<br />
Но лучше это делать конструкцией вроде этой:<br />
<pre class="code_block">
а = (если условие; "это правда" иначе "не верь этому")
</pre>
<br />
<blockquote>не предполагает явное обозначение объявления новой переменной?</blockquote>
Да, не предполагает. Хотя, если требуется, можно уточнить тип инициализирующего значения.<br />
<br />
<blockquote>В 11l обязательно указывать при инициализации, что объявляется новая переменная, с помощью ключевого слова</blockquote>
У Алексея Недори в его Тривиле сделано весьма любопытно<br />
<pre class="code_block">
а = 9  // а — константа, ибо знак равенства
б := 0 // б — переменная, ибо присваивание
</pre>
<br />
Да и зачем вообще объявлять новую переменную? Вы же стремитесь к краткости в языке. Ясное дело, что описание типов необходимо для аргументов функции или полей структур данных, без этого не обойтись. С глобальными переменными тоже надо думать, как быть.<br />
<br />
<blockquote>в 5.4 и более новых версиях — писать break 0 вообще запретили.</blockquote>
И правильно сделали. Зачем нужны бессмысленные конструкции? Когда я написал про break 0, то это было «объяснение на пальцах». Я лишь уповал на логику, чтобы исключить путаницу. А не иллюстрировал будущие задумки.<br />
<br />
<blockquote>в чём ошибка компиляции в записи var2*2? Это же простое умножение значения переменной var2 на число 2.</blockquote>
Я имел в виду, что выражение<br />
<pre class="code_block">
var4 = нечто
</pre>
синтаксически правильно, в отличие от<br />
<pre class="code_block">
var2*2 = нечто
</pre>
Точно так же<br />
<pre class="code_block">
break 4
</pre>
не может быть заменено на<br />
<pre class="code_block">
break 2*2
</pre>
Хотя в теории, ничто не мешает <a href="http://compiler.su/makrosy-eto-chistye-funktsii-ispolnyaemye-vo-vremya-kompilyatsii.php">во время компиляции вычислить значение</a> количества покидаемых циклов, если выражение вычислимо во время компиляции.<br />
<pre class="code_block">
break cos(0) + tg(π/2)
</pre>
Но тогда придётся делать законным<br />
<pre class="code_block">
break 0
</pre>
Но это всё игры разума, можно обойтись без пижонства, одним лишь обычным числом.<br />
<hr />
2024-11-06 <i><b>alextretyak</b></i><br />
<br />
<b>ИванАс</b><br />
<blockquote>Наверное, можно заменить на product из itertools.</blockquote>
В данном случае да, можно.<br />
<!--[[[Но читаемость кода, на мой взгяд, при этом ухудшится.]]]-->Но восприятие кода при этом усложнится<!--[[[ (]]]-->, несмотря на избавление от лесенки из <pre style="display: inline"><span class="keyword">if</span> <span class="identifier">was_break</span></pre><!--[[[), т.к. itertools.product встречается в реальном коде [[[достаточно/]]]очень редко]]]-->.<br />
<br />
<b>Автор сайта</b><br />
<blockquote>Кстати, что означает такое название языка?</blockquote>
Об этом можно догадаться из описания языка на его сайте — <a href="http://11l-lang.org/ru">http://11l-lang.org/ru</a><br />
<!--[[[Чуть б]]]-->Более подробно написано об этом на странице языка в Википедии (которую, правда, уже удалили, но есть сохранённая копия — <a href="https://11l-wikipedia.github.io/ru">https://11l-wikipedia.github.io/ru</a>):<br />
<blockquote class="re">В отличие от других языков программирования, ключевые слова 11l структурированы в иерархию. На верхнем уровне этой иерархии располагается 11 базовых/корневых ключевых слов. Данная черта легла в основу названия языка программирования 11l, где «l» означает «litterae» в латинском, «logos» в греческом (в значении «слово»), либо «letters» в английском (так как корневые ключевые слова языка можно сокращать до одной буквы).</blockquote>
<br />
<blockquote>Не очень понимаю, зачем оператору break нужен loop.</blockquote>
<!--[[[Таким образом,]]]-->Поэтому, исходя из названия языка, я не могу добавить в 11l ключевое слово <b>break</b>, т.к. в <!--[[[таком/]]]-->этом случае корневых ключевых слов станет больше, чем 11.<br />
<br />
<blockquote>Даже case ... убираете из конструкции switch</blockquote>
С <b>case</b> аналогично — добавить это ключевое слово в 11l невозможно <span class="sq"><span class="sq_brackets">[</span>не изменив название языка на 12l :)(:<span class="sq_brackets">]</span></span>.<br />
<br />
<blockquote>И так же ясно, что выйти можно только из цикла.</blockquote>
Не только. В 11l ещё есть <b>switch.break</b>. Впрочем, его полезность под вопросом. А вот <b>switch.fallthrough</b> может пригодиться.<br />
<br />
К тому же, даже если «только из цикла», то остаётся вопрос: «а из какого именно цикла?» И вот тут этот "<!--[[[избыточный/]]]-->расточительный" синтаксис оказывается очень к месту: <b>loop</b> обозначает текущий цикл, <b>^loop</b> обозначает вышестоящий цикл, <b>loop(version)</b> обозначает цикл с переменной цикла version и т.д. И к любому выбранному циклу можно применить любое ключевое "подслово" <!--[[[цикла]]]-->корневого слова loop, а именно <b>break</b>, <b>continue</b>, <b>index</b>, <b>first_iteration</b> и пр.<br />
<br />
<blockquote>Или инициализировать, но инициализация за скобкой будет бесполезной</blockquote>
А зачем вообще необходимо использовать вложенные скобки в вашем примере?<br />
Можете привести более законченный/практичный пример где требуется запись <b>^переменная = ...</b>? А то<!--[[[ мне вообще]]]--> не очень понятно, что вы имели в виду.<br />
<br />
<blockquote>Да и зачем вообще объявлять новую переменную?</blockquote>
Если честно, я даже не рассматривал этот вопрос всерьёз. Практически во всех компилируемых языках переменные необходимо объявлять явно, и я считал этот вопрос решённым и не требующим переосмысления. А сейчас вот даже и не знаю, что ответить, какие <!--[[[реальные/]]]-->весомые аргументы привести в пользу явного объявления.<br />
<br />
Прежде всего, мне нравится чётко видеть в коде, где объявляется/создаётся новая переменная, а где изменяется значение уже существующей.<br />
<br />
И компилятор не пропустит случаи, когда в имени переменной была допущена ошибка:<br />
<pre class="code_block">
<span class="keyword">fn</span> <span class="identifier">calc_result</span>()
   <span class="keyword">var</span> <span class="identifier">result</span> = <span class="numeric-literal">0</span>
   <span class="keyword">if</span> ...
      <span class="identifier">rezult</span> = <span class="numeric-literal">1</span> <span class="comment">// ошибка компиляции, а не создание новой переменной с именем rezult</span>
   ...
</pre>
<br />
<!--[[[Чтобы можно было]]]-->Также явное объявление позволяет создать новую переменную с уже использующимся именем во внутренней области видимости:<br />
<pre class="code_block">
<span class="keyword">fn</span> <span class="identifier">calc_result</span>()
   <span class="keyword">var</span> <span class="identifier">r</span> = <span class="numeric-literal">0</span>
   ...
   <span class="keyword">if</span> ...
      <span class="keyword">var</span> <span class="identifier">r</span> = <span class="numeric-literal">1</span> <span class="comment">// без `var` будет использоваться внешняя `r`</span>
      <span class="identifier">print</span>(<span class="identifier">r</span>)  <span class="comment">// выводим значение внутренней `r`</span>
   ...
   <span class="keyword">return</span> <span class="identifier">r</span> <span class="comment">// возвращаем значение `r`, объявленной в начале функции</span>
</pre><!--[[[
А также для единообразия области видимости переменных циклов:
#(11l)‘
loop(i)
   ...
   loop(i)
      ...
   ...
’]]]-->
Или позволяет запретить создание таких переменных (т.н. variable shadowing). <span class="sq"><span class="sq_brackets">[</span>Причём этот запрет лучше вынести из спецификации языка на уровень опций компилятора, чтобы решение принимал руководитель проекта (решение о том, позволять variable shadowing или запрещать в коде проекта).<!--[[[
Идея навеяна сообщением от lair:
>[https://habr.com/ru/articles/350694/comments/#comment_10701298]:‘потому что variable shadowing — это зло.’
]]]--><span class="sq_brackets">]</span></span><br />
<br />
<blockquote>Ясное дело, что описание типов необходимо для аргументов функции</blockquote>
Тип аргументов функции даже в компилируемом языке указывать необязательно.<br />
<br />
Так, в C++20 появилась возможность использовать auto вместо типа аргумента функции — в этом случае тип аргумента «определится» в месте вызова функции.<br />
А в 11l такое поведение получается в случае, когда тип аргумента вообще не указан (а только его имя<!--[[[ аргумента]]]-->).<br />
<br />
Хотя для перегрузки функции с одинаковым количеством аргументов указать тип хотя бы некоторых из них, конечно, придётся явно.<br />
<br />
<blockquote>Когда я написал про break 0, то это было «объяснение на пальцах». Я лишь уповал на логику, чтобы исключить путаницу.</blockquote>
Тогда соглашусь. Логика в этом есть.<br />
Правда такую запись — <b>break &lt;число></b> — в других языках (кроме PHP) я не встречал.<br />
<hr />
2024-11-09 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Данная черта легла в основу названия языка программирования 11l, где «l» означает «litterae» в латинском</blockquote>
Мне кажется, маркетологи убили бы Вас за такое название. 🤣<br />
<br />
<blockquote>я не могу добавить в 11l ключевое слово break, т.к. в этом случае корневых ключевых слов станет больше, чем 11... добавить это ключевое слово в 11l невозможно, не изменив название языка на 12l</blockquote>
Вы сами придумали себе трудности, а потом героически их преодолеваете. Была когда-то такая забава — турнир поэтов. Поэты сперва придумывали какие-нибудь произвольные ограничения, например окончание строк на какие-то строго определённые слова. А потом укладывали свои стихи в такое прокрустово ложе. Вот и Вам, видимо, придётся строить модель парусника внутри стеклянной бутылки. Но Вы автор, Вы творец и Вам виднее.<br />
<br />
<blockquote>Можете привести более законченный/практичный пример где требуется запись ^переменная = ...?</blockquote>
<pre class="code_block">
(^i = 0 цикл i &lt; N; ++ i // i объявлена внутри скобок
   . . .)
j = i                    // но видна за скобками
</pre>
<br />
<blockquote>Практически во всех компилируемых языках переменные необходимо объявлять явно, и я считал этот вопрос решённым и не требующим переосмысления. А сейчас вот даже и не знаю, что ответить, какие весомые аргументы привести в пользу явного объявления.</blockquote>
Вывод типов, то есть инициализация как значения, так и типа, исключает такой класс ошибок, как использование неинициализированных переменных. Вывод типов создаёт иллюзию, что объявлять переменные не надо. Но это только иллюзия, которая придаёт сходство с языками с динамической типизацией.<br />
<br />
<blockquote>мне нравится чётко видеть в коде, где объявляется/создаётся новая переменная, а где изменяется значение уже существующей.</blockquote>
Есть возможность почувствовать вкус иного стиля, попрактиковавшись на языках типа PHP или Basic. Тогда идею вывода типов легче принять. В языках с динамической типизацией тип переменной может меняться по ходу вычислений, а при выводе типов тип переменной задаётся один раз, при инициализации.<br />
<br />
<blockquote>явное объявление позволяет создать новую переменную с уже использующимся именем во внутренней области видимости</blockquote>
Мне кажется, уникальность имён позволяет не париться на эту тему. А если приспичило, то можно неуникальные имена сопровождать именем области видимости. Но, думается, лучше не дублировать имена.<br />
<br />
<blockquote>Хотя для перегрузки функции с одинаковым количеством аргументов указать тип хотя бы некоторых из них, конечно, придётся явно.</blockquote>
И тут склоняюсь к <a href="http://compiler.su/unikalnost-imyon-funktsij.php">уникальности имён</a>. Хотя полиморфизм времени компиляции даёт некоторую волю, не так уж и сильно ограничивает такая уникальность.<br />
<br />
<blockquote>Правда такую запись — break &lt;число> — в других языках (кроме PHP) я не встречал.</blockquote>
Я уже рассказывал историю своих взаимоотношений с break и continue. Когда-то придумал, что эти ключевые слова надо сделать с числовым параметром. Потом познакомился с PHP и увидел, что break в нём может иметь параметр, а вот continue нет. Потом написал и опубликовал эту идею в статье, которую мы сейчас комментируем. Потом появился язык Jancy, в котором и break, и continue имеют параметр. А автор языка Jancy просит меня включить свой язык в <a href="http://compiler.su/entuziasty-razrabotchiki-kompilyatorov-i-ikh-proekty.php">этот список</a>.<br />
<hr />
2024-11-13 <i><b>Неслучайный читатель</b></i><br />
<br />
Если не нравится <b>break 2</b>, можно заменить на <b>break break</b><br />
<pre class="code_block">
цикл
    цикл
        если условие
            break break //выход из обоих циклов
</pre>
То есть <b>break N</b> меняется на N штук <b>break</b>. Как в языках народов Полинезии: если существительное употребляется несколько раз, то столько штук и имелось в виду.<br />
<br />
С <b>continue N</b> интереснее. Ведь чтобы перейти к продолжению цикла уровня N, надо сперва выйти из N-1 циклов. То есть <b>continue N</b> по факту означает <b>break ... break continue</b>: где <b>break</b> повторяется N-1 раз.<br />
<hr />
2024-11-13 <i><b>Борис К.</b></i><br />
<br />
<b>Ада</b><br />
<pre class="code_block">
цикл1:loop
    ...
    цикл2:loop
        ...
        exit цикл1;
        exit цикл2;
        ...
    end loop цикл2;
    ...
end loop цикл1;
</pre>
<hr />
2024-11-13 <i><b>Неслучайный читатель</b></i><br />
<br />
Длинновато с метками.<br />
<hr />
2024-11-14 <i><b>alextretyak</b></i><br />
<br />
<b>Автор сайта</b><br />
<blockquote>Вы сами придумали себе трудности, а потом героически их преодолеваете.</blockquote>
<!--[[[Честно говоря, не думал, что можно посмотреть на эту фичу 11l с такой точки зрения.]]]-->А ведь и правда, можно посмотреть на это и с такой точки зрения. Как-то не думал об этом.<br />
Но всё-таки, синтаксис и возможности языка 11l <!--[[[составлялись/]]]-->определялись не исходя из его названия (к которому я пришёл далеко не сразу), а наоборот — когда я понял/пришёл к окончательному решению, что корневых ключевых слов достаточно одиннадцати<!--[[[ (и даже решил отказаться от [[[вспомогательного]]] слова *‘extra’ для подслов вне категорий)]]]-->, то решил оставить такое название с целью предотвратить <!--[[[его]]]--> <!--[[[дальнейшее]]]-->ненужное раздувание языка.<br />
<br />
<blockquote>Есть возможность почувствовать вкус иного стиля, попрактиковавшись на языках типа PHP или Basic.</blockquote>
Я уже давно напрактиковался в таких языках. Даже свой движок форума написал на PHP и JavaScript.<br />
И если PHP со своими вездесущими «долларами» <span class="sq"><span class="sq_brackets">[</span>перед именем каждой переменной<span class="sq_brackets">]</span></span> и "аляповатой" и перегруженной стандартной библиотекой мне никогда не нравился, то JavaScript-ом я поначалу прямо таки восхищался. После C++ (причём версии C++03) с его излишней многословностью, JS ощущался как глоток свежего воздуха. Но восхищение со временем и опытом профессионального программирования <span class="sq"><span class="sq_brackets">[</span>правда не на JS, а на Lua и C++<span class="sq_brackets">]</span></span> прошло. И пришло понимание, что строгая типизация всё-таки лучше (а строгая статическая — ещё лучше).<br />
<!--[[[А отсутствием необходимости явного объявления/создания переменных я порядочно «наелся» в Python.]]]-->Но по опыту программирования на Python я, откровенно говоря, могу признать, что отсутствие необходимости явного объявления/создания переменных — штука весьма удобная.<br />
<!--[[[Более того]]]-->И вместе с тем, наверное самое большое, что меня в <!--[[[нём/]]]-->Python раздражает, это смежная/похожая его фича — <!--[[[отсутствие вложенных областей]]]-->единая область видимости для всех локальных переменных в функции, независимо от того, на каком уровне они создаются.<br />
К примеру, <!--[[[попробуйте догадаться]]]-->догадываетесь, почему в <a href="https://sourceforge.net/p/pqmarkup/code/ci/0aafa73f124996c2be99483a4479cd79e1a43d02/tree/pqmarkup.py#l624">этой строке кода</a> <!--[[[используется/]]]-->написано <b>for ii in ...</b>, а не просто <b>for i in ...</b>?<br />
Да потому, что <b>i</b> уже используется в этой функции в качестве индекса текущего разбираемого символа входной строки. Но сначала то я в этом месте написал просто <b>i</b>, в результате чего получилось, что выполнение данного кода приводило к «порче» переменной <b>i</b>, "объявленной" <!--[[[ранее]]]-->выше и использующейся в последующем коде. <!--[[[А в другом проекте (не могу точно вспомнить/найти где) я .]]]-->И я до сих пор <!--[[[порой/]]]-->иногда забываю про эту "особенность" Python и наступаю на эти грабли (т.е. забываю про то, что добавление невинного цикла <b>for i</b> глубоко внутри функции портит значение <b>i</b>, использующейся в окружающем коде).<!--[[[ Как же это бесит.]]]--><br />
<br />
<blockquote>Тогда идею вывода типов легче принять.</blockquote>
Вывод типов в 11l есть. Также как и в новых версиях практически всех популярных компилируемых языков программирования. Вывод типа переменной при её инициализации — это фактически уже стандарт<!--[[[ для всех компилируемых языков программирования]]]-->, им никого не удивишь <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">и многие им даже злоупотребляют — у нас на работе был программист, который настолько любил писать всюду <b>auto</b>, появившийся в C++11 в новом качестве, что вместо <b>int i = 0;</b> он писал <b>auto i = 0;</b></span><span class="cu_brackets_b">}</span></span>. <!--[[[Не вижу смысла обсуждать его полезность.]]]-->Но обсуждаем то мы другое, а именно «необходимость явного обозначения для объявления/создания новой переменной».<br />
<br />
<blockquote>В языках с динамической типизацией тип переменной может меняться по ходу вычислений, а при выводе типов тип переменной задаётся один раз, при инициализации.</blockquote>
Дело не в «динамичности» типизации. В статически типизированном Rust тип переменной тоже может меняться. Эта фича называется “rebinding”. Фактически, Rust позволяет переобъявлять переменную с <!--[[[новым]]]-->другим типом, скрывая переменную с таким же именем, объявленную ранее. <a href="https://users.rust-lang.org/t/rebinding-variables-with-let/12959">Вот здесь</a> есть пример кода.<br />
Но аналогичного эффекта можно добиться и в C++ <!--[[[с ]]]-->использованием фигурных скобок:<br />
<pre class="code_block">
{auto x = 1;
...
}{auto x = "Hello World!";
...
}
</pre><!--[[[
>[https://users.rust-lang.org/t/rebinding-variables-with-let/12959 <- google:‘rust var rebind’]:‘
int x = 1;
{
char *x = "hi";
}’
]]]-->
Единственное, что дополнительно позволяет делать Rust (и что не получится повторить в C++) — это использовать при инициализации новой переменной значение старой/скрываемой переменной с таким же именем:<br />
<pre class="code_block">
let s = "123";
...
let s = s.len(); // `s` здесь "меняет" тип на число
// (теперь в `s` содержится длина строки `s`)
</pre><!--[[[Пример навеян [https://www.reddit.com/r/rust/comments/1fx4pse/is_this_an_example_of_shadowing_or_rebinding_in/ <- google:‘rust var rebind’]]]]-->
Заметьте, что раз ваш язык не предполагает явное обозначение объявления новой переменной, то в вашем языке такой трюк как в Rust повторить не получится.<br />
<br />
<blockquote><pre class="code_block">
(^i = 0 цикл i &lt; N; ++ i // i объявлена внутри скобок
   . . .)
j = i                    // но видна за скобками
</pre></blockquote>
Так ведь тут можно, как я уже писал выше «создать переменную чуть раньше за скобкой»:<br />
<pre class="code_block">
i = 0
(цикл i &lt; N; ++ i
   . . .)
j = i
</pre>
Или можно даже так:<br />
<pre class="code_block">
i = 0; (цикл i &lt; N; ++ i
   . . .)
j = i
</pre>
В последнем случае количество строк кода будет такое же.<br />
И даже количество символов такое же.<br />
И даже специальный синтаксис с префиксным «^» не нужен.<br />
И даже читаемость/понятность кода лучше.<br />
<hr />
2024-11-18 <i><b>veector</b></i><br />
<br />
С точки зрения пользователя языков, выражу свое скромное мнение. Мне было бы удобно, что бы циклу можно было присвоить имя, если нужно, чтобы оперировать не с тем циклом, в контексте которого выполняются команды, а с тем циклом, с которым нужно и когда это нужно. Проиллюстрирую идею. Вместо меток:<br />
<pre class="code_block">
while (true) 
{
    switch (instr[i]) 
    {
        case '[':
            nesting_level++;
            break;
       
        case ']':
            if (--nesting_level == 0)
                goto break_;
            break;
    };
    i++;
};
break_:
</pre>
Было бы удобно, например так:<br />
<pre class="code_block">
while.levels (true) 
{
    switch (instr[i]) 
    {
        case '[':
            nesting_level++;
            break;
            
        case ']':
            if (--nesting_level == 0)
                break(while.levels); // Выход из блока кода конкретного while.
            break; // Выход из блока кода текущего контекста case.
    };
    i++;
};
</pre>
Чуть выше есть пример на языке Ада, где идея выхода из цикла на мой взгляд более корректная, чем метки. Метки и goto, явно пришедшие из ассемблера, очень не удобны для сопровождения активно изменяющегося прикладного кода. В системном же коде, без меток и goto обойтись нельзя.<br />
<hr />
2024-11-18 <i><b>Автор сайта</b></i><br />
<br />
<b>alextretyak</b><br />
<blockquote><blockquote>Вы сами придумали себе трудности, а потом героически их преодолеваете.</blockquote>
... можно посмотреть на это и с такой точки зрения. Как-то не думал об этом. ... синтаксис и возможности языка 11l определялись не исходя из его названия..., а наоборот — когда я понял/пришёл к окончательному решению, что корневых ключевых слов достаточно одиннадцати, то решил оставить такое название с целью предотвратить ненужное раздувание языка.</blockquote>
Но этим самым Вы сжигаете за собой мосты — после этого Вы не сможете добавлять в язык новые возможности которые могут потребовать новые ключевые слова. Либо надо признать, что Ваш язык настолько совершенен, что в улучшениях не нуждается. Но тогда надо признать, что Вы большой оптимист. 🤣 Или дальше не собираетесь над ним работать. Типа «я покорил этот Эверест, а дальше мне неинтересно».<br />
<br />
<blockquote>отсутствие необходимости явного объявления/создания переменных — штука весьма удобная.</blockquote>
Ну вот, мне даже убеждать Вас ни в чём не надо.<br />
<br />
<blockquote>самое большое, что меня в Python раздражает, это ... — единая область видимости для всех локальных переменных в функции, независимо от того, на каком уровне они создаются. ... написал просто i, в результате чего получилось, что выполнение данного кода приводило к «порче» переменной i, "объявленной" выше</blockquote>
Но, может, это и хорошо? Уникальность имён внутри функций предотвратит путаницу с одноимёнными переменными. Да и при точном следовании рекомендациям по стилю программирования следует писать короткие, лаконичные функции. А в них и переменных мало. Тогда ситуации, когда «Боливар не снесёт двоих», будет легко избежать.<br />
<br />
<blockquote><pre class="code_block">
let s = s.len(); // `s` здесь "меняет" тип на число
</pre>
<span class="sq"><span class="sq_brackets">[</span>если<span class="sq_brackets">]</span></span> ваш язык не предполагает явное обозначение объявления новой переменной, то ... такой трюк ... повторить не получится.</blockquote>
А надо ли его повторять? Мне вспоминается старая байка, как программисты спорили, какой язык лучше — Алгол или Фортран. Один из них говорит: «Зато в этом языке есть многомерные массивы!» Второй отвечает: «Покажи мне хоть одну свою программу, где бы были многомерные массивы». И крыть было не чем.<br />
<br />
Создать одноимённую переменную с новым типом можно было бы примерно так:<br />
<pre class="code_block">
имя = скрыть старую переменную и создать новую (значение)
</pre>
где <b>имя</b> слева — новая ячейка в памяти нового типа, который определяется исходя из параметра <b>значение</b>. То есть здесь имеет место быть вывод типа. При этом функция «скрыть старую переменную и создать новую» — полиморфна, и это полиморфизм времени компиляции. В принципе в этом можно увидеть тот же «let», только вид сбоку, но формально объявления не было.<br />
<br />
<blockquote><pre class="code_block">
i = 0; (цикл i &lt; N; ++ i
   . . .)
j = i
</pre></blockquote>
Согласен, что тут от выноса инициализации i за скобки мы ничего не теряем, и это обычно будет справедливо и в других случаях. А над обратными примерами подумаю и напишу позже.<br />
<br />
<b>veector</b><br />
<blockquote>Было бы удобно</blockquote>
Да, « удобно» — это очень индивидуально. Это как размер одежды: кому-то удобно носить 50 размер одежды, а кому-то нет. Мне было бы удобно вот так:<br />
<pre class="code_block">
(цикл истина; ++i
когда instr[i]
    = '['
        ++ nesting_level
    = ']'
        -- nesting_level
            если nesting_level = 0
                выйти)
</pre>
<br />
<blockquote>В системном же коде, без меток и goto обойтись нельзя.</blockquote>
Если системный код пишется на ассемблере, то конечно. Если на других языках, то среди них найдутся такие, что <a href="http://compiler.su/nekoshernyj-goto.php">отсутствие goto</a> и меток не принесёт неудобств.<br />
<br />
В Си и его потомках с <b>break</b> действительно неудобно получилось: и в циклах, и в переключателе один и тот же <b>break</b>. А к чему он относится — к циклу или переключателю — догадайся сам. Но в Си уже ничего не изменить — по причине обратной совместимости. А создаваемые языки могут избежать двусмысленности.<br />
<hr />
2024-11-19 <i><b>veector</b></i><br />
<br />
Под "удобно" я имел в виду не "нравится — не нравится", не рюшечки, а удобство сопровождения активно изменяеющегося кода с целью минимизации ошибок в ходе изменения.<br />
<br />
"в Си уже ничего не изменить" — это огромное заблуждение. Вы просто привыкли к Майкрософтовскому Си и GNU gcc Си, которые имеют множество расширений, которые ещё и не полностью совместимы между собой. А я из мира embedded и кроме этих двух есть ещё другие компиляторы со своими расширениями, не похожими ни на что другое. Естественно, классический "Hello world" или "мигание светодиодом" ими всеми компилируются без проблем. Но когда начинаются действительно серьезные вещи, системные, тогда без расширений ни одна задача не решается.<br />
<br />
Если уж придираться к предложенному мной Си примеру, который иллюстрировал идею, то там синтаксис более-менее обратно совместим, а если нет, то можно рихтануть. Но я не заводил речь о расширении, а иллюстрировал идею.<br />
<br />
break в Си с числовым аргументом опасен когда идет изменение кода, например, когда меняют набор операторов if() на switch() и case или наоборот, забывая увеличивать или уменьшать уровень контекста из которого нужно выходить — вот что создает неудобства.<br />
<br />
PS. Про синтаксисы я вообще молчал, но, раз заговорили, то лично я скромно считаю синтаксис Си идеальным, мое мнение окончательно и изменению не подлежит.<br />
<hr />
2024-11-22 <i><b>alextretyak</b></i> <a name="2024-11-22"></a><br />
<br />
<blockquote><pre style="display: inline">break; // Выход из блока кода текущего контекста case.</pre></blockquote>
Вот уж не думал, что найдётся человек, который будет защищать <!--[[[необходимость ]]]-->break в <b>case</b>-ах switch-а в Си. Это же <!--[[[просто «эпичный фейл»]]]-->явно неудачное решение с точки зрения дизайна синтаксиса языка программирования.<!--[[[ Причём настолько эпичный, что разработчики GCC добавили предупреждение
]]]--><br />
И его неудачность признают разработчики большинства современных ЯП, где никакого break в switch-ах (или его аналогах) <!--[[[просто]]]--> нет.<br />
<!--[[[В том же]]]-->Даже в C#, несмотря на <!--[[[основанность на]]]-->его максимальную близость к Си (ну, после C++ и Objective-C), неявное "проваливание" в <b>case</b>-ах запретили (кроме пустых <b>case</b>). <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">"Проваливание" в C# (а также в D) необходимо обозначать в коде явно с помощью <b>goto case</b>. В языках Go и Swift для "проваливания" используется специальное ключевое слово <b>fallthrough</b>.</span><span class="cu_brackets_b">}</span></span><br />
Собственно, только для пустых <b>case</b> оно <span class="sq"><span class="sq_brackets">[</span>неявное "проваливание"<span class="sq_brackets">]</span></span> и используется в реальном коде. Но им есть гораздо более удачная альтернатива.<br />
Так, вместо<br />
<pre class="code_block">
switch (ch) {
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
    &lt;...>
}
</pre>
в Pascal-е можно писать так:<br />
<pre class="code_block">
case ch of
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9': &lt;...>
end;
</pre>
или даже так:<br />
<pre class="code_block">
case ch of
    '0'..'9': &lt;...>
end;
</pre>
<br />
А <!--[[[даже ]]]-->разработчики языков, скопировавши<!--[[[х]]]-->е по глупости поведение Си, осознали эту ошибку, и рекомендуют всегда вставлять комментарий, который говорит «да, здесь не забыли поставить break, а так и задумано».<br />
Вот цитата из <a href="https://www.oracle.com/technetwork/java/codeconventions-150003.pdf" title="<- google:‘java code guide’">“Java Code Conventions”</a><!--[[[ от]]]-->, написанного в 1997(!) год<!--[[[а]]]-->у:<br />
<blockquote>Every time a case falls through (doesn't include a break statement), add a comment where the break statement would normally be.</blockquote>
<hr />
2024-11-22 <i><b>veector</b></i><br />
<br />
<blockquote>Вот уж не думал, что найдётся человек, который будет защищать break в case-ах switch-а в Си.</blockquote>
А я и не защищаю, а наоборот, написал в чем проблема с точки зрения сопровождения изменяющегося кода.<br />
<hr />
2024-11-23 <i><b>alextretyak</b></i><br />
<br />
<blockquote>А я и не защищаю</blockquote>
Как это так, ведь вы же сами написали: «лично я скромно считаю синтаксис Си идеальным».<br />
И раз вы не уточняли («считаю синтаксис Си <i>(кроме break в switch)</i> идеальным»), то по умолчанию подразумевается, что вы считаете <b>весь</b> синтаксис Си идеальным.<br />
<!--[[[Т.е.]]]-->Или что вы хотели тогда сказать, что «синтаксис Си — идеальный, но... в нём есть изъяны, вроде break в switch». Так получается?<br />
<br />
Отношение к break в switch в языке программирования может быть только одно из двух — <!--[[[вы ]]]-->либо "за", либо "против". Тут на двух стульях усидеть никак не получится. Так вы "за"? Или "против"?<br />
Если "за", то см<!--[[[отри]]]-->. моё предыдущее сообщение, где я <!--[[[подробно расписал, чем такое решение плохо]]]-->убедительно показал, что такое решение признано плохим <!--[[[большинством разработчиков ЯП]]]-->многими разработчиками ЯП.<br />
А если вы "против", то возникает противоречие с вашим же утверждением про идеальность синтаксиса Си.<br />
<br />
<blockquote>наоборот, написал в чем проблема с точки зрения сопровождения изменяющегося кода.</blockquote>
Если бы в Си не было break в switch, тогда вместо <b>break(while.levels)</b> достаточно было написать просто <b>break</b>, и проблемы <!--[[[бы этой вообще]]]-->«с точки зрения сопровождения изменяющегося кода» в данном случае не было бы.<br />
Так как (цитирую):<br />
<blockquote>когда меняют набор операторов if() на switch() и case</blockquote>
никакое поведение уже имеющихся break никак бы не изменилось, т.к. break-и использ<!--[[[уются]]]-->овались бы только для выхода из циклов.<br />
<hr />
2024-11-23 <i><b>Клихальт</b></i><br />
<br />
А может вместо потворствования юношескому максимализму к двум Вашим вариантам ответа "только за" и "только против" стоит добавить третий: "понять для чего именно это было сделано" и применять оное сообразно? 😉 Ведь конструкция switch, не требующая break, менее гибка и не позволяет совмещать код из разных вариантов выбора без раздувания кода. Кроме того, внутри циклов вместо break возможно использование continue, что позволяет оптимизировать переходы. Понятно, что всё это может за вас сделать и оптимизатор компилятора, но мне, например, по кайфу не полагаться на того парня, а делать самому то, что считаю сделать нужным.<br />
<hr />
2024-11-25 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b><br />
Синтаксис всего языка Си — лично я считаю идеальным. И в то же время, лично я считаю, что логику с break и continue можно было сделать лучше, причем в рамках текущего синтаксиса язык Си.<br />
<br />
Данный сайт посвящен разрабатываемому языку и тут ребята хотят повторить тот же логический изъян (не синтаксический изъян), что и в Си с break и continue. Поэтому, решил высказать, чем же ещё плох логический подход с числовой константой для break, кроме того, что рассмотрено в исходной статье.<br />
<br />
<blockquote>Если бы в Си не было break в switch, тогда вместо break(while.levels) достаточно было написать просто break ...</blockquote>
Всё-таки недостаточно, потому что, например, если есть два и более вложенных циклов, иногда надо выйти из всех циклов, разом. И мне, как пользователю языка и программисту, было бы удобнее указывать из какого именно цикла мне надо выйти, не высчитывая уровень вложенности, который может меняться в ходе сопровождения программы при сокращении или увеличении уровней вложенности. Да, это редкие события, поэтому, очень редко доставляют проблем, но, всё-таки доставляют. Причем так, что достаточно одного раза, чтобы запомнить на всю жизнь.<br />
<br />
<b>Клихальт</b><br />
Вот, я тоже разделяю вот эту вашу точку зрения "конструкция switch, не требующая break, менее гибка". Хотя, там, где можно обойтись без такой возможности языка, предпочитаю не делать case без break, но, иногда, да, приходится. Так-то язык Си в switch позволяет делать даже такое, от чего даже мне становится как-то не по себе: <a href="https://en.wikipedia.org/wiki/Duff's_device">https://en.wikipedia.org/wiki/Duff's_device</a>. Кстати, Клихальт, какой язык программирования вам нравится?<br />
<hr />
2024-11-27 <i><b>alextretyak</b></i><br />
<br />
<b>Клихальт</b><br />
<blockquote>А может вместо потворствования юношескому максимализму ...</blockquote>
Бывают случаи, когда максимализм уместен. И данный случай — один из таких.<br />
К тому же, позиция «синтаксис языка Х — идеален» — это ещё больший максимализм. Тем более, когда Х это Си.<br />
<br />
<blockquote>Ведь конструкция switch, не требующая break, менее гибка и не позволяет совмещать код из разных вариантов выбора без раздувания кода.</blockquote>
Нет. Выразительные возможности в обоих случаях абсолютно одинаковы. Вопрос только в принятых умолчаниях. В случае Си отсутствие break обозначает "проваливание", но практика программирования показала, что это неудачное решение, т.к. "проваливание" требуется гораздо реже, чем break. Поэтому в современных ЯП break в switch убрали, т.к. поведение "break" осуществляется по умолчанию. Но поведение "проваливания" по-прежнему доступно, только его необходимо обозначать в коде явно — чаще всего для этого используется ключевое слово <b>fallthrough</b> (<!--[[[о чём я уже говорил]]]-->которое я уже упоминал чуть раньше).<br />
Так вот, мне очевидно, что умолчание, принятое в Си — явно неудачно, и <!--[[[мне]]]--> было бы любопытно увидеть хоть какой-то разумный аргумент в защиту этого умолчания.<br />
А так как вариантов тут всего <!--[[[2]/]]-->два — по умолчанию либо "break" (при этом ключевое слово break в switch становится ненужным), либо "проваливание" (при этом ненужным становится ключевое слово fallthrough) — оттого и получается такой <!--[[[вот ]]]-->максимализм в отношении к break в switch в языке программирования.<br />
<br />
<b>veector</b><br />
<blockquote>Синтаксис всего языка Си — лично я считаю идеальным.</blockquote>
Ладно. С вами всё понятно. Для вас «идеальность синтаксиса языка» определяется персональными ощущениями при программировании на <!--[[[нём/]]]-->этом языке, а не стремящ<!--[[[е/]]]-->имся к объективности рациональным обоснованием.<!--[[[ И добиться от вас [[[аргументированного ответа]]]конкретных аргументов[[[ в защиту даже явно неудачных элементов синтаксиса Си]]], похоже, не получится.]]]--><br />
<hr />
2024-11-27 <i><b>Gudleifr</b></i><br />
<br />
<blockquote>стремящимся к объективности рациональным обоснованием</blockquote>
И в чем оно заключается?<br />
<hr />
2024-11-29 <i><b>alextretyak</b></i><br />
<br />
<blockquote>И в чем оно заключается?</blockquote>
В стремлении к объективности. :)(:<br />
К примеру, моё утверждение «"проваливание" требуется гораздо реже, чем break» вообще говоря субъективно, и основано только на моём личном опыте программирования.<br />
Чтобы сделать более объективное утверждение, <!--[[[Например, берём]]]-->можно взять какой-нибудь достаточно популярный проект с открытым исходным кодом<!--[[[ на Си и анализируем]]]--> и проанализировать его исходники для сбора статистики, показывающей насколько именно редко <!--[[[используется/]]]-->требуется "проваливание" в switch.<br />
<br />
<!--[[[Возьмём, к примеру, исходный код ядра Linux. ]]]-->В качестве такого проекта можно взять ядро Linux. Я проанализировал <a href="https://www.kernel.org/pub/linux/kernel/v1.0/linux-1.0.tar.gz" title="<- https://www.kernel.org/pub/linux/kernel/ <- google:‘old linux kernel source’">исходный код версии 1.0</a>, которая вышла аж в 1994 году, но язык Си с тех пор не сильно изменился, да и программисты писать<!--[[[ лучше]]]--> код на Си лучше не стали. И объёма кода этой версии — 100 тыс. строк — вполне достаточно для <!--[[[грубой]]]-->ориентировочной оценки. (Для справки: последняя версия ядра 6.12 содержит в 300(!) раз больше кода — 1.5Гб (против 5Мб в версии 1.0) и свыше 30 млн. строк.)<br />
<br />
Для анализа я использовал модуль pycparser на Python. Т.к. работает он довольно медленно, а код ядра Linux состоит из большого количества .c файлов и каждый .c файл включает довольно много заголовочных файлов, то я решил объединить их в один .c файл для ускорения разбора всего исходного кода. При этом, правда, пришлось исходники немного "обработать напильником", т.к. в .c файлах встречались объявления макросов с короткими именами (например, <pre style="display: inline">#define pos (vc_cons[currcons].vc_pos)</pre>), которые необходимо undefine'ить (с помощью <pre style="display: inline">#undef pos</pre>) в конце файла, а то иначе они ломают последующий код.<br />
<br />
В результате получились такие цифры.<br />
Всего конструкций switch в коде ядра: <b>215</b> (чуть меньше, чем общее количество .c файлов, т.е. на один .c файл приходится примерно один switch).<br />
Конструкций switch, в которых есть не пустой и не последний case, который не оканчивается на break, на continue, на return или на goto: <b>26</b>. Из них ложных срабатываний: <b>10</b>. О причинах ложных срабатываний можно почитать в <a href="https://github.com/alextretyak/break_in_switch/blob/master/report.txt">моём отчёте</a>, для составления которого я проанализировал <i>каждый</i> случай обнаруженного анализатором потенциального "проваливания" в switch — при запуске скрипт-анализатор выдаёт их в формате имя_исходного_файла:номер_строки:позиция_в_строке, всего таких случаев получилось 32 (хотя прокомментировать каждый случай я поленился<!--[[[,]]]--> — комментарии есть только у ложных срабатываний). Там же в репозитории мой скрипт-анализатор в файле break_in_switch.py и Release с <a href="https://github.com/alextretyak/break_in_switch/releases/download/1/break_in_switch.zip">архивом с "обработанным" кодом ядра</a>.<br />
Таким образом, итого получается, что в коде ядра Linux 1.0 "проваливание" используется <span class="sq"><span class="sq_brackets">[</span>с учётом ложных срабатываний<span class="sq_brackets">]</span></span> только в <b><!--[[[16]954cf2957203c0f8f5993568a99765319c46969b]]-->17</b> switch'ах из 215, т.е. в <b><!--[[[7]]]-->8%</b> switch'ей.<br />
<hr />
2024-11-29 <i><b>Gudleifr</b></i><br />
<br />
<blockquote>В качестве такого проекта можно взять ядро Linux. Я проанализировал исходный код версии 1.0, которая вышла аж в 1994 году, но язык Си с тех пор не сильно изменился, да и программисты писать код на Си лучше не стали</blockquote>
Наоборот, к 94-му Си уже безвозвратно устарел.<br />
<br />
Да и сама идея того, что один большой проект статистически заменит много мелких, не безупречна. Большая субъективность не означает объективности.<br />
<hr />
2024-11-29 <i><b>Автор сайта</b></i><br />
<br />
<b>Alextretyak</b>, браво! Завидую Вашей дотошности и целеустремлённости! Надо же, не поленились собрать статистику, проверили алгеброй гармонию. А я бы, наверное, решил для себя, что «тут и так всё ясно, ну что тут думать?».<br />
<br />
Думаю, для проваливания вниз было бы уместно использовать ключевое слово <b>then</b> вместо <b>fallthrough</b>. Вот тут оно было бы к месту. В отличие от <b>then</b> в Паскале после <b>if условие</b>. Там оно так себе, «не пришей к звезде манжет».<br />
<hr />
2024-11-29 <i><b>Клихальт</b></i><br />
<br />
<b>Alextretyak</b>, попробуйте проанализировать тексты из эпохи, когда ещё не принято было писать так, как написано ядро Linux, которое Вы проанализировали. Вот тексты первого компилятора Си, написанного на Си.<br />
<a href="https://github.com/mortdeus/legacy-cc">https://github.com/mortdeus/legacy-cc</a><br />
Точную статистику я по ним не собирал, как то сделали Вы, но после того как пробежался по ним глазами, увидел, что там картина несколько отлична от той, что описали Вы.<br />
<hr />
2024-11-29 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b>, хорошо, вы сделали некоторую статистику:<br />
<blockquote>Таким образом, итого получается, что в коде ядра Linux 1.0 "проваливание" используется только в <!--[[[16]]]-->17 switch-ах из 215, т.е. в <!--[[[7]]]-->8% switch-ей.</blockquote>
И что она для вас показывает и на какие выводы вас подталкивает? Что вы хотите этой статистикой показать?<br />
<hr />
2024-11-30 <i><b>alextretyak</b></i><br />
<br />
<b>Клихальт</b><br />
<blockquote>https://github.com/mortdeus/legacy-cc<br />
... там картина несколько отлична от той, что описали Вы.</blockquote>
Да, в этом коде статистика получается другая.<br />
Всего конструкций switch: <!--[[[58]2 switch'а потерялось (оказались закомментированны [[[{]]]`/* } switch(cval) { /* goto */`[[[}]]] и убраны препроцессором), ef81ce5fe6904cd9625c8217ae68de33fcdb9ad0]]-->60 (<!--[[[по 4.5 switch'а на один .c файл, при том что каждый .c файл состоит из 400 строк кода]]]-->в пересчёте на общее количество строк кода относительное количество switch'ей в этом коде в 5 раз выше, чем в коде ядра Linux 1.0).<br />
"Проваливание" используется в 11 switch'ах, т.е. в <!--[[[19]]]-->18% switch'ей.<br />
Ложных срабатываний <span class="sq"><span class="sq_brackets">[</span>от доработанного скрипта-анализатора<span class="sq_brackets">]</span></span>, в принципе, не было. Только пара спорных моментов. Например, в <a href="https://github.com/mortdeus/legacy-cc/blob/master/prestruct/c01.c#L86-L88">этом месте</a> на мой взгляд было бы понятнее вместо <b>d1++; d2++;</b> с "проваливанием" написать <b>d1+=2; d2+=2; break;</b>.<br />
<br />
<b>veector</b><br />
<blockquote>Что вы хотите этой статистикой показать?</blockquote>
<ul>
<li>Во-первых, <!--[[[краткости кода]]]-->то, что при использовании «break по умолчанию» вместо «"проваливание" по умолчанию» в <!--[[[более чем 90%]]]-->подавляющем большинстве switch'ей (и, как следствие, в программе в целом) уменьшится количество кода<!--[[[ (особенно актуально когда кода в case'ах немного)]]]--> (конечно, минимизация объёма кода — это не самоцель, но в данном случае речь идёт об избавлении от синтаксического мусора в виде вездесущих break в почти каждом case).</li>
<li>Во-вторых, синтаксис языка программирования должен по возможности препятствовать возникновению ошибок в коде. Если в каком-то case нету break в конце (либо return или continue) — то это скорее всего ошибка, т.к. "проваливание" требуется <!--[[[очень и очень]]]--><!--[[[крайне/]]]--><!--[[[достаточно/]]]-->очень редко (согласно статистике). И язык Си своим «"проваливанием" по умолчанию» потворствует <!--[[[возникновению/]]]-->допущению таких ошибок в коде.</li>
</ul>
И есть ещё одно преимущество отсутствия break в switch никак не связанное со статистикой: конструкция switch может быть не statement'ом, а выражением и возвращать результат соответствующей ветки case. Почитайте про switch-выражения в Java: <a href="https://habr.com/ru/articles/443464/" title="<- google:‘java switch break’">https://habr.com/ru/articles/443464/</a><br />
В switch-выражениях break совсем не уместен. При этом switch-выражения вполне могут заменить традиционный switch-statement, и в новых языках программирования поддерживать switch-statement смысла нет — достаточно только switch-выражений. В том же Kotlin'е switch-statement'ов нет, а есть только switch-выражения (правда ключевое слово используется другое — <b>when</b>).<br />
<hr />
2024-11-30 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Вот тексты первого компилятора Си</blockquote>
А в чём смысл рассмотрения именно древних исходников?<br />
<br />
Взял файл первый попавшийся файл last1120c/c00.c и посчитал, как построены <b>switch</b>. В 6 конструкциях <b>switch</b> встретил такие <b>case</b>:<br />
<ul>
<li><b>проваливание</b> после <b>case</b> — 7 раз,</li>
<li>заканчивается <b>goto</b> — 23 раза,</li>
<li>заканчивается <b>exit</b> — 2 раза,</li>
<li>заканчивается <b>return</b> — 26 раз,</li>
<li>удивительно, но ни одного <b>break</b>!</li>
</ul>
Не ахти какая статистика, но проваливание используется нечасто. О чём догадывался и раньше.<br />
<br />
<blockquote>Что вы хотите этой статистикой показать?</blockquote>
Лично я увидел в статистике, что проваливание требуется редко. Поэтому логично сделать поведением по умолчанию выход из <b>switch</b>, а не проваливание. А если проваливание потребовалось, то на этот случай предусмотреть специальный оператор или ключевое слово.<br />
<hr />
2024-11-30 <i><b>Клихальт</b></i><br />
<br />
<b>Автор сайта</b>,<br />
<blockquote>А в чём смысл рассмотрения именно древних исходников?</blockquote>
Если быть честным до конца, то исходники ядра Linux 1.0 с точки зрения сегодняшнего дня это такие же древние исходники, хотя против их рассмотрения вы не имели ничего против. И они ровно также субъективны, как и любые другие исходные тексты на этом языке программирования, вне зависимости от времени их написания. Смысл же их приведения мною состоит в том, что это шаг в сторону из круга понятий и приёмов программирования, принятых одними и вбитых в головы другим. Это попытка показать, что может быть и иначе.<br />
<br />
<blockquote>Не ахти какая статистика, но проваливание используется нечасто. О чём догадывался и раньше.</blockquote>
Давайте поставим вопрос несколько иначе: насколько часто для выхода из ветки оператора выбора используется именно break? И в данном случае ответ однозначный — в рассматриваем вами участке текста ни разу, а в целом крайне редко. Не спорю, в настоящее время ситуация совершенно иная и происходит это, по моему мнению, оттого что во времена, к коим относятся тексты, приведённого мною примера, основным языком разработки был язык ассемблера, где вся оптимизация кода лежала на плечах программиста, а не языки высокого уровня и оптимизирующие компиляторы, как сейчас, где чем дальше, тем больше программист всё больше отстраняется сначала от оптимизации, а затем уже и от самого кода, что с моей точки зрения в корне неверно.<br />
<br />
<b>alextretyak</b>,<br />
<blockquote>Во-первых, то, что при использовании «break по умолчанию» вместо «"проваливание" по умолчанию» в подавляющем большинстве switch'ей (и, как следствие, в программе в целом) уменьшится количество кода (конечно, минимизация объёма кода — это не самоцель, но в данном случае речь идёт об избавлении от синтаксического мусора в виде вездесущих break в почти каждом case).</blockquote>
Под уменьшением количества кода Вы верно имели ввиду уменьшение количества исходного текста программы, а не количества кода программы? Что ж до "избавлении от синтаксического мусора в виде вездесущих break в почти каждом case" позволю отослать Вас к приведённому мною примеру исходных текстов компилятора языка Си, где break вообще практически не используется для выхода из ветки оператора выбора. Что ж до "синтаксического мусора", то break, впрочем как continue и return, при помощи которых происходит выход из ветки выбора это не "синтаксический мусор", а конкретные операторы, осуществляющие конкретные действия, которые необходимы с точки зрения программиста в конкретном месте программы, а "синтаксическим мусором" как раз и является псевдооператор "проваливания", который нужен лишь для того, чтобы дать понять думающему за тебя компилятору, что твое действие осмысленно и ничего за тебя в этом месте додумывать не надо.<br />
<hr />
2024-12-01 <i><b>alextretyak</b></i><br />
<br />
Предлагаю продолжить обсуждение <a href="./../pereklyuchatel/#2024-12-01" target="_self">тут</a>.<br />
<hr />
2024-12-09 <i><b>veector</b></i><br />
<br />
<b>@alextretyak</b><br />
<blockquote>Во-первых, то, что при использовании «break по умолчанию» вместо ...<br />
Во-вторых, синтаксис языка программирования должен ...<br />
И есть ещё одно преимущество отсутствия break в switch ...</blockquote>
<br />
Не надеюсь на понимание, но я все-таки напишу.<br />
<br />
Профессиональные программисты не так смотрят на эти вещи, как вы, <b>alextretyak</b>.<br />
Первичным для языка Си, является — <u>информационная модель адресного пространства, совпадающая с моделью как у процессора</u>.<br />
А это значит, что программист работает в своей программе, в том числе, и с адресами, и с переходами по адресам в адресном пространстве.<br />
Ключевые слова "case" и "default" являются метками в адресном пространстве для формирования условных переходов.<br />
Ключевое слово "break" является контекстным оператором безусловного перехода, т.е. как "goto", только в контексте "switch".<br />
Тоже самое относится к "break" для выхода из циклов, это просто контекстный оператор безусловного перехода.<br />
<br />
Никто и никогда, из нормальных программистов, не забывает их писать или не писать, это все выдумки "программистов", пришедших из математики (теоретиков).<br />
Быстрый набор, забота о минимуме строк кода и забывчивость — это части удел кодеров, у которых в приоритете набор текста, без необходимости понимания сути, происходящего в программе, т.к. работают по указке программиста или другого руководителя.<br />
<hr />
2024-12-09 <i><b>Неслучайный читатель</b></i><br />
<br />
У программистов и математиков есть общий предок — детсадовец необразованный. Математиком школьник становится раньше, чем программистом. Так построено образование. В чистом виде программистов не существует, у всех есть математический бэкграунд.<br />
<br />
Если поведением по умолчанию является не проваливание, а выход из <b>switch</b>, то это лишь рационализация, полезность которой выведена эмпирическим путём. Это не волшебная пилюля, полная чудес, а небольшое улучшение. Если не довлеет обратная совместимость, то почему бы и нет?<br />
<hr />
2024-12-09 <i><b>Клихальт</b></i><br />
<br />
<b>Неслучайный читатель</b>,<br />
<blockquote>В чистом виде программистов не существует, у всех есть математический бэкграунд.</blockquote>
Позвольте с вами не согласиться. Несмотря на общий образовательный "математический бэкграунд" в программирование люди приходят как сверху — со стороны математики и вычислительных задач, рассматривая само программирование как полезный, но не самый важный придаток к основному занятию, так и снизу — со стороны железа. И тут речь не о системщиках и прикладниках. Встречал на своём веку массу системщиков, принадлежащих по складу ума и кругу интересов как раз к первой когорте, а вовсе не ко второй и наоборот.<br />
<br />
<blockquote>Если поведением по умолчанию является не проваливание, а выход из switch, то это лишь рационализация, полезность которой выведена эмпирическим путём. Это не волшебная пилюля, полная чудес, а небольшое улучшение.</blockquote>
Это не "рационализация" и не "небольшое улучшение", а реверанс теоретикам и очередной шаг прочь от машины в сторону математики. Си времён K&amp;R это по сути своей высокоуровневый ассемблер, или язык среднего уровня (как его в шутку называли) с весьма ограниченной областью применения, а не высокоуровневый язык, аналог языков линии Алгола, просто с несколько видоизменённым синтаксисом, который можно использовать повсюду в режиме "каждой бочке затычка".<br />
<hr />
2024-12-10 <i><b>Неслучайный читатель</b></i><br />
<br />
Что в лоб, что по лбу — от изменения поведения по умолчанию генерируемый машинный код при решении одной и той же задачи не изменится ни на бит.<br />
<hr />
2024-12-10 <i><b>Клихальт</b></i><br />
<br />
<b>Неслучайный читатель</b>,<br />
<blockquote>Что в лоб, что по лбу — от изменения поведения по умолчанию генерируемый машинный код при решении одной и той же задачи не изменится ни на бит.</blockquote>
Генерируемый компилятором код в данном конкретном случае не изменится и это правда, на вас, как состоявшегося программиста это так же, если и окажет влияние, то минимальное, а вот для новых поколений, не имевших "тяжелого ассемблерного детства" и кодирования в условиях крайне ограниченных ресурсов, вопрос уже далеко не такой <!--[[[однозначный]]]--> однозначный, а скорее наоборот.<br />
<hr />
2024-12-10 <i><b>veector</b></i><br />
<br />
<b>@Неслучайный читатель</b><br />
<blockquote>Что в лоб, что по лбу — от изменения поведения по умолчанию генерируемый машинный код при решении одной и той же задачи не изменится ни на бит.</blockquote>
В этом случае для программиста, вдруг, в Си появятся неявные "goto".<br />
Это все-таки очень серьезное и неожиданное логическое изменение, сравнимое с изменением исходных условий.<br />
Что, в свою очередь, может повлиять на само генерируемое программистом решение. Предположу, что в операциях сравнения будут использованы обратные условия, которые и повлияют на результирующий машинный код.<br />
<br />
<b>@Клихальт</b><br />
Вам, от меня лично, огромный плюс в карму!<br />
Хочу добавить к вашим словам, что дело ещё и в достижения необходимой скорости работы и отзывчивости (скорости реакции на события).<br />
Си ещё уникален тем, что он практически не добавляет никакой отсебятины и у него почти ничего не скрыто "под капотом".<br />
<hr />
2024-12-14 <i><b>alextretyak</b></i><br />
<br />
<b>veector</b><br />
<blockquote>Профессиональные программисты не так смотрят на эти вещи</blockquote>
Здорово, что вы и все другие профессиональные программисты никогда не забывают писать break. Но в реальном мире, увы, профессиональных программистов на всех не хватает. И код на Си пишут не только лишь профессиональные программисты. И члены комитета по стандартизации Си это понимают, и (о ужас!) в стандарте C23 в конструкцию switch добавили псевдооператор "проваливания" в виде атрибута <b>[[fallthrough]]</b>:<br />
<a href="https://en.cppreference.com/w/c/language/attributes/fallthrough" title="<- google:‘fallthrough attribute c’ <- https://pvs-studio.ru/ru/docs/warnings/v796/ <- google:‘pvs studio break switch’">https://en.cppreference.com/w/c/language/attributes/fallthrough</a><br />
Как вам такая новость?<br />
<br />
Да, стандарт C23 <!--[[[предписывает лишь]]]-->подразумевает лишь выдачу предупреждения при отсутствии <!--[[[атрибута]]]--> <b>[[fallthrough]]</b> в case без <b>break</b> в конце, а точнее — подавление предупреждения посредством этого атрибута. Но во многих серьёзных проектах включена опция компиляции -‍Werror <span class="sq"><span class="sq_brackets">[</span>которая предписывает трактовать все предупреждения как ошибки<span class="sq_brackets">]</span></span> или аналогичная, так что фактически отсутствие <b>[[fallthrough]]</b> или <b>break</b> (или return/continue) в конце case означает ошибку компиляции при использовании последнего стандарта языка Си.<br />
Так что, когда вы пишите «синтаксис всего языка Си — лично я считаю идеальным», вы хотя бы уточняйте какую именно версию языка Си вы имеете в виду. :)(:<br />
<br />
Также рекомендую ознакомиться с позицией Андрея Карпова, одного из основателей и технического <a href="https://pvs-studio.ru/ru/blog/posts/0231/" title="<- google:‘андрей карпов директор pvs’ <- [google:‘андрей карпов pvs’]:‘Андрей Карпов — один из основателей проекта PVS-Studio, технический директор компании «Системы программной верификации».’">директора</a> PVS-Studio:<br />
<blockquote><a href="https://pvs-studio.ru/ru/blog/posts/cpp/0554/" title="<= https://www.viva64.com/ru/b/0554/ <- https://habr.com/ru/companies/pvs-studio/articles/418891/ <- google:‘pvs studio V796 site:habr.com’"><i>https://pvs-studio.ru/ru/blog/posts/cpp/0554/</i></a>:<br />
<br />
Многие годы я изучал ошибки в программах и сейчас могу с уверенностью заявить, что в C, а вслед за ним и в C++, оператор <i>switch</i> сделан неправильно. ... огромное количество ошибок убедило меня, что был выбран неправильный подход. Понятно, что теперь уже поздно. Просто хотелось сказать, что правильным решением было бы обязательно писать слово <i>break</i> или обратное ключевое слово, например, <i>fallthrough</i>. Сколько бы сил, времени и денег было сэкономлено.</blockquote>
Его вы<!--[[[, очевидно,]]]--> тоже не относите к профессиональным программистам?<br />
<hr />
2024-12-15 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Никто и никогда, из нормальных программистов, не забывает их писать или не писать, это все выдумки "программистов", пришедших из математики (теоретиков).</blockquote>
После знакомства с коллекциями ошибок программистов от PVS-Studio можно сказать, что волосы дыбом встают. Когда небожители в таких серьёзных проектах допускают такие нелепые ошибки, то впору призадуматься: на чём мир держится? Куда уж там «нормальным» программистам!<br />
<br />
<blockquote>в стандарте C23 в конструкцию switch добавили псевдооператор "проваливания" в виде атрибута <b>fallthrough</b>...<br />
рекомендую ознакомиться с позицией Андрея Карпова</blockquote>
<b>alextretyak</b>, очень весомые аргументы.<br />
<hr />
2024-12-15 <i><b>Клихальт</b></i><br />
<br />
<blockquote>После знакомства с коллекциями ошибок программистов от PVS-Studio можно сказать, что волосы дыбом встают. Когда небожители в таких серьёзных проектах допускают такие нелепые ошибки, то впору призадуматься: на чём мир держится? Куда уж там «нормальным» программистам!</blockquote>
Коллекция ошибок содержит лишь сами ошибки, но не содержит разбора ситуации, приведшей к их появлению и оценки конкретного программиста их допустившего в этой ситуации, а в современном мире с потогонной системой организации труда, катастрофическим падением уровня программистов и их заинтересованности в конечных результатах своего труда это куда важнее обезличенного описания самих ошибок.<br />
<br />
<blockquote>очень весомые аргументы.</blockquote>
Это аргументы в пользу того, что комитет пытается хоть как-то выйти из сложившейся на момент принятия стандарта ситуации и с моей точки зрения он идёт вверх по лестнице, ведущей вниз.<br />
<hr />
2024-12-15 <i><b>Неслучайный читатель</b></i><br />
<br />
Карпов и сотоварищи подкидывают своему PVS-Studio проекты с открытым кодом. Кто ж им даст закрытые коды, правильно? Тогда при чём здесь потогонная система? Кто из добровольцев гонит пот, как не они сами? Гитхаб завален проектами программистов, которых никто не просил писать этот код, они его пишут сами без принуждения.<br />
<hr />
2024-12-16 <i><b>veector</b></i><br />
<br />
<b>@alextretyak</b><br />
<blockquote>Здорово, что вы и все другие профессиональные программисты никогда не забывают писать break.</blockquote>
Забываем, конечно, но очень редко.<br />
У нас чаще используется такой код:<br />
<pre class="code_block">
    switch (State(Obect))
    {
        case StateFoo:
            return StateBar(Obect, ...);
        ...
</pre>
Да и самопальный статический анализатор давно помогает.<br />
А ещё у нас всегда есть default.<br />
<br />
<blockquote>...fallthrough Как вам такая новость?<br />
...<br />
Но в реальном мире, увы, профессиональных программистов на всех не хватает.</blockquote>
Не хватает даже просто нормальных программистов, это точно. Может, тогда, им писать не на Си или все-таки готовить нормальных и учителей научить обучать? Язык-то тут при чем? Или будем в Русский язык вносить слова типа "трафка зелинеет" вместо или вместе с "травка зеленеет"? <b>@alextretyak</b>, вопросы по большей части риторические, ответа на них не требуется, т.к. ответы моего мнения не изменят, ибо до абсурда можно довести все что угодно.<br />
Опять же, повторюсь, я работаю в embedded, и не выбираю какой стандартности компилятор использовать. Мне всегда приходится иметь дело с тем, что идет в комплекте к железу.<br />
<br />
<blockquote>Его вы тоже не относите к профессиональным программистам?</blockquote>
Все зависит от того, как он сам пишет и пользуется ли стат. анализатором.<br />
Стат. анализаторы полезны, с этим никто не спорит, остальное, чистой воды пиар своего анализатора.<br />
Вот если бы он взял и сравнил стат. анализаторы (хотя бы с https://frama-c.com/ (просто первая попавшаяся ссылка с живым свободным проектом анализатора)), было бы больше пользы, но увы и ах.<br />
Вообще, практика показала, чтобы стат. анализатор давал пользу, а не пудрил мозги, его нужно настраивать под проект и стиль кода. Поэтому, мы ограничиваемся лишь собственным набором опыта и не гонимся за всевозможными ситуациями.<br />
<hr />
2024-12-16 <i><b>Клихальт</b></i><br />
<br />
<b>veector</b>,<br />
<blockquote>Не хватает даже просто нормальных программистов, это точно. Может, тогда, им писать не на Си или все-таки готовить нормальных и учителей научить обучать? Язык-то тут при чем?</blockquote>
Согласен на все сто! С некоторых пор стало модно недостатки в подготовке программистов списывать на недостатки языка программирования, используемого ими.<br />
<hr />
2024-12-17 <i><b>Бурановский дедушка</b></i><br />
<br />
<blockquote>скромно считаю синтаксис Си идеальным</blockquote>
<blockquote>стало модно недостатки в подготовке программистов списывать на недостатки языка программирования</blockquote>
В разделе «Проблемы и критика» страницы «Си_(язык_программирования)» в Википедии много и подробно описаны недостатки Си. Это объективно существующие недостатки, они существуют вне зависимости от моды. Однако если бы вдруг эти недостатки исчезли, то хуже бы от этого не стало. Если кто-то сделает лучше, чем сделано в Си, то флаг в руки. Rust в последнее время всё чаще фигурирует в слухах, что на нём переписывают ОС: то Windows, то Linux... Но и Rust не идеален. «У каждого свои недостатки» (© «В джазе только девушки»).<br />
<hr />
2024-12-17 <i><b>Клихальт</b></i><br />
<br />
<b>Бурановский дедушка</b>,<br />
<blockquote>В разделе «Проблемы и критика» страницы «Си_(язык_программирования)» в Википедии много и подробно описаны недостатки Си.</blockquote>
Львиная доля описанных там недостатков произрастает из вкусовщины эпохи повального недостатка действительно квалифицированных программистов и неверного позиционирования языка Си в качестве языка высокого уровня общего назначения, когда на нём стали писать все, кто попало и что попало. Язык Си разрабатывался как замена языку ассемблера в системном программировании. И анализировать его надо именно с этой стороны. Попробуйте рассмотреть с тех же позиций язык ассемблера и предложить разработать ему на замену безопасную версию. Думается плач Ярославны по поводу небезопасности языка Си при этом достигнет масштаба урагана высшей категории.<br />
<br />
<blockquote>«У каждого свои недостатки» (© «В джазе только девушки»).</blockquote>
А вот с этим согласен, но только при должной квалификации и сноровке практически любой недостаток ЯП, при применении языка непосредственно по назначению, можно превратить в его достоинство.<br />
</div>
</body>
</html>