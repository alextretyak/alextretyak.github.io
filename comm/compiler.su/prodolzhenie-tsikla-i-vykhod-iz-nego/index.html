<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/prodolzhenie-tsikla-i-vykhod-iz-nego.php">Продолжение цикла и выход из него (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
2024-10-23 <i><b>bvz</b></i><br />
<br />
Такое чувство, что проблема искусственно создана на ровном месте. Специально, чтобы потом триумфально разрешить её с помощью оператора goto. Кроме циклов for, между прочим, существуют также ещё и циклы while и until. Что мешает использовать один из них? Пусть условие надо_выйти_из_цикла с отрицанием добавлено через конъюнкцию в самый внешний цикл while. И тогда на каждом шаге этого самого внешнего цикла будет проверяться истинность условия надо_выйти_из_цикла.<br />
<br />
Собственно говоря, циклы for, по-моему, придумали с одной единственной целью: избавиться от записи i=i+1 внутри цикла и включить её в заголовок. В некоторых случаях это, может, и удобно. Но если в данном конкретном случае цикл for не подходит, зачем нужно насильно его использовать?<br />
<hr />
2024-10-23 <i><b>Автор сайта</b></i><br />
<br />
Не знаю, искусственным ли путём образовалась проблема или естественным. Однако до сих пор для выхода из нескольких циклов используют либо «goto»<br />
<pre class="code_block">
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            goto &lt;метка>
    // конец второго цикла
// конец первого цикла
&lt;метка>:
</pre>
либо заменитель «goto» («break» с меткой)<br />
<pre class="code_block">
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            break &lt;метка>
    // конец второго цикла
// конец первого цикла
&lt;метка>:
</pre>
либо пользуются самым длинным вариантом — создают дополнительные переменные с дополнительными танцами с бубнами:<br />
<pre class="code_block">
надо_выйти_из_цикла = ложь
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            надо_выйти_из_цикла = истина
            break
    // конец второго цикла
    если надо_выйти_из_цикла
        break
// конец первого цикла
&lt;метка>:
</pre>
Независимо от вида цикла: «while», «until», «for».<br />
<br />
<blockquote>чтобы потом триумфально разрешить её с помощью оператора goto.</blockquote>
Вы невнимательно читали. Как раз-то этот вариант<br />
<pre class="code_block">
цикл &lt;проверка условия>
    цикл &lt;проверка условия>
        если &lt;дополнительная проверка условия>
            break N  // N -число циклов, которые надо покинуть
</pre>
и самый лаконичный, и самый прозрачный. Для него не нужны ни метки (как для «goto» и «break» с меткой), ни дополнительные переменные.<br />
<hr />
2024-10-24 <i><b>bvz</b></i><br />
<br />
Автор сайта, ладно, я понял вашу мысль. Лаконичный — это значит, краткий, правильно? Но ведь не всегда краткий = изящный. Изящность, как и красота — вещь довольно субъективная. На мой взгляд, изящно было бы писать программу, придерживаясь один раз принятых принципов. Например, не использовать оператор goto. И никогда не отступая от них. Но вы и не использовали, вы использовали break N.<br />
<br />
Короче, я бы всё равно писал по-своему. Я только не понял, предлагал ли кто-нибудь выше мой вариант. А что касается искусственности созданной проблемы — проблема эта возникает в тот момент, когда "бывают такие ситуации, когда условие выхода удобнее проверить не в заголовке цикла, а «по месту требования»." Так вот, я бы просто поместил это условие именно в заголовок каждого цикла. Руки бы у меня от этого не отвалились. Удобство или неудобство может возникнуть на стадии понимания программы. Но опять-таки, не думаю, что такую программу будет намного труднее понять.<br />
<br />
И более того. Если вы всегда записываете условие выхода в заголовок цикла, все такие программы будут выглядеть одинаково. Вне зависимости от количества вложенных циклов. Соответственно, исчезает возможность ошибиться на стадии break N. Например, написать break 6 вместо break 5. А может, и вовсе стоит написать рекурсивную процедуру для неограниченного числа вложенных "циклов".<br />
<br />
Хотя, строго говоря, такие алгоритмы, наверное, не будут эквивалентными. Если я проверяю некое условие в заголовке каждого цикла, я делаю дополнительное действие, правильно? Значит, программа будет медленнее работать. Но я такими вещами никогда не заморачивался, честно говоря.<br />
<hr />
2024-10-26 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Так вот, я бы просто поместил это условие именно в заголовок каждого цикла.</blockquote>
Не во всех языках программирования в заголовок цикла <b>for</b> можно вставить дополнительное условие.<br />
Например, в том же Python нет универсального цикла <b>for</b>. И для выхода из нескольких циклов приходится, как уже было сказано выше «создавать дополнительные переменные с дополнительными танцами с бубнами».<br />
<br />
Вот конкретный пример.<br />
У меня есть Python-скрипт, которому требуется определить директорию с установленной Microsoft Visual Studio, <!--[[[причём самой]]]--><!--[[[как можно более новой версии]]]-->причём более новые версии должны быть в приоритете.<br />
Для этого я использовал такой вложенный цикл:<br />
<style>
span.keyword {color: #0000FF; font-weight: bold;}
span.identifier {color: #00009F;}
span.string-literal {color: #800000;}
span.numeric-literal {color: #008000;}
span.constant {color: #008000;}
span.comment {color: #808080;}
</style><pre class="code_block">
<span class="keyword">for</span> <span class="identifier">version</span> <span class="keyword">in</span> [<span class="string-literal">'2022'</span>, <span class="string-literal">'2019'</span>, <span class="string-literal">'2017'</span>, <span class="string-literal">'2015'</span>, <span class="string-literal">'2013'</span>]:
    <span class="keyword">for</span> <span class="identifier">edition</span> <span class="keyword">in</span> [<span class="string-literal">'BuildTools'</span>, <span class="string-literal">'Community'</span>, <span class="string-literal">'Enterprise'</span>, <span class="string-literal">'Professional'</span>]:
        <span class="keyword">if</span> <span class="identifier">os</span>.<span class="identifier">path</span>.<span class="identifier">isfile</span>(<span class="string-literal">'C:\\Program Files (x86)\\Microsoft Visual Studio\\'</span> + <span class="identifier">version</span>
                          + <span class="string-literal">'\\'</span> + <span class="identifier">edition</span> + <span class="string-literal">R'\VC\Auxiliary\Build\vcvarsall.bat'</span>):
            ... <span class="comment"># здесь нужно выйти из всех циклов</span>
</pre>
<br />
Но недавно этот скрипт пришлось поправить, так как оказалось, что 2022-ая студия может быть установлена не в "C:\Program Files (x86)", а в "C:\Program Files".<br />
Вот ссылка на мой коммит с этой правкой: <a href="https://github.com/symasm/symasm/commit/7d2f432a9ef45784646a01662be874abb8ba17e7">https://github.com/symasm/symasm/commit/7d2f432a9ef45784646a01662be874abb8ba17e7</a>.<br />
В итоге код получился вот таким:<br />
<pre class="code_block">
<span class="identifier">was_break</span> = <span class="constant">False</span>
<span class="keyword">for</span> <span class="identifier">version</span> <span class="keyword">in</span> [<span class="string-literal">'2022'</span>, <span class="string-literal">'2019'</span>, <span class="string-literal">'2017'</span>, <span class="string-literal">'2015'</span>, <span class="string-literal">'2013'</span>]:
    <span class="keyword">for</span> <span class="identifier">edition</span> <span class="keyword">in</span> [<span class="string-literal">'BuildTools'</span>, <span class="string-literal">'Community'</span>, <span class="string-literal">'Enterprise'</span>, <span class="string-literal">'Professional'</span>]:
        <span class="keyword">for</span> <span class="identifier">x86</span> <span class="keyword">in</span> [<span class="numeric-literal">0</span>, <span class="numeric-literal">1</span>]:
            <span class="identifier">vcvarsall</span> = <span class="string-literal">'C:\\Program Files'</span> + <span class="string-literal">' (x86)'</span>*<span class="identifier">x86</span> + <span class="string-literal">'\\Microsoft Visual Studio\\'</span> + <span class="identifier">version</span> + <span class="string-literal">'\\'</span> + <span class="identifier">edition</span> + <span class="string-literal">R'\VC\Auxiliary\Build\vcvarsall.bat'</span>
            <span class="keyword">if</span> <span class="identifier">os</span>.<span class="identifier">path</span>.<span class="identifier">isfile</span>(<span class="identifier">vcvarsall</span>):
                <span class="identifier">was_break</span> = <span class="constant">True</span>
                <span class="comment">#print('Using ' + version + '\\' + edition)</span>
                <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="identifier">was_break</span>:
            <span class="keyword">break</span>
    <span class="keyword">if</span> <span class="identifier">was_break</span>:
        <span class="keyword">break</span>
<span class="keyword">if</span> <span class="identifier">was_break</span>:
    <span class="identifier">masm_pathname</span> = <span class="identifier">subprocess</span>.<span class="identifier">check_output</span>(<span class="string-literal">'"'</span> + <span class="identifier">vcvarsall</span> + <span class="string-literal">'" x64 > nul &amp;&amp; where ml64'</span>, <span class="identifier">encoding</span> = <span class="string-literal">'ascii'</span>).<span class="identifier">rstrip</span>()
    <span class="identifier">open</span>(<span class="string-literal">'masm_pathname.txt'</span>, <span class="string-literal">'w'</span>).<span class="identifier">write</span>(<span class="identifier">masm_pathname</span>)
<span class="keyword">else</span>:
    <span class="identifier">print</span>(<span class="string-literal">'''Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].'''</span>)
    <span class="identifier">masm_pathname</span> = <span class="string-literal">'-'</span>
</pre>
<br />
Видите замечательную лесенку из <pre style="display: inline"><span class="keyword">if</span> <span class="identifier">was_break</span></pre>?<br />
И теперь представьте, что вам запросто может потребоваться добавить ещё один вложенный цикл <b>for</b>.<br />
<br />
А если использовать язык программирования с возможностью выхода из нескольких циклов, например 11l, то код получится значительно проще:<br />
<pre class="code_block">
<span class="keyword">loop</span>(<span class="identifier">version</span>) [<span class="string-literal">‘2022’</span>, <span class="string-literal">‘2019’</span>, <span class="string-literal">‘2017’</span>, <span class="string-literal">‘2015’</span>, <span class="string-literal">‘2013’</span>]
   <span class="keyword">loop</span>(<span class="identifier">edition</span>) [<span class="string-literal">‘BuildTools’</span>, <span class="string-literal">‘Community’</span>, <span class="string-literal">‘Enterprise’</span>, <span class="string-literal">‘Professional’</span>]
      <span class="keyword">loop</span>(<span class="identifier">x86</span>) [<span class="numeric-literal">0</span>, <span class="numeric-literal">1</span>]
         <span class="keyword">var</span> <span class="identifier">vcvarsall</span> = <span class="string-literal">‘C:\Program Files’</span>(<span class="string-literal">‘ (x86)’</span>*<span class="identifier">x86</span>)<span class="string-literal">‘\Microsoft Visual Studio\’</span><span class="identifier">version</span><span class="string-literal">‘\’</span><span class="identifier">edition</span><span class="string-literal">‘\VC\Auxiliary\Build\vcvarsall.bat’</span>
         <span class="keyword">if</span> <span class="identifier">fs</span>:<span class="identifier">is_file</span>(<span class="identifier">vcvarsall</span>)
            <span class="comment">//print(‘Using ’version‘\’edition)</span>
            <span class="identifier">masm_pathname</span> = <span class="identifier">os</span>:(<span class="string-literal">‘"’</span><span class="identifier">vcvarsall</span><span class="string-literal">‘" x64 > nul &amp;&amp; where ml64’</span>).<span class="identifier">stdout</span>.<span class="identifier">rtrim</span>(<span class="string-literal">"\n"</span>)
            <span class="identifier">File</span>(<span class="string-literal">‘masm_pathname.txt’</span>, <span class="identifier">WRITE</span>).<span class="identifier">write</span>(<span class="identifier">masm_pathname</span>)
            <span class="keyword">loop</span>(<span class="identifier">version</span>).<span class="identifier">break</span>

<span class="keyword">loop.was_no_break</span>
   <span class="identifier">print</span>(<span class="string-literal">‘Unable to find vcvarsall.bat!
If you do not have Visual Studio 2013, 2015, 2017, 2019 or 2022 installed please install it or Build Tools for Visual Studio from here[https://visualstudio.microsoft.com/downloads/].’</span>)
   <span class="identifier">masm_pathname</span> = <span class="string-literal">‘-’</span>
</pre>
<br />
Конструкция <b>loop(version).break</b> осуществляет выход из соответствующего цикла (в языке 11l меток нет).<br />
Вместо неё можно использовать эквивалентную (при данном количестве вложенных циклов!) конструкцию: <b>^^loop.break</b>.<br />
Я выбрал символы крышечки (^) вместо числа после <b>break</b>, так как:<br />
<ol>
<li>не очевидно с какого числа начинается отсчёт, с 0 или с 1 (в PHP начинается с 1, т.е. просто <b>break</b> равнозначен <b>break 1</b>, а чтобы прервать внешний цикл, нужно использовать <b>break 2</b>, но в программировании нумерацию принято начинать с 0, т.е. было бы логично, что просто <b>break</b> равнозначен <b>break 0</b>... в общем, возможна путаница; с крышечками же логика проще — если их нет, то <b>loop.break</b> он и в Африке... осуществляет выход только из текущего цикла, если одна крышечка, то выходим из вышестоящего цикла по отношению к текущему, если крышечки две, то идём ещё выше (сам этот символ символизирует направление вверх, потому он и был выбран <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none"><br />
Но ведь <b>^loop.break</b> по факту осуществляет переход не выше/вверх, а вниз, сразу к коду после цикла. Как же так?<br />
Дело тут в том, что крышечка (^) относится не к <b>loop.break</b>, а к <b>loop</b>. Т.е. имеется в виду <b>(^loop).break</b>, а не <b>^(loop.break)</b>.<br />
И использовать крышечку/-ки перед <b>loop</b> можно не только для выхода из цикла, но и для продолжения цикла — <b>^loop.continue</b>, для получения индекса (номера<!--[[[,]]]--> начиная с 0) текущей итерации цикла — <b>^loop.index</b> и т.д.<br />
</span><span class="cu_brackets_b">}</span></span>) и т.д.);</li>
<li>число после <b>break</b> создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например <b>break 2+3</b> или вообще вставить какую-<!--[[[то/]]]-->нибудь переменную:<br />
<pre class="code_block">
<span class="keyword">loop</span> ...
    <span class="keyword">loop</span> ...
       <span class="keyword">loop</span> ...
          <span class="identifier">int</span> <span class="identifier">entered_number</span> = <span class="identifier">int</span>(<span class="identifier">input</span>(<span class="string-literal">‘Сколько циклов вы хотите покинуть?’</span>))
          <span class="identifier">break</span> <span class="identifier">entered_number</span>
</pre></li>
</ol>
<br />
Более «монолитно», чем <b>break 2</b>, выглядит запись <b>break_2</b>, но так сделать в языке программирования не получится<!--[[[ —]]]-->, т.к. break_2 может быть действительным именем переменной/идентификатором.<br />
<br />
Но если вернуться к исходной проблеме — лесенке из <pre style="display: inline"><span class="keyword">if</span> <span class="identifier">was_break</span></pre>, то есть и друго<!--[[[й выход]]]-->е решение — поместить необходимую логику внутрь функции, которая вместо <b>break</b> будет делать <b>return</b>.<br />
Но мне не нравится такое решение — нужно придумывать имя для новой функции, которая используется только в одном месте и только для обхода ограничения используемого языка программирования. Похоже на костыль.<br />
<br />
<blockquote>Хотя для применения «continue N» не очень легко привести пример из жизни для иллюстрации его полезности. Возможно, читатели этих строк предложат что-то в комментариях к статье.</blockquote>
Предложат-предложат. :)(:<br />
<br />
Вот два наиболее интересных встретившихся мне примера, в которых было бы оправдано применение «continue N»:<br />
<ol>
<li>В транспайлере Python → 11l вот <a href="https://github.com/11l-lang/python_to_11l/blob/f54b0475ebbceaea280e1b9eca6eab99069f2f4f/parse.py#L3053-L3056">эти 4 строки</a> не самого понятного Python-кода можно заменить одной строкой <b>^loop.continue</b> (аналог <b>continue 2</b>).</li>
<li>Этот <a href="https://rosettacode.org/wiki/Peaceful_chess_queen_armies#D">код на языке D</a> использует <b>continue &lt;метка></b> <span class="sq"><span class="sq_brackets">[</span>и, как видно по этой же веб-странице, эту конструкцию поддерживают также языки Go, Java, Kotlin, Swift<span class="sq_brackets">]</span></span>, но т.к. Python такого не поддерживает, пришлось усложнить логику путём добавления двух else-веток для for — <a href="https://github.com/11l-lang/_11l_to_cpp/blob/master/tests/python_to_cpp/Rosetta%20Code/p.txt#L2272">вот этот перевод на Python</a>.</li>
</ol>
Там же на rosettacode.org можно поискать ещё хорошие примеры употребления <b>continue &lt;метка></b> (вдруг я что-то упустил).<br />
<hr />
2024-10-26 <i><b>Автор сайта</b></i><br />
<br />
<blockquote><b>^^loop.break</b></blockquote>
Я префиксному «^» собираюсь назначить иную роль. Один такой символ — увеличение области видимости на уровень выше. То есть за пределы скобки <!--[[[(]]]-->«)»:<br />
<pre class="code_block">
( (^переменная = ... // инициализация переменной с выводом её типа
    ... = переменная // внутри скобок она видна
  )
  ... = переменная   // за пределами первой пары скобок тоже видна
)
... = переменная   // за пределами второй пары скобок не видна
</pre>
<br />
<blockquote>не очевидно с какого числа начинается отсчёт, с 0 или с 1</blockquote>
Число после «break» — это <b>сколько циклов надо покинуть</b>. Если 0, то значит цикл покидать не надо.<br />
<br />
<blockquote>число после break создаёт ощущение, что вместо него можно подставить какое-то целочисленное выражение и написать например break 2+3</blockquote>
Компилятор разочарует своими сообщениями об ошибках. Так же, как если бы вместо var4 написали бы var2*2.<br />
<br />
<blockquote>эти 4 строки не самого понятного Python-кода можно заменить одной строкой <b>^loop.continue</b></blockquote>
👍<br />
<hr />
2024-10-26 <i><b>ИванАс</b></i><br />
<br />
<blockquote><pre class="code_block">
<span class="keyword">for</span> <span class="identifier">version</span> <span class="keyword">in</span> [<span class="string-literal">'2022'</span>, <span class="string-literal">'2019'</span>, <span class="string-literal">'2017'</span>, <span class="string-literal">'2015'</span>, <span class="string-literal">'2013'</span>]:
    <span class="keyword">for</span> <span class="identifier">edition</span> <span class="keyword">in</span> [<span class="string-literal">'BuildTools'</span>, <span class="string-literal">'Community'</span>, <span class="string-literal">'Enterprise'</span>, <span class="string-literal">'Professional'</span>]:
        <span class="keyword">for</span> <span class="identifier">x86</span> <span class="keyword">in</span> [<span class="numeric-literal">0</span>, <span class="numeric-literal">1</span>]
</pre></blockquote>
Наверное, можно заменить на product из itertools.<br />
<hr />
2024-10-28 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Я префиксному «^» собираюсь назначить иную роль. Один такой символ — увеличение области видимости на уровень выше.</blockquote>
Так одно другому не мешает.<br />
В 11l, кстати, планируется аналогичный функционал: использовать префиксы <b>^</b> для доступа к переменным из внешней области видимости. Особенно это может быть полезно во время отладки (например, есть цикл по <b>i</b>, внутри него ещё какой-то цикл, внутри которого ещё маленький цикл по <b>i</b>, находясь в котором хочется получить текущее значение переменной <b>i</b> верхнего уровня, это можно сделать посредством записи <b>^i</b>).<!--[[[
#rec##audio#[REC_0003412.wav][в СвН соборе в углу на лавочке у иконы Арх. Михаилу]
Я об этом писал ещё в статье «Каркас нового языка программирования».
]]]--> Я об этом писал ещё в статье «Каркас нового языка программирования» на Хабре и в комментариях там по<!--[[[ этому]]]--> поводу этой возможности велись <!--[[[активные/]]]-->горячие споры: <a href="https://habr.com/ru/articles/350694/comments/#comment_10701298">https://habr.com/ru/articles/350694/comments/#comment_10701298</a>.<br />
Также хочу обратить внимание на то, что в записи <b>^^loop.break</b> крышечки относятся не к <b>break</b>, а к <b>loop</b>. Т.е. имеется в виду <b>(‍^^loop).break</b>, а не <b>^^(loop.break)</b>.<br />
<br />
<blockquote><pre class="code_block">
( (^переменная = ... // инициализация переменной с выводом её типа
    ... = переменная // внутри скобок она видна
  )
  ... = переменная   // за пределами первой пары скобок тоже видна
)
</pre></blockquote>
Ну в чистом виде такой код малополезен — проще создать переменную чуть раньше за скобкой. А на практике может понадобиться создать «внешнюю» переменную в теле условного оператора. Вот только вопрос<!--[[[,]]]-->: что делать в случае, когда условие не выполняется — <!--[[[ведь обращение к этой переменной осуществляется]]]-->как должно отрабатывать обращение к этой переменной в последующем коде?<br />
<br />
И разве ваш язык не предполагает явное обозначение объявления новой переменной?<br />
В 11l обязательно указывать при инициализации, что объявляется новая переменная, с помощью ключевого слова <b>var</b>\<b>пер</b>:<br />
<pre class="code_block">
<span class="keyword">если</span> &lt;<span class="identifier">условие</span>>
   <span class="keyword">пер</span> <span class="identifier">имя_новой_переменной1</span> = ...  <span class="comment">// видна только внутри тела условного оператора</span>
   <span class="keyword">пер</span> ^<span class="identifier">имя_новой_переменной2</span> = ... <span class="comment">// видна также снаружи,</span>
<span class="identifier">вывод</span>(<span class="identifier">имя_новой_переменной2</span>)        <span class="comment">// но что делать, если &lt;условие> ложно?</span>
</pre>
<br />
Также префикс <b>^</b> можно будет использовать для обозначения «внешних» счётчиков цикла:<br />
<pre class="code_block">
<span class="keyword">цикл</span>(^<span class="identifier">н</span>) <span class="numeric-literal">0</span> .&lt; <span class="numeric-literal">100</span> <span class="comment">// цикл от 0 до 100, включая 0, но не включая 100</span>
   <span class="keyword">если</span> &lt;<span class="identifier">условие</span>>
      <span class="keyword">цикл.прервать</span> <span class="comment">// или цикл.выход</span>

<span class="identifier">вывод</span>(<span class="identifier">н</span>) <span class="comment">// выводим значение `н` на итерации, в которой цикл был прерван</span>
         <span class="comment">// если цикл не был прерван, то в `н` будет число 100</span>
</pre>
И перед точкой:<br />
<pre class="code_block">
.offset = 5
pos1.
   pos2.
      .x = 10 + ^.x + ^^.offset
     └─┬┘      └─┬─┘ └────┬────┘
       │         │        ╘═(^^.).offset = 5
       ╘═pos2.x  ╘═pos1.x
</pre>
И ещё — для внешних return:<br />
<pre class="code_block">
<span class="keyword">фн</span> <span class="identifier">внешняя_функция</span>(...)
   <span class="keyword">фн</span> <span class="identifier">локальная_функция</span>()
      ^<span class="identifier">возврат</span> <span class="comment">// возврат из внешней функции</span>
   <span class="identifier">локальная_функция</span>()
   ... <span class="comment">// этот код выполняться не будет, т.к. внутри вызова</span>
   ... <span class="comment">// локальной функции осуществляется возврат из внешней</span>
</pre><!--[[[
На замечание «это приводит к неочевидной логике работы кода функции» я могу ответить, что внешний/глубокий return ничем не хуже исключений, которые возбуждаются при обращении к элементу по индексу за границами массива или при арифметических переполнениях.
]]]-->
<br />
<blockquote>Число после «break» — это сколько циклов надо покинуть. Если 0, то значит цикл покидать не надо.</blockquote>
А вот разработчики языка PHP с вами не согласны.<br />
В версии до 5.4 <b>break 0</b> работал так же как <b>break 1</b>, а в 5.4 и более новых версиях — писать <b>break 0</b> вообще запретили.<br />
<a href="https://php.ru/manual/control-structures.break.html">https://php.ru/manual/control-structures.break.html</a><!--[[[ <- google:‘php "break 0"’]]]--><br />
<br />
<blockquote>Компилятор разочарует своими сообщениями об <b>ошибках</b>. Так же, как если бы вместо var4 написали бы var2*2.</blockquote>
Эмм. Не понял, а в чём ошибка компиляции в записи var2*2? Это же простое умножение значения переменной var2 на число 2.<!--[[[
Если речь про ошибку «переменная не найдена», то если есть переменная var4, то скорее всего есть и var2. :)(:]]]--><br />
<hr />
2024-11-04 <i><b>Автор сайта</b></i><br />
<br />
<b>alextretyak</b>, наконец-то отвечаю Вам.<br />
<blockquote>В 11l, кстати</blockquote>
Кстати, что означает такое название языка? Почему оно такое?<br />
<br />
<blockquote>в записи ^^loop.break крышечки относятся не к break, а к loop. Т.е. имеется в виду (^^loop).break, а не ^^(loop.break).</blockquote>
Не очень понимаю, зачем оператору break нужен loop. И так же ясно, что выйти можно только из цикла. В одних местах Вы стремитесь к наибольшей краткости, а в этом месте — нет. Даже case с двоеточием убираете из конструкции switch, оставляете одну константу. А тут такая расточительность.<br />
<br />
<blockquote>такой код малополезен — проще создать переменную чуть раньше за скобкой.</blockquote>
Если чуть раньше, то значит<br />
<ul>
<li>просто её объявить, без инициализации. Тогда придётся делать анализ: а не используется ли эта переменная в правой части присваивания, будучи неинициализированной?</li>
<li>Или инициализировать, но инициализация за скобкой будет бесполезной: значение в последующем будет изменено, а инициализирующее значение так и не понадобится.</li>
</ul>
Инициализация же в нужном месте с распространением видимости на уровень выше упрощает применение вывода типа через инициализацию.<br />
<br />
<blockquote>А на практике может понадобиться создать «внешнюю» переменную в теле условного оператора. Вот только вопрос: что делать в случае, когда условие не выполняется — как должно отрабатывать обращение к этой переменной в последующем коде?</blockquote>
Инициализация переменной должна произойти во всех альтернативных ветвях кода во избежание использования неинициализированной переменной в правой части присваивания.<br />
<br />
Но лучше это делать конструкцией вроде этой:<br />
<pre class="code_block">
а = (если условие; "это правда" иначе "не верь этому")
</pre>
<br />
<blockquote>не предполагает явное обозначение объявления новой переменной?</blockquote>
Да, не предполагает. Хотя, если требуется, можно уточнить тип инициализирующего значения.<br />
<br />
<blockquote>В 11l обязательно указывать при инициализации, что объявляется новая переменная, с помощью ключевого слова</blockquote>
У Алексея Недори в его Тривиле сделано весьма любопытно<br />
<pre class="code_block">
а = 9  // а — константа, ибо знак равенства
б := 0 // б — переменная, ибо присваивание
</pre>
<br />
Да и зачем вообще объявлять новую переменную? Вы же стремитесь к краткости в языке. Ясное дело, что описание типов необходимо для аргументов функции или полей структур данных, без этого не обойтись. С глобальными переменными тоже надо думать, как быть.<br />
<br />
<blockquote>в 5.4 и более новых версиях — писать break 0 вообще запретили.</blockquote>
И правильно сделали. Зачем нужны бессмысленные конструкции? Когда я написал про break 0, то это было «объяснение на пальцах». Я лишь уповал на логику, чтобы исключить путаницу. А не иллюстрировал будущие задумки.<br />
<br />
<blockquote>в чём ошибка компиляции в записи var2*2? Это же простое умножение значения переменной var2 на число 2.</blockquote>
Я имел в виду, что выражение<br />
<pre class="code_block">
var4 = нечто
</pre>
синтаксически правильно, в отличие от<br />
<pre class="code_block">
var2*2 = нечто
</pre>
Точно так же<br />
<pre class="code_block">
break 4
</pre>
не может быть заменено на<br />
<pre class="code_block">
break 2*2
</pre>
Хотя в теории, ничто не мешает <a href="http://compiler.su/makrosy-eto-chistye-funktsii-ispolnyaemye-vo-vremya-kompilyatsii.php">во время компиляции вычислить значение</a> количества покидаемых циклов, если выражение вычислимо во время компиляции.<br />
<pre class="code_block">
break cos(0) + tg(π/2)
</pre>
Но тогда придётся делать законным<br />
<pre class="code_block">
break 0
</pre>
Но это всё игры разума, можно обойтись без пижонства, одним лишь обычным числом.<br />
<hr />
2024-11-06 <i><b>alextretyak</b></i><br />
<br />
<b>ИванАс</b><br />
<blockquote>Наверное, можно заменить на product из itertools.</blockquote>
В данном случае да, можно.<br />
<!--[[[Но читаемость кода, на мой взгяд, при этом ухудшится.]]]-->Но восприятие кода при этом усложнится<!--[[[ (]]]-->, несмотря на избавление от лесенки из <pre style="display: inline"><span class="keyword">if</span> <span class="identifier">was_break</span></pre><!--[[[), т.к. itertools.product встречается в реальном коде [[[достаточно/]]]очень редко]]]-->.<br />
<br />
<b>Автор сайта</b><br />
<blockquote>Кстати, что означает такое название языка?</blockquote>
Об этом можно догадаться из описания языка на его сайте — <a href="http://11l-lang.org/ru">http://11l-lang.org/ru</a><br />
<!--[[[Чуть б]]]-->Более подробно написано об этом на странице языка в Википедии (которую, правда, уже удалили, но есть сохранённая копия — <a href="https://11l-wikipedia.github.io/ru">https://11l-wikipedia.github.io/ru</a>):<br />
<blockquote class="re">В отличие от других языков программирования, ключевые слова 11l структурированы в иерархию. На верхнем уровне этой иерархии располагается 11 базовых/корневых ключевых слов. Данная черта легла в основу названия языка программирования 11l, где «l» означает «litterae» в латинском, «logos» в греческом (в значении «слово»), либо «letters» в английском (так как корневые ключевые слова языка можно сокращать до одной буквы).</blockquote>
<br />
<blockquote>Не очень понимаю, зачем оператору break нужен loop.</blockquote>
<!--[[[Таким образом,]]]-->Поэтому, исходя из названия языка, я не могу добавить в 11l ключевое слово <b>break</b>, т.к. в <!--[[[таком/]]]-->этом случае корневых ключевых слов станет больше, чем 11.<br />
<br />
<blockquote>Даже case ... убираете из конструкции switch</blockquote>
С <b>case</b> аналогично — добавить это ключевое слово в 11l невозможно <span class="sq"><span class="sq_brackets">[</span>не изменив название языка на 12l :)(:<span class="sq_brackets">]</span></span>.<br />
<br />
<blockquote>И так же ясно, что выйти можно только из цикла.</blockquote>
Не только. В 11l ещё есть <b>switch.break</b>. Впрочем, его полезность под вопросом. А вот <b>switch.fallthrough</b> может пригодиться.<br />
<br />
К тому же, даже если «только из цикла», то остаётся вопрос: «а из какого именно цикла?» И вот тут этот "<!--[[[избыточный/]]]-->расточительный" синтаксис оказывается очень к месту: <b>loop</b> обозначает текущий цикл, <b>^loop</b> обозначает вышестоящий цикл, <b>loop(version)</b> обозначает цикл с переменной цикла version и т.д. И к любому выбранному циклу можно применить любое ключевое "подслово" <!--[[[цикла]]]-->корневого слова loop, а именно <b>break</b>, <b>continue</b>, <b>index</b>, <b>first_iteration</b> и пр.<br />
<br />
<blockquote>Или инициализировать, но инициализация за скобкой будет бесполезной</blockquote>
А зачем вообще необходимо использовать вложенные скобки в вашем примере?<br />
Можете привести более законченный/практичный пример где требуется запись <b>^переменная = ...</b>? А то<!--[[[ мне вообще]]]--> не очень понятно, что вы имели в виду.<br />
<br />
<blockquote>Да и зачем вообще объявлять новую переменную?</blockquote>
Если честно, я даже не рассматривал этот вопрос всерьёз. Практически во всех компилируемых языках переменные необходимо объявлять явно, и я считал этот вопрос решённым и не требующим переосмысления. А сейчас вот даже и не знаю, что ответить, какие <!--[[[реальные/]]]-->весомые аргументы привести в пользу явного объявления.<br />
<br />
Прежде всего, мне нравится чётко видеть в коде, где объявляется/создаётся новая переменная, а где изменяется значение уже существующей.<br />
<br />
И компилятор не пропустит случаи, когда в имени переменной была допущена ошибка:<br />
<pre class="code_block">
<span class="keyword">fn</span> <span class="identifier">calc_result</span>()
   <span class="keyword">var</span> <span class="identifier">result</span> = <span class="numeric-literal">0</span>
   <span class="keyword">if</span> ...
      <span class="identifier">rezult</span> = <span class="numeric-literal">1</span> <span class="comment">// ошибка компиляции, а не создание новой переменной с именем rezult</span>
   ...
</pre>
<br />
<!--[[[Чтобы можно было]]]-->Также явное объявление позволяет создать новую переменную с уже использующимся именем во внутренней области видимости:<br />
<pre class="code_block">
<span class="keyword">fn</span> <span class="identifier">calc_result</span>()
   <span class="keyword">var</span> <span class="identifier">r</span> = <span class="numeric-literal">0</span>
   ...
   <span class="keyword">if</span> ...
      <span class="keyword">var</span> <span class="identifier">r</span> = <span class="numeric-literal">1</span> <span class="comment">// без `var` будет использоваться внешняя `r`</span>
      <span class="identifier">print</span>(<span class="identifier">r</span>)  <span class="comment">// выводим значение внутренней `r`</span>
   ...
   <span class="keyword">return</span> <span class="identifier">r</span> <span class="comment">// возвращаем значение `r`, объявленной в начале функции</span>
</pre><!--[[[
А также для единообразия области видимости переменных циклов:
#(11l)‘
loop(i)
   ...
   loop(i)
      ...
   ...
’]]]-->
Или позволяет запретить создание таких переменных (т.н. variable shadowing). <span class="sq"><span class="sq_brackets">[</span>Причём этот запрет лучше вынести из спецификации языка на уровень опций компилятора, чтобы решение принимал руководитель проекта (решение о том, позволять variable shadowing или запрещать в коде проекта).<span class="sq_brackets">]</span></span><br />
<br />
<blockquote>Ясное дело, что описание типов необходимо для аргументов функции</blockquote>
Тип аргументов функции даже в компилируемом языке указывать необязательно.<br />
<br />
Так, в C++20 появилась возможность использовать auto вместо типа аргумента функции — в этом случае тип аргумента «определится» в месте вызова функции.<br />
А в 11l такое поведение получается в случае, когда тип аргумента вообще не указан (а только его имя<!--[[[ аргумента]]]-->).<br />
<br />
Хотя для перегрузки функции с одинаковым количеством аргументов указать тип хотя бы некоторых из них, конечно, придётся явно.<br />
<br />
<blockquote>Когда я написал про break 0, то это было «объяснение на пальцах». Я лишь уповал на логику, чтобы исключить путаницу.</blockquote>
Тогда соглашусь. Логика в этом есть.<br />
Правда такую запись — <b>break &lt;число></b> — в других языках (кроме PHP) я не встречал.<br />
<hr />
2024-11-09 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Данная черта легла в основу названия языка программирования 11l, где «l» означает «litterae» в латинском</blockquote>
Мне кажется, маркетологи убили бы Вас за такое название. 🤣<br />
<br />
<blockquote>я не могу добавить в 11l ключевое слово break, т.к. в этом случае корневых ключевых слов станет больше, чем 11... добавить это ключевое слово в 11l невозможно, не изменив название языка на 12l</blockquote>
Вы сами придумали себе трудности, а потом героически их преодолеваете. Была когда-то такая забава — турнир поэтов. Поэты сперва придумывали какие-нибудь произвольные ограничения, например окончание строк на какие-то строго определённые слова. А потом укладывали свои стихи в такое прокрустово ложе. Вот и Вам, видимо, придётся строить модель парусника внутри стеклянной бутылки. Но Вы автор, Вы творец и Вам виднее.<br />
<br />
<blockquote>Можете привести более законченный/практичный пример где требуется запись ^переменная = ...?</blockquote>
<pre class="code_block">
(^i = 0 цикл i &lt; N; ++ i // i объявлена внутри скобок
   . . .)
j = i                    // но видна за скобками
</pre>
<br />
<blockquote>Практически во всех компилируемых языках переменные необходимо объявлять явно, и я считал этот вопрос решённым и не требующим переосмысления. А сейчас вот даже и не знаю, что ответить, какие весомые аргументы привести в пользу явного объявления.</blockquote>
Вывод типов, то есть инициализация как значения, так и типа, исключает такой класс ошибок, как использование неинициализированных переменных. Вывод типов создаёт иллюзию, что объявлять переменные не надо. Но это только иллюзия, которая придаёт сходство с языками с динамической типизацией.<br />
<br />
<blockquote>мне нравится чётко видеть в коде, где объявляется/создаётся новая переменная, а где изменяется значение уже существующей.</blockquote>
Есть возможность почувствовать вкус иного стиля, попрактиковавшись на языках типа PHP или Basic. Тогда идею вывода типов легче принять. В языках с динамической типизацией тип переменной может меняться по ходу вычислений, а при выводе типов тип переменной задаётся один раз, при инициализации.<br />
<br />
<blockquote>явное объявление позволяет создать новую переменную с уже использующимся именем во внутренней области видимости</blockquote>
Мне кажется, уникальность имён позволяет не париться на эту тему. А если приспичило, то можно неуникальные имена сопровождать именем области видимости. Но, думается, лучше не дублировать имена.<br />
<br />
<blockquote>Хотя для перегрузки функции с одинаковым количеством аргументов указать тип хотя бы некоторых из них, конечно, придётся явно.</blockquote>
И тут склоняюсь к <a href="http://compiler.su/unikalnost-imyon-funktsij.php">уникальности имён</a>. Хотя полиморфизм времени компиляции даёт некоторую волю, не так уж и сильно ограничивает такая уникальность.<br />
<br />
<blockquote>Правда такую запись — break &lt;число> — в других языках (кроме PHP) я не встречал.</blockquote>
Я уже рассказывал историю своих взаимоотношений с break и continue. Когда-то придумал, что эти ключевые слова надо сделать с числовым параметром. Потом познакомился с PHP и увидел, что break в нём может иметь параметр, а вот continue нет. Потом написал и опубликовал эту идею в статье, которую мы сейчас комментируем. Потом появился язык Jancy, в котором и break, и continue имеют параметр. А автор языка Jancy просит меня включить свой язык в <a href="http://compiler.su/entuziasty-razrabotchiki-kompilyatorov-i-ikh-proekty.php">этот список</a>.<br />
<hr />
2024-11-13 <i><b>Неслучайный читатель</b></i><br />
<br />
Если не нравится <b>break 2</b>, можно заменить на <b>break break</b><br />
<pre class="code_block">
цикл
    цикл
        если условие
            break break //выход из обоих циклов
</pre>
То есть <b>break N</b> меняется на N штук <b>break</b>. Как в языках народов Полинезии: если существительное употребляется несколько раз, то столько штук и имелось в виду.<br />
<br />
С <b>continue N</b> интереснее. Ведь чтобы перейти к продолжению цикла уровня N, надо сперва выйти из N-1 циклов. То есть <b>continue N</b> по факту означает <b>break ... break continue</b>: где <b>break</b> повторяется N-1 раз.<br />
<hr />
2024-11-13 <i><b>Борис К.</b></i><br />
<br />
<b>Ада</b><br />
<pre class="code_block">
цикл1:loop
    ...
    цикл2:loop
        ...
        exit цикл1;
        exit цикл2;
        ...
    end loop цикл2;
    ...
end loop цикл1;
</pre>
<hr />
2024-11-13 <i><b>Неслучайный читатель</b></i><br />
<br />
Длинновато с метками.<br />
<hr />
2024-11-14 <i><b>alextretyak</b></i><br />
<br />
<b>Автор сайта</b><br />
<blockquote>Вы сами придумали себе трудности, а потом героически их преодолеваете.</blockquote>
<!--[[[Честно говоря, не думал, что можно посмотреть на эту фичу 11l с такой точки зрения.]]]-->А ведь и правда, можно посмотреть на это и с такой точки зрения. Как-то не думал об этом.<br />
Но всё-таки, синтаксис и возможности языка 11l <!--[[[составлялись/]]]-->определялись не исходя из его названия (к которому я пришёл далеко не сразу), а наоборот — когда я понял/пришёл к окончательному решению, что корневых ключевых слов достаточно одиннадцати<!--[[[ (и даже решил отказаться от [[[вспомогательного]]] слова *‘extra’ для подслов вне категорий)]]]-->, то решил оставить такое название с целью предотвратить <!--[[[его]]]--> <!--[[[дальнейшее]]]-->ненужное раздувание языка.<br />
<br />
<blockquote>Есть возможность почувствовать вкус иного стиля, попрактиковавшись на языках типа PHP или Basic.</blockquote>
Я уже давно напрактиковался в таких языках. Даже свой движок форума написал на PHP и JavaScript.<br />
И если PHP со своими вездесущими «долларами» <span class="sq"><span class="sq_brackets">[</span>перед именем каждой переменной<span class="sq_brackets">]</span></span> и "аляповатой" и перегруженной стандартной библиотекой мне никогда не нравился, то JavaScript-ом я поначалу прямо таки восхищался. После C++ (причём версии C++03) с его излишней многословностью, JS ощущался как глоток свежего воздуха. Но восхищение со временем и опытом профессионального программирования <span class="sq"><span class="sq_brackets">[</span>правда не на JS, а на Lua и C++<span class="sq_brackets">]</span></span> прошло. И пришло понимание, что строгая типизация всё-таки лучше (а строгая статическая — ещё лучше).<br />
<!--[[[А отсутствием необходимости явного объявления/создания переменных я порядочно «наелся» в Python.]]]-->Но по опыту программирования на Python я, откровенно говоря, могу признать, что отсутствие необходимости явного объявления/создания переменных — штука весьма удобная.<br />
<!--[[[Более того]]]-->И вместе с тем, наверное самое большое, что меня в <!--[[[нём/]]]-->Python раздражает, это смежная/похожая его фича — <!--[[[отсутствие вложенных областей]]]-->единая область видимости для всех локальных переменных в функции, независимо от того, на каком уровне они создаются.<br />
К примеру, <!--[[[попробуйте догадаться]]]-->догадываетесь, почему в <a href="https://sourceforge.net/p/pqmarkup/code/ci/0aafa73f124996c2be99483a4479cd79e1a43d02/tree/pqmarkup.py#l624">этой строке кода</a> <!--[[[используется/]]]-->написано <b>for ii in ...</b>, а не просто <b>for i in ...</b>?<br />
Да потому, что <b>i</b> уже используется в этой функции в качестве индекса текущего разбираемого символа входной строки. Но сначала то я в этом месте написал просто <b>i</b>, в результате чего получилось, что выполнение данного кода приводило к «порче» переменной <b>i</b>, "объявленной" <!--[[[ранее]]]-->выше и использующейся в последующем коде. <!--[[[А в другом проекте (не могу точно вспомнить/найти где) я .]]]-->И я до сих пор <!--[[[порой/]]]-->иногда забываю про эту "особенность" Python и наступаю на эти грабли (т.е. забываю про то, что добавление невинного цикла <b>for i</b> глубоко внутри функции портит значение <b>i</b>, использующейся в окружающем коде).<!--[[[ Как же это бесит.]]]--><br />
<br />
<blockquote>Тогда идею вывода типов легче принять.</blockquote>
Вывод типов в 11l есть. Также как и в новых версиях практически всех популярных компилируемых языков программирования. Вывод типа переменной при её инициализации — это фактически уже стандарт<!--[[[ для всех компилируемых языков программирования]]]-->, им никого не удивишь <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">и многие им даже злоупотребляют — у нас на работе был программист, который настолько любил писать всюду <b>auto</b>, появившийся в C++11 в новом качестве, что вместо <b>int i = 0;</b> он писал <b>auto i = 0;</b></span><span class="cu_brackets_b">}</span></span>. <!--[[[Не вижу смысла обсуждать его полезность.]]]-->Но обсуждаем то мы другое, а именно «необходимость явного обозначения для объявления/создания новой переменной».<br />
<br />
<blockquote>В языках с динамической типизацией тип переменной может меняться по ходу вычислений, а при выводе типов тип переменной задаётся один раз, при инициализации.</blockquote>
Дело не в «динамичности» типизации. В статически типизированном Rust тип переменной тоже может меняться. Эта фича называется “rebinding”. Фактически, Rust позволяет переобъявлять переменную с <!--[[[новым]]]-->другим типом, скрывая переменную с таким же именем, объявленную ранее. <a href="https://users.rust-lang.org/t/rebinding-variables-with-let/12959">Вот здесь</a> есть пример кода.<br />
Но аналогичного эффекта можно добиться и в C++ <!--[[[с ]]]-->использованием фигурных скобок:<br />
<pre class="code_block">
{auto x = 1;
...
}{auto x = "Hello World!";
...
}
</pre><!--[[[
>[https://users.rust-lang.org/t/rebinding-variables-with-let/12959 <- google:‘rust var rebind’]:‘
int x = 1;
{
char *x = "hi";
}’
]]]-->
Единственное, что дополнительно позволяет делать Rust (и что не получится повторить в C++) — это использовать при инициализации новой переменной значение старой/скрываемой переменной с таким же именем:<br />
<pre class="code_block">
let s = "123";
...
let s = s.len(); // `s` здесь "меняет" тип на число
// (теперь в `s` содержится длина строки `s`)
</pre><!--[[[Пример навеян [https://www.reddit.com/r/rust/comments/1fx4pse/is_this_an_example_of_shadowing_or_rebinding_in/ <- google:‘rust var rebind’]]]]-->
Заметьте, что раз ваш язык не предполагает явное обозначение объявления новой переменной, то в вашем языке такой трюк как в Rust повторить не получится.<br />
<br />
<blockquote><pre class="code_block">
(^i = 0 цикл i &lt; N; ++ i // i объявлена внутри скобок
   . . .)
j = i                    // но видна за скобками
</pre></blockquote>
Так ведь тут можно, как я уже писал выше «создать переменную чуть раньше за скобкой»:<br />
<pre class="code_block">
i = 0
(цикл i &lt; N; ++ i
   . . .)
j = i
</pre>
Или можно даже так:<br />
<pre class="code_block">
i = 0; (цикл i &lt; N; ++ i
   . . .)
j = i
</pre>
В последнем случае количество строк кода будет такое же.<br />
И даже количество символов такое же.<br />
И даже специальный синтаксис с префиксным «^» не нужен.<br />
И даже читаемость/понятность кода лучше.<br />
</div>
</body>
</html>