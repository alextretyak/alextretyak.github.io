<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/es-evm-eto-izmena-trusost-i-obman.php">ЕС ЭВМ — это измена, трусость и обман? (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
2024-08-07 <i><b>Автор сайта</b></i><br />
<br />
Пришёл на почту такой вопрос:<br />
<blockquote>Помнится, встречал на вашем сайте такое мнение, что «начинать нужно с создания своих собственных отечественных процессоров». Возможно, это писали не Вы, но мне интересно ваше мнение на этот счёт.</blockquote>
Решил дать ответ через сайт на странице, которая ближе всего к этой теме. Ибо сейчас стоит такой же вопрос, как и 55 лет назад: сделать что-то своё или выбрать что-то лучшее из зарубежного? 55 лет назад выбирали между условным «Уралом»/БЭСМ-6 и IBM/360. Сейчас же, если упростить ситуацию, выбирают между «Эльбрусом» и RISC-V.<br />
<br />
Выбор IBM/360 в качестве ЕС ЭВМ был, на мой взгляд вынужденной мерой: на дворе была холодная война, а времени и денег было в обрез. Обвинение в предательстве, высказываемые сейчас, неуместны: люди, которые принимали такое решение, были уважаемы и не раз доказывали, что их труд и талант работает на благо страны.<br />
<br />
Что касается сегодняшнего дня, то пусть правильное решение примут специалисты. Себя же считаю недостаточно компетентным в этом. С одной стороны, хочется пожелать успехов отечественному «Эльбрусу». С другой стороны, есть вопросы: а потянем ли? Действительно ли так хорош «Эльбрус»? Ведь есть споры на сей счёт (<a href="https://habr.com/ru/articles/570716/">«Процессор Эльбрус — почему это тупик для развития отечественной линейки general-purpose CPU»</a> и <a href="https://habr.com/ru/articles/575302/">«Процессор Эльбрус — почему статья о тупике несостоятельна»</a>), и я не знаю, кто прав в этом споре.<br />
<br />
Есть вариант сделать ставку на RISC-V, ибо эта архитектура открыта. И тут возможна хитрость: «если мафию победить невозможно, то нужно её возглавить». Известный специалист <a href="https://habr.com/ru/articles/833568/">Юрий Панчул пишет</a>:<br />
<blockquote>Путь России, Китая и другой зарождающейся мировой альтернативы — это линуксные компьютеры на RISC-V. Там можно легально, конструктивно и эффективно использовать открытые решения со всего мира, на основе которых строить свои.</blockquote>
Впрочем, и архитектуру «Эльбруса» тоже можно сделать открытой, как у RISC-V, и вроде бы делаются шаги в этом направлении.<br />
<br />
Так что моё мнение такое: пусть принимают решение специалисты, а я с ним соглашусь. Главное, чтобы потом не было двоемыслия, что иностранные языки программирования на отечественных процессорах — это хорошо, а вот наоборот — это плохо.<br />
<hr />
2024-08-09 <i><b>alextretyak</b></i><br />
<br />
<b>Автор сайта</b><br />
Мой вопрос был немного не про это.<br />
Вот смотрите. Всюду нас окружают компьютеры с процессорами архитектуры x86: дома, на работе, практически на всех серверах для хостинга (в т.ч. хостинга этого сайта). Вы верите в то, что это положение можно как-то изменить? (Речь не о <!--[[[военке или ]]]-->каких-то нишевых/узких применениях, а про массовую вычислительную технику.)<br />
<br />
<!--[[[Даже могучий ARM сколько лет пытается залезть в нишу серверных процессоров, и есть даже ПО для виртуализации, но почему-то ]]]--><!--[[[Да, кроме x86 (x86-64) есть ещё ARM, но в нише ПК/ноутбуков его доля крайне мала, в то время как x86-процессоров *‘уже’ произведено и работает много миллиардов штук.]]]-->Да, возможно ARM или RISC-V когда-то в будущем смогут потеснить x86 в нише ПК/ноутбуков, но сейчас, на данный момент, x86-процессоров <b>уже</b> произведено и работает много миллиардов штук. И в ближайшие годы (а скорее десятилетия) <!--[[[эта ситуация точно не изменится]]]-->архитектура x86 продолжит быть доминирующей в этой нише.<br />
<br />
Но если взять любой процессор Intel x86 и стереть с его корпуса маркировку, то что от него останется американского?<br />
<br />
Процессору всё равно, на каком языке говорили его разработчики. Он просто слепо исполняет <!--[[[заданные инструкции]]]--><!--[[[данные ему]]]-->указанные машинные команды. Причём команды эти представлены в двоичном коде и процессор понятия не имеет о языках ассемблера, о языках высокого уровня или об операционной системе, использующей его возможности.<br />
<!--[[[
И если следовать такой логике, то x86-процессоры не являются американской является документация на процессор.
]]]--><br />
И чем вообще «русский» процессор принципиально может отличаться от существующих иностранных? Не получится ли в итоге плюс-минус то же самое (регистры, кэш-память, типичный набор инструкций — mov/load/store, сложение, вычитание, умножение, сдвиги и т.д.)?<br />
К тому же, в разработке процессоров x86 <!--[[[участвовало]]]-->принимало участие множество людей самых разных национальностей. И если что и является американским в x86-процессорах, так это их <i>документация</i>.<br />
<br />
И вот в этой области, как раз таки у нас есть реальная возможность «перехватить инициативу». В каком смысле?<br />
По <a href="https://habr.com/ru/companies/huawei/articles/503194/">словам</a> одного из бывших сотрудников Intel:<br />
<blockquote>из существующей X86 ISA сейчас используется около 20%. Остальное – пережитки прошлого.</blockquote>
Официальная документация от Intel по архитектуре x86/x86-64 — это огромный талмуд на 5000 страниц, который <!--[[[читать/]]]-->изучать полностью нет никакого смысла, т.к. большая часть информации в нём уже не актуальна. И сейчас очень не хватает именно <i>актуальной</i> документации по современным процессорам архитектуры x86. Причём документации в удобной форме, а не в виде архаичного pdf-документа, в котором затруднительно осуществлять поиск нужной информации и который распечатывать всё равно никто не будет.<br />
<br />
Собственно, я считаю, что начинать нужно именно с такой документации. В процессе работы над которой следует обозначить устаревшие возможности <!--[[[процессоров]]]-->архитектуры x86, а также новые возможности, которые не используются в современном ПО и, следовательно, также являются неактуальными. (Для оценки актуальности <!--[[[возможностей процессора]]]-->тех или иных команд архитектуры x86 можно просто проанализировать машинный код всего популярного ПО <span class="sq"><span class="sq_brackets">[</span>даже исходники иметь не обязательно — есть дизассемблер<span class="sq_brackets">]</span></span> <!--[[[—]]]-->и если какие-то <!--[[[инструкции/]]]-->команды вообще нигде не используются, значит они неактуальны.)<br />
Более того, такая документация сможет помочь не только для разработки ПО под x86, но и для проектирования новых процессоров (как отечественных, так и не очень). <!--[[[За прошедшие десятилетия Intel добавила в x86 очень много [[[новых]]] инструкций, большая часть которых так и не нашла своего применения (можно посмотреть хотя бы на AVX-512[[[создаётся впечатление, что AVX-512 не нашёл применения, хотя я имел в виду некоторые команды из AVX-512]]]). Из чего можно сделать вывод, что в новые процессоры такие инструкции включать не имеет смысла.]]]-->Т.к. в зависимости от «нужности»/частоты использования инструкции зависит её реализация в процессоре.<br />
<br />
И если такую документацию вести сразу на русском языке <span class="sq"><span class="sq_brackets">[</span>ну или параллельно на английском и на русском<span class="sq_brackets">]</span></span>, тогда неизбежно встаёт вопрос и о... русском языке ассемблера.<br />
Хотя этот вопрос уже неоднократно <a href="http://www.compiler.su/russkij-yazyk-i-programmirovanie.php#35">поднимался</a>, всерьёз за реализацию такого проекта никто ещё не брался (речь про реально работающий генератор машинного кода х86-64 из русского ассемблера с поддержкой современных расширений набора команд <span class="sq"><span class="sq_brackets">[</span>хотя бы SSE/AVX2<span class="sq_brackets">]</span></span>). И у меня есть некоторые соображения<!--[[[,]]]--> <!--[[[как организовать такой проект]]]-->на этот счёт. В течение месяца я планирую <!--[[[выложить/]]]-->опубликовать соответствующую статью на Хабре <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">статья <!--[[[уже]]]--> <a href="https://habr.com/ru/articles/840070/">опубликована</a></span><span class="cu_brackets_b">}</span></span>.<br />
<hr />
2024-08-09 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Вы верите в то, что это положение можно как-то изменить?</blockquote>
Оно уже давно меняется, при этом без нашего участия. Операционных систем Android установлено больше, чем Windows. А работает Android на ARM. Фирма Apple скакала сперва с Motorola на PowerPC, потом на Intel, потом на ARM. И делала это достаточно безболезненно! Потому что мощность нового процессора позволяла эмулировать старый процессор без потери скорости.<br />
<br />
Linux работает на многих платформах, ему, по сути, всё равно на чём работать. Остаётся Windows. Но индийский руководитель Microsoft заявил, что у его компании больше нет религии. То есть они теперь всеядны. Так что свято место лидирующей архитектуры пустым не будет. Тем более, что x86 не оптимальна и объективно проигрывает в некоторых вещах , типа плотности команд (машинный код для реализации одного и того же длиннее, чем у конкурентов), и положение неисправимо.<br />
<br />
Но x86 не исчезнет, просто доля сожмётся. Ведь PowerPC до сих пор применяются, например в истребителях F-22 или F35. X86 останется в ещё больших количествах, ибо исторический багаж очень велик.<br />
<br />
Ну чисто субъективное ощущение, что скорость смены эпох возрастает.<br />
<br />
<blockquote>в зависимости от «нужности»/частоты использования инструкции зависит её реализация в процессоре.</blockquote>
При разработке отечественной архитектуры «Самсон» самые частые команды специально сделали однобайтовыми. Вот это я понимаю, вот это борьба за оптимальность.<br />
<br />
<blockquote>всерьёз за реализацию такого проекта никто ещё не брался</blockquote>
Разработка Д.Ю.Караваева — это не только суверенный компилятор PL/1, но и суверенный ассемблер x86. Просто он не русифицирован. Но лично я не наблюдал интереса к русификации ассемблера. О чём неоднократно писал.<!--[[[

> В течение месяца я планирую опубликовать соответствующую статью на Хабре.
Ждём-с [[[(]]]:) Будет интересно почитать. Вы ещё одну статью обещали — сравнение моделей итераторов в различных языках программирования.]]]--><br />
<hr />
2024-08-11 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Оно уже давно меняется</blockquote>
Не соглашусь.<br />
Ничего принципиально не меняется. Только <i>добавляется</i>. А это большая разница.<br />
<br />
<!--[[[И я говорил именно про изменения в]]]-->В <!--[[[нише/]]]-->существующей нише ПК/ноутбуков/серверов за последние несколько <i>десятилетий</i> <!--[[[практически не было изменений в относительной доле x86-процессоров]]]-->принципиальных изменений не было (x86 продолжает доминировать), а рынок смартфонов/планшетов — это <b>новая</b> <!--[[[рынок/]]]-->ниша. Которые <span class="sq"><span class="sq_brackets">[</span>смартфоны/планшеты<span class="sq_brackets">]</span></span> лично я к компьютерам не отношу <!--[[[совсем/]]]-->вообще. Почему? А вы попробуйте попрограммировать на Android<!--[[[ (на чём-то кроме Java и Kotlin)]]]-->-устройстве. Попробуйте подключить к смартфону/планшету мышь, клавиатуру, монитор (а лучше два) и настроить IDE для комфортной работы. И попробуйте установить например Python. С официального сайта, правда, не получится, т.к. Android <i>вообще не упоминается</i> в списке неофициально поддерживаемых платформ даже на странице ‘Python for Other Platforms’.<br />
Проблема в том, что Android — это не Linux. И её владелец — компания Google — вообще не заинтересована в поддержке разработчиков нативных приложений под свою систему и в превращении смартфонов в мобильное Arm64-рабочее место. И хотя производительности ARM-процессора современного смартфона вполне <!--[[[себе]]]--> достаточно для работы тяжёлых программ (в т.ч. и IDE), получить пользовательский опыт аналогичный ПК с x86 никак не получится<!--[[[ [взять хотя бы отладку]]]]-->. Т.е.<!--[[[ архитектура]]]--> ARM тут оказалась в заложниках политики Google.<br />
<br />
Что касается продукции Apple. Она ориентирована на свою особую аудиторию фанат<!--[[[ик]]]-->ов и, как вы верно упомянули, Apple удавалось успешно перепрыгивать с одной архитектуры на другую много раз.<!--[[[ Apple — это религия.]]]--> И я бы не стал <!--[[[вообще ]]]--><!--[[[учитывать]]]-->причислять какие-либо процессоры в устройствах Apple к ARM-процессорам. Уже сейчас их "ARM-based" чипы поддерживают некоторые недокументированные инструкции (например Apple <a href="https://github.com/corsix/amx">AMX</a>), которые никто кроме Apple, очевидно, добавлять в свои процессоры не будет. И дальше, я полагаю, расхождение с ARM будет только увеличиваться. Не исключено, что Apple вообще соорудит какую-то новую архитектуру специально под себя.<br />
<br />
Таким образом, ARM занимает свою отдельную нишу и <!--[[[никак не [[[пересекается с]]]
Поэтому ]]]-->единственная область, в которой архитектура ARM может потеснить x86 <!--[[[в обозримом будущем ]]]-->— это рынок серверов. Но и здесь изменения происходят очень<!--[[[-очень]]]--> медленно.<br />
В <a href="https://xakep.ru/2014/08/06/arm-na-serverah/[[[" title="<- google:‘сколько произведено &quot;миллиардов процессоров&quot; x86’]]]">новости</a> от 2014 года было сказано:<br />
<blockquote>По мне­нию AMD, через пять лет 25% всех сер­веров в мире будут работать на плат­форме ARM.</blockquote>
Вот прошло уже 10 лет, и по факту доля ARM на серверном рынке <a href="https://www.theregister.com/2023/08/08/amazon_arm_servers/[[[" title="<- google:‘arm server market share’]]]">составляет</a> 10%, причём больше половины из них обслуживают Amazon Web Services. Т.е. несмотря на значительно большую энергоэффективность — в 2-4 раза<!--[[[
>[https://blog.cloudflare.com/neon-is-the-new-black <- google:‘arm neon registers’]:‘Centriq is now 1.3 times faster while also 6.5 times more power efficient.’
>[https://habr.com/ru/companies/servermall/articles/680424/ <- google:‘x86 density’]:‘2018 ГОД...производительность на ватт — 1,180 pts.... производительность на ватт — 384 pts.’
]]]--> по сравнению с Intel Xeon — ARM-сервера до сих пор используются лишь в каких-то специализированных решениях, где серверный софт специально пишут под ARM.<br />
<br />
<blockquote>Но x86 не исчезнет, просто доля сожмётся.</blockquote>
Так то оно так. Вот только с такими темпами этот процесс растянется на много десятилетий. И что нам делать всё это время, просто ждать?<br />
Я предлагаю ориентироваться на текущее положение вещей (т.к. не похоже, что оно может принципиально измениться в ближайшем будущем) и разрабатывать своё ПО <!--[[[именно]]]--> для сокращённой версии x86-64 (содержащей только актуальные возможности архитектуры).<br />
Хотя и про поддержку ARM64 забывать не следует. Но для полноценного использования ARM-процессоров (в работе) необходимо будет разработать или доработать <!--[[[отдельную]]]-->специальную операционную систему, т.к. <!--[[[пытаться перенести ]]]-->Android для профессиональной работы не годится.<!--[[[

> типа плотности команд
С плотностью команд, кстати, у x86 всё ‘не так плохо’[https://www.bitsnbites.eu/cisc-vs-risc-code-density/ <- google:‘x86 code density’]. Но особого смысла обсуждать это я не вижу, т.к. это не самый важный показатель.]]]--><br />
<hr />
2024-08-11 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>Ничего принципиально не меняется. Только добавляется... x86 продолжает доминировать... рынок смартфонов/планшетов — это новая ниша.</blockquote>
Ой, не скажите. Знаю многих людей, которые не айтишники и которые перестали обновлять свои домашние компьютеры раз в несколько лет. Старые компьютеры у них пылятся без дела, а новые не нужны, потому что есть телефон, а в нём есть всё, что нужно. А полазить в Интернете можно и с телевизора лёжа на диване.<br />
<br />
Теперь про тех, кого знаю и кто использует компьютеры на работе. Один разработчик на PHP поставил себе Linux на ноутбук и тащится от того, что с Windows он бы тормозил и пришлось бы покупать новый. А вот с Linux он весьма шустрый. Раз у него стоит Linux и ему нужен PHP, то в следующий раз он опять возьмёт ноутбук под Linux, а вот какой у него будет процессор — большой вопрос. Очень даже может быть, что ARM или RISC-V. Ведь главное — соотношение цена/качество.<br />
<br />
Знаю другого разработчика на Go. Ему на работе выдали ноутбук Apple. Не потому, что он фанат, а просто выдали и всё. Он ему понравился. А ведь в нём нет x86.<br />
<br />
Ещё из того, что знаю. На одном предприятии работникам в цехах на телефоны поставили приложение, в котором они получают производственные задания и ставят отметки об их выполнении. За компьютеры садятся только бригадиры, которым нужна только 1С и почта в браузере. Если 1С переведут на ARM или RISC-V (а это обязательно когда-нибудь случится), то надо только дождаться предложения на поставку компьютеров с такими процессорами. Так что не только домашние компьютеры x86 уходят из жизни.<br />
<br />
<blockquote>не стал причислять какие-либо процессоры в устройствах Apple к ARM-процессорам. Уже сейчас их "ARM-based" чипы поддерживают некоторые недокументированные инструкции... полагаю, расхождение с ARM будет только увеличиваться.</blockquote>
Это не важно для ответа на вопрос: «перейдёт ли мир на что-то не x86 или не перейдёт». Что ARM, что модифицированный ARM не являются x86 и это главное.<br />
<br />
<blockquote>прошло уже 10 лет, и по факту доля ARM на серверном рынке составляет 10%.</blockquote>
Так потому что нет предложения. Зайдите на сайт какого-нибудь компьютерного магазина и Вы не увидите в каталоге компьютеров или серверов с ARM. А когда появится, то покупатели учтут соотношение цена/качество.<br />
<br />
<blockquote>Я предлагаю ориентироваться на текущее положение вещей... и разрабатывать своё ПО для сокращённой версии x86-64.</blockquote>
Я бы отдал приоритет генерации кода во что-то, не сильно зависимое от платформы. В Си или LLVM. К сожалению, в последнюю не дадут внести поддержку «Эльбрусов» (или уже не дали). Поэтому неплохо бы задуматься об <b>отечественном аналоге LLVM</b>. И это, на мой взгляд, куда <b>актуальнее, нежели русский ассемблер</b>. Думаю, <b>Вежливому Лису</b> стоит учесть это в своих планах. Он ведь любит планировать.<br />
<br />
<blockquote>для полноценного использования ARM-процессоров (в работе) необходимо будет разработать или доработать специальную операционную систему</blockquote>
Зачем? Есть масса версий Linux, которые работают с ARM. И зарубежные, и отечественные. ОС от Касперского работает на x86_64, но написана она не на ассемблере, поэтому вполне переписывается и на другие платформы. Да и стоит ли ориентироваться на ARM? Всё равно не дадут законно производить. Лучше сразу строить планы на RISC-V. И про «Эльбрус» не забываем.<br />
<hr />
2024-08-12 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Ой, не скажите. Знаю многих людей, которые не айтишники</blockquote>
<!--[[[Да]]]-->Вот, но<!--[[[а]]]--> я-то говорил<!--[[[ как раз]]]--> об айтишниках.<br />
Но <!--[[[хотя]]]--> ладно, не буду спорить. Критерии наблюдаемых «изменений» бывают разные. Окружение у нас тоже очень разное. Я говорил про свой опыт, вы — про свой. И хотя компьютер я тоже давно не обновлял, но без дела у меня пылятся планшет и эл.книга <span class="sq"><span class="sq_brackets">[</span>с процессорами ARM, как можно догадаться<span class="sq_brackets">]</span></span>. За большим монитором работать с информацией <span class="sq"><span class="sq_brackets">[</span>особенно, писать статьи<span class="sq_brackets">]</span></span> гораздо удобнее.<br />
<br />
<blockquote>отечественном аналоге LLVM. И это, на мой взгляд, куда актуальнее, нежели русский ассемблер</blockquote>
Допустим, что и правда актуальнее. Вот только это не отменяет вопрос: а выхлоп этого «отечественного аналога LLVM» под архитектуру x86 будет на каком языке? Сразу в машинном коде? А если где-то в одном битике ошибка и вместо <!--[[[кода операции]]]-->машинного кода D1'E8 (инструкция <b>shr eax, 1</b>) сгенерировался D1'F8 (инструкция <b>sar eax, 1</b>), и <!--[[[код]]]-->полученная программа вроде бы в целом работает (т.к. обе эти инструкции осуществляют сдвиг вправо на 1 бит), но иногда ведёт себя странно. Как <!--[[[такое отлаживать]]]-->находить в сгенерированном коде такие ошибки? Даже ассемблер разглядывать — то ещё удовольствие. Но машинный код x86 — это вообще ужас-ужас. <!--[[[Различным вариантам]]]-->Той же <!--[[[инструкции/]]]-->мнемонике <b>shr</b> соответствуют 6 различных кодов операции в зависимости от того, какие операнды она принимает (<a href="https://www.felixcloutier.com/x86/sal:sar:shl:shr">https://www.felixcloutier.com/x86/sal:sar:shl:shr</a>). Разработчики компилятора должны это наизусть заучивать?<br />
Нет, всё-таки без языка ассемблера никак.<br />
Тем более, что вы сами <a href="http://ruscomp.bb24.ru/viewtopic.php?id=42">предлагали</a> идею в верном направлении (обозначать машинные операции не сокращениями из букв, а символами). Осталось только эту идею более тщательно проработать. Чем я, кстати, сейчас и занимаюсь. <!--[[[Результаты работы выложу в виде статьи]]]--><span class="sq"><span class="sq_brackets">[</span>Этому, собственно, и будет посвящена новая статья, о которой я здесь уже упоминал.<span class="sq_brackets">]</span></span><br />
<hr />
2024-08-12 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>а выхлоп этого «отечественного аналога LLVM» под архитектуру x86 будет на каком языке? Сразу в машинном коде?</blockquote>
С одной стороны, если сразу в машинный код, то это и быстрее, и компилятор проще. Но в целях отладки всё-таки лучше с промежуточным этапом — текстом на ассемблере.<br />
<br />
<blockquote>Как находить в сгенерированном коде такие ошибки?<br />
Разработчики компилятора должны это наизусть заучивать?</blockquote>
Чтобы разработчик компилятора из своего языка не мучился с такими проблемами, ему лучше компилировать в аналог LLVM. А вот разработчик этого аналога должен вовсю постараться, чтобы не было путаницы между «shr» и «sar». Он должен сделать работу качественно.<br />
<br />
<blockquote>вы сами предлагали... обозначать машинные операции не сокращениями из букв, а символами</blockquote>
Если бы я это делал заново, то и сейчас поступил так же, хотелось языку ассемблера привить какие-то черты от ЯВУ. Вспомнил некоторые черты языка ассемблера, который разрабатывал Е.А Зуев. Что-то оттуда взял. Но у «паскалиста» Зуева ассемблер получился не такой, как у меня, «сишника».<br />
<br />
Но я говорил о невостребованности русского ассемблера не просто так. Никто за 10 лет не поинтересовался моим ассемблером. А русификатор Си скачивали более 1600 раз.<br />
<br />
В отечественном LLVM я первый был бы заинтересован, если бы он был качественный. Это ж сколько головной боли он бы снимал. Между прочим, у нас хорошая отечественная школа в этой области. Были в прошлом проекты языков Эпсилон и Сигма, своего рода «ассемблеры высокого уровня».<br />
<hr />
2024-09-02 <i><b>alextretyak</b></i><br />
<br />
<blockquote>разработчик этого аналога должен вовсю постараться, чтобы не было путаницы между «shr» и «sar». Он должен сделать работу качественно.</blockquote>
<!--[[[Это верно. Вот только «отечественный компилятор», когда таковой будет создан, будет поставляться вместе с «отечественным аналогом LLVM»[[[ неразрывно, т.к. по отдельности]]]. И пользователям (т.е. прикладным программистам) отечественного компилятора будет всё-равно кто ошибся — разработчик компилятора или разработчик «отечественного аналога LLVM». Если у них неправильно работает код, они не будут разбираться, на каком этапе генерации машинного кода была допущена ошибка, а просто отправят баг-репорт разработчику компилятора.
]]]--><!--[[[
Но д]]]-->Даже если «отечественный аналог LLVM» будет работать идеально без ошибок, то всё равно иногда требуется посмотреть ассемблерный листинг с целью анализа итогового сгенерированного машинного кода:<br />
<ul>
<li>оценить насколько эффективно компилятор выполнил встраивание функций, какие переменные поместил в регистры, как часто происходит обращение к памяти и прочее;</li>
<li>сравнить качество оптимизации одинакового исходного кода на языке высокого уровня (например C++) различными компиляторами — например я <!--[[[частенько/]]]-->нередко сравниваю ассемблерный код, сгенерированный Clang-ом (который использует LLVM) с кодом, сгенерированным GCC и MSVC (которые LLVM не используют).</li>
</ul>
</div>
</body>
</html>