Н‘‘Шестнадцатиричные и двоичные константы (ссылка на статью)’[http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php]’

Комментарии:
---
2019-08-12 ~‘*‘alextretyak’’

Идеи занятные (и с кавычками и со скобками)...

В свою очередь, предлагаю [[[рассмотреть/]]]посмотреть на [[[мой ]]][[[вариант/]]]‘способ записи шестнадцатеричных чисел/констант в языке программирования 11l’[http://11l-lang.org/doc/ru/integer-literals].
[[[
А не думал ли кто-нибудь [[[о красивом синтаксисе]]]об обратной операции? [{Речь о конвертировании/преобразовании значения числовой переменной в произвольную систему счисления. Согласен, что она требуется гораздо реже и специальный синтаксис в языке для неё выделять — это излишество, но вот функцию добавить в стандартную библиотеку языка — почему бы и нет {на данный момент из популярных языков программирования такая функция есть лишь в Си (itoa), и то она нестандартна}.}]
А также о [[[синтаксисе]]]задаче преобразования числа из любой произвольной системы счисления в любую произвольную. Удивительно, но ни в одном языке программирования нет встроенной функции для такого преобразования.
](такая возможность есть в Swift: `String(10, radix: 16)`; задача преобразования числа из любой произвольной системы счисления в любую произвольную также легко решается в Swift: `String(Int("...", radix: FROM_RADIX)!, radix: TO_RADIX)`)]]
> Иногда ещё 10, но в особых случаях.
Эм... не совсем понял данное предложение\sentence. [[[ИМХО]]]Насколько я вижу по реальным проектам, десятичная система счисления является самой востребованной в проектах любого рода. Затем идёт шестнадцатеричная[[[, а]]]. Двоичная и восьмеричная же практически не используются. [Или тут речь о явном указании на десятичную систему? Т.е. о записи 10'123 вместо просто 123? Такое, конечно, не востребовано, но имхо это просто какая-то глупость {это всё равно что добавить в язык префикс `0d` и писать 0d123 вместо 123}.]

Кстати, [[[я когда выбирал , смотрел примеры реальных программ (на Python и C/C++)]]]по хорошему, нужно смотреть примеры реальных проектов/программ, чтобы понять насколько будет удачно/красиво выглядеть тот или иной вариант синтаксиса. {Кстати, давно у меня зреет идея [[[мега/]]]большого проекта по формированию базы хорошего/красивого кода (в т.ч. псевдокода). Не интересует ли автора сайта работа в этом направлении, в формировании такой базы? [А то мне и самому, признаться, надоело уже быть голословным — хочется бац, и дать ссылку на результат анализа всего хорошего кода на планете, "результат" — в смысле, например, процентное соотношение используемых числовых констант различных систем счисления.]}
---
2019-08-14 ~‘*‘Автор сайта’’

Не понятно, что у Вас является признаком шестнадцатеричного числа. Апостроф? Нет, иначе бы 255\\\'000 не было бы десятичным числом.
> Кстати, по хорошему, нужно смотреть примеры реальных проектов/программ, чтобы понять насколько будет удачно/красиво выглядеть тот или иной вариант синтаксиса. {Кстати, давно у меня зреет идея большого проекта по формированию базы хорошего/красивого кода (в т.ч. псевдокода). Не интересует ли автора сайта работа в этом направлении, в формировании такой базы? ...}
Читал я Вашу дискуссию с читателями статьи «Каркас нового языка программирования». Вам заметили, что предлагать новый язык программирования имеет смысл, если в этом языке есть новые концепции. Вы ответили, что желание улучшить синтаксис достаточно для того, что новый язык имел право на существование.

В принципе, с Вами можно было бы согласиться, вот только «пространства» для улучшения синтаксиса всё меньше и меньше. Число комбинаций одного и того же набора символов ограничено. Так что без новых концепций новым языкам трудно пробиться.

Вот вам пример лаконичного и красивого синтаксиса. Допустим, в нижеприведённом коде переменной «текущая координата» присвоено значение функции, читающей положение курсора мыши:
#‘
текущие координаты = читать координаты курсора ()
’
А если мы хотим установить новые координаты? Обычно это делается так
#‘
записать координаты курсора (новые координаты)
’
Если язык поддерживает перезагрузку имён функций, то это может выглядеть короче:
#‘
текущие координаты = координаты курсора ()  // чтение
координаты курсора (новые координаты)       // запись
’
Выше две разных функции с одинаковым именем имеют разную семантику. Моя идея заключается в том, что эти одноимённые функции могут менять семантику в зависимости от местоположения:
#‘
текущие координаты = координаты курсора ()  // чтение
координаты курсора () = новые координаты    // запись
’
---
2019-08-15 ~‘*‘alextretyak’’

> Непонятно, что у Вас является признаком шестнадцатеричного числа. Апостроф? Нет, иначе бы 255\\\'000 не было бы десятичным числом.
3 обратных слэша тут лишние, верно?
А признак очень простой — *‘количество’ цифр, разделённых апострофом. Если 1, 2 или 4, тогда число шестнадцатеричное. Если 3, либо если нет разделителей[[[/апострофов]]], то число десятичное. Если оканчивается на ‘b’ или русскую ‘д’, тогда двоичное. Если оканчивается на ‘o’, тогда восьмеричное.

Но благодарю за Вашу реакцию — я подумаю над тем, чтобы [[[дописать/]]]добавить это пояснение в документацию языка.

> Читал я Вашу дискуссию с читателями статьи «Каркас нового языка программирования»...
Ну, со времени написания той статьи много воды утекло.[[[ С тех пор, я больше структурировал информацию, написал документацию к языку, пересмотрел своё]]] [И с тех пор я [[[по многим вопросам]]]во многом поменял своё мнение, в частности, я решил делать больше упор на анализ существующих языков программирования, а также на формирование рационального/логического обоснования для элементов синтаксиса языка[[[ программирования]]], нежели на массовое [и в [[[подавляющем ]]]большинстве случаев — не аргументированное] мнение по тем или иным вопросам, так как мнение любого человека слишком уж завязано на его привычки, и непривычные вещи априори будут [[[приниматься со скрипом]]]восприниматься с отторжением.]

Предлагаю познакомиться с новой статьёй {теперь статью можно скачать отсюда[http://forum.11l-lang.org/threads/Разработка-когнитивно-эргономического-синтаксиса-для-нового-аппаратно-ориентированного-языка-программирования.8/#post-11]}, черновик которой я отправил Вам на почту [можете высказать свои соображения по [[[данной/]]]этой статье здесь же (если это будет уместно), или прошу на форуме[http://forum.11l-lang.org/threads/Разработка-когнитивно-эргономического-синтаксиса-для-нового-аппаратно-ориентированного-языка-программирования.8/] (можете написать и эл. письмо, но предупреждаю заранее, что я оставляю за собой право разместить его текст [или его часть] на форуме[[[время кулуарных обсуждений прошло, только открытые дискуссии!]]])].

> вот только «пространства» для улучшения синтаксиса всё меньше и меньше. ... Так что без новых концепций новым языкам трудно пробиться.
Полностью с Вами согласен.
Вот только число новых/нереализованных значимых/существенных концепций, по-моему, ‘уже близко к [абсолютному] нулю’/‘ещё меньше, чем улучшений синтаксиса’.
Поэтому [[[данный/]]]новый язык [в идеале] должен включить в себя все оставшиеся удачные/подходящие нереализованные идеи по улучшению синтаксиса.[[[ И это реально трудная задача. [[[Но улучшить/‘создать новую’ концепцию — задача нереально трудная.]]]]]] А также взять концепции, лучшие из существующих[[[ (по моему мнению, это смесь С++, Rust[[[‘lifetimes’]]] и Swift[[[‘ARC, `&`’]]] [[а также щепотка Go[[[‘-‘concurrency’[https://habr.com/ru/post/464741/]:‘Golang is well known for the coroutine’’]]], D[[[‘templates/metaprogramming’]]], Nim[[[‘AST based macroses, metaprogramming’]]], Nemerle[[[‘type params infered from usage’]]], C# и Kotlin[[[‘как улучшение Java’]]]/Java]])]]].[[[ В данный момент её можно выразить словами Juarez: ]]]

> Моя идея заключается в том, что эти одноимённые функции могут менять семантику в зависимости от местоположения
Так ведь это уже есть в C++[[[ Да в C++ всё уже есть. Он такой крутой, что даже/уже не интересно. :)(:]]]. Оператор `[]` в `std::vector<bool>` (который на самом деле не массив из `bool`, а битовый массив) возвращает прокси объект, который можно читать (за счёт [[[перегруженного/]]]перегрузки operator `bool`), и в который можно писать (за счёт перегрузки оператора [[[равенства/]]]равно). Чтобы понять как устроен оператор `[]` в `std::vector<bool>` изнутри, можно [[[по шагам ]‘по шагам — это F10, а тут имеется в виду F11 (а впрочем, F11 в MSVC называется ‘Шаг с заходом’ — т.е. тоже ‘шаг’ как-никак)’]]по шагам пройти в отладчике такой код:
#(C++)‘
std::vector<bool> v(1);
v[0] = true;
bool b = v[0];
’

И хочу ещё [[[сделать замечание]]]высказаться [[[на тему]]]по поводу возможности разделения идентификаторов пробелом. Лично мне, [[[также ]]]как и автору, тоже не нравится, [[[как/]]]что символы подчёркивания бросаются в глаза в именах. Но я вижу другое решение этой проблемы — в IDE/‘среде разработки’ отображать символы подчёркивания в идентификаторах немного по-другому, в таком виде, который не так бросается в глаза:
Р‘https://habrastorage.org/webt/gw/kz/es/gwkzes4_vqnxphhxqspvgzitw-i.png’[[[
nesting_level (стандартный Courier New 10)

nesting_level (подчёркивание приподнято на 2 пикселя и сокращено слева и справа на 1 пиксель)

nesting_level (аналогично предыдущему, только подчёркивание полупрозрачно (opacity: 0.5))
]]][[[P‘./[c.txt]/9.08.14/nesting_level.png’]]][[[Если автор опять заменит это на текст ссылки на картинку, попрошу его: ‘А почему Вы не хотите заменять ссылки на картинку тегом <img src="ссылка-на-картинку" />? Она [эта картинка] ведь совсем небольшая. [[[И/]]]А руками копировать ссылку в адресную строку, чтобы посмотреть на [[[неё/]]]картинку, очень неудобно.’]]]

А если разрешить пробелы в идентификаторах, то, боюсь, [[[что будет конфликтовать]]]будет конфликт с ключевыми словами. Например, у меня в парсере есть переменная #‘type_name’. Но #‘type name’ написать уже не получится, так как это корректное объявление нового типа. [Впрочем, об этом автор уже писал[http://compiler.su/utilita-transliteratsii-russkogo-Si-SiPlusPlus-v-standartnyj.php], только там [[[был/]]]приводится пример с ‘int’.]

И к тому же, слышал ли автор[[[ну не люблю я обращение на Вы с большой буквы]]] что-нибудь про "poetry mode" в Ruby? Там можно написать такое:
#(Ruby)‘
puts value
# или даже так:
puts Integer value
’
что является сокращённой записью такого кода:
#(Ruby)‘
puts(value)
puts(Integer(value))
’

P.S. Кстати, синтаксис форматирования сообщений/отзывов, [[[выбранный/]]]разработанный автором, очень даже [[[недурен/]]]неплох[[[ [по мне так даже [[[чем-то/в чём-то ]]]лучше, чем Markdown!]]]].
Единственное, для текста программ я бы выбрал (##символы решётки##) или (0‘``обратные апострофы``’), а не знаки равенства (равенство больше подходит для обозначения двойного зачёркивания).[[[

P.P.S. И ещё маленькое замечание. Такая запись
(&#61;&#61;
код
&#61;&#61;)
не должна генерировать пустую строку вначале.[[[А то получается:
┌──────────────────┐
│                  │
│ код              │
└──────────────────┘
]]]]]]
---
2019-08-16 ~‘*‘Автор сайта’’

>‘alextretyak’:‘А признак очень простой — количество цифр’
Так признак, на мой взгляд, не так уж и прост. Но всё относительно. Вы субъективны в своих оценках, а я в своих. ~‘«Каждый пишет, как он слышит. Каждый слышит, как он дышит».’

По поводу статьи я выскажусь чуть позже. Просто пока что зреют мысли.

> число новых/нереализованных значимых/существенных концепций, по-моему, «уже близко к абсолютному нулю»
Не хотите ли Вы сказать, что уже ничто не ново, всё Вам настолько знакомо, что в каждом новом языке Вы видите отголоски старых?

> Так ведь это уже есть в C++.
Ну так приведите пример. Как я должен определить функцию `func`, чтобы я мог записать:
#‘
func() = 123;
’

Спрятать символ подчёркивания, чтобы он не так бросался в глаза... Зачем? Лучше, если программист увидит «честный» текст. Но пробелы внутри идентификаторов — это вызов, это головоломка для лексического/синтаксического анализа. И тут у каждого простого решения есть свои минусы.

> я бы выбрал (##символы решётки##)
Я думал ещё и об эргономике. Хотелось, чтобы символы форматирования были на обеих раскладках клавиатуры на одинаковых клавишах. Остался только «!», но это НЗ на тот случай, когда ещё что-то захочется.
---
2019-08-18 ~‘*‘alextretyak’’

> Не хотите ли Вы сказать, что уже ничто не ново
Ну... я бы немного по-другому сказал. Всё новое — довольно[[[/достаточно]]] спорно. Взять тот же Rust с его lifetimes/borrowing (я, кстати, до сих пор не могу найти пример хорошего кода на Rust, где эти lifetimes оправданны, [[[другими словами — я не понимаю, чем эта модель лучше C++]]]все приводимые примеры в статьях по Rust либо надуманны, либо их можно [[[спокойно/]]]легко переписать на C++ безо всяких lifetimes).[[[Или нововведения в C++ (привет ‘export import’).]]]

> всё Вам настолько знакомо, что в каждом новом языке Вы видите отголоски старых?
Отчасти и это тоже.
Но если посмотреть на эволюцию естественных языков, то можно заметить, например, что русский язык [[[почти]]]существенно не менялся уже более ста лет с реформы 1918 года, и практически/фактически не менялся с 1956 года. А с наступлением цифровой эпохи ни русский, ни английский, никакие другие естественные языки, скорее всего, меняться уже [[[практически ]]]не будут. И я боюсь, что языки программирования постигнет та же участь — [[[с некоторого момента]]]они "заморозятся" и их эволюция завершится (также как когда-то завершилась эволюция чисел [ведь, никто не будет спорить с тем, что числа больше не будут эволюционировать? и не только/просто числа, а язык математики, скорее всего, тоже не будет больше эволюционировать![[[ (кто не согласен — попробуйте привести новшества[?] в математике за последние лет 30[?])]]]]).

> Ну так приведите пример. Как я должен определить функцию `func`, чтобы я мог записать: `func() = 123;`
#(C++)‘
#include <iostream>

void func(int i) { std::cout << i; }

class Proxy
{
public:
    void operator=(int i) { func(i); }
    operator int() {
        int r;
        std::cin >> r;
        return r;
    }
};

Proxy func() { return Proxy(); }

int main()
{
    func() = 123;   // заменяется на func(123)
    int i = func(); // возвращает число из cin
}
’

> Хотелось, чтобы символы форматирования были на обеих раскладках клавиатуры на одинаковых клавишах.
А я использую AutoHotkey и у меня в обеих раскладках одинаковое поведение при наборе [[[спец]]]символов (например, Shift+2 — это всегда @, Alt+2 — это всегда кавычка ", Shift+3 — это всегда решётка #, а Alt+3 — это всегда № и т.д.).
Соответствующий скрипт можно посмотреть тут: [http://pqmarkup.org/ru] → «‘Советы по набору’/‘способы набора’ символов одиночных парных кавычек ‘ и ’...» → «В этот же файл-скрипт можно дополнительно ещё добавить:».

И, если честно, я считаю проблему переключения раскладок [[[— ]]]несколько надуманной. Также [[[как и]]]весьма сомнительным считаю чрезмерное стремление повысить скорость набора кода [речь про слепую печать и т.д.[[[т.д. — это [[[минимизация переключений раскладки](уже упоминается в этом предложении)]]макросы, горячие клавиши, автодополнение[‘это удобно само по себе, а не с целью повышения скорости набора’]]]]]. На первом месте должно быть *‘качество’ кода или текста, а не его количество. Причём я [[[зачастую]]] наблюдал[[[ именно]]] такую картину, что чем больше программист пишет кода, тем менее он качественный[[[не обижайся Заккер, но код Саши Котляра мне больше нравится]]].
Вот пример из Вашей же статьи[https://habr.com/ru/post/208474/]:
> Ховик Меликян приводит пример, когда программа из 80000 строк кода на Си++ и 55000 строк кода на VB заменялась 10 строками на шелл-скрипте.

И чтобы получить более качественный текст [[[сообщений]]][комментариев или писем], лично я использую два приёма:
1. Откладываю его отправку примерно на одни сутки[[[ [в течение этого срока подсознание наиболее[?] активно[?] присылает мысли по улучшению текста комментария]]]].
2. Периодически перечитываю этот текст. Суммарно получается больше 10 раз точно. Ну и к чему мне эта пресловутая скорость набора, если на ревью и обдумывание/придумывание[[[/составление]]] текста я трачу времени гораздо больше?

А что касается кириллицы в программировании, то, как можно видеть, например в языке КуМир ([http://bsosh6.shkola.hc.ru/teachers_pashut/tuzov/kumir/manual.pdf]) хотя и используются кириллические ключевые слова, но математические функции оставлены на английском (например, sqrt или sin[[[или sin — на уроках математики мы же пишем `sin x`, а не `син х` и ничего, к тому же это слово не английское, а латинское[[[[[а для sqrt можно ввести синоним `квкорень`]]]]]]]] {на уроках математики мы же пишем ~‘sin x’, а не ~‘син х’ и ничего}). И я считаю это [[[правильным/]]]оправданным.

>‘... который не так бросается в глаза:
https://habrastorage.org/webt/gw/kz/es/gwkzes4_vqnxphhxqspvgzitw-i.png’
А почему Вы не хотите заменять ссылку на картинку тегом <img src="ссылка-на-картинку" />? Она [эта картинка] ведь совсем небольшая. [[[И/]]]А руками копировать ссылку в адресную строку, чтобы посмотреть на [[[неё/]]]картинку, очень неудобно.
---

~‘...Прошло 5 с половиной лет...’

---
2025-03-16 ~‘*‘Сергей’’

Странно, что не рассмотрены буквы АБВГДЕ. Азбучный порядок очень важен, чтобы быстро в уме переводить шестнадцатеричные числа в десятичные и обратно и считать шестнадцатеричными.
---
2025-03-17 ~‘*‘Автор сайта’’

Этот вариант рассматривался, но Вы, видимо, забыли прочитать текст статьи выше:
> «abcdef» -> «абвгде». Русская «В» и «Е» имеют схожие по начертанию латинские «B» и «E», но имеют разный код. Звучащие одинаково на слух «Д» и «D» тоже имеют разный код. Это потенциальный источник путаницы, этого нельзя допустить.
Это же мина замедленного действия. Немалый процент тех, кто привык к существующим языкам, будут переносить свои привычки в мир кириллического программирования. Ещё один момент: на сегодняшний день нет ни традиции написания шестнадцатеричных констант на кириллице, ни ГОСТов. И пока нет общепринятых стандартов де-факто, то эти стандарты устанавливают первопроходцы.
---
2025-03-20 ~‘*‘alextretyak’’
[[[Недавно проходил медкомиссию, и мне нужно было сделать копию результатов рентгенологического исследования. Спросил терапевта: «а где печать?» Она ответила, что теперь печати нет, т.к. документ подписан электронной подписью. С удивлением обнаружил, что в этой электронной подписи в цифрах используются латинские буквы.
]]]
> на сегодняшний день нет ни традиции написания шестнадцатеричных констант на кириллице, ни ГОСТов.
Отдельного ГОСТа по написанию шестнадцатеричных чисел действительно нет. Но в уже имеющихся современных ГОСТах для написания таких чисел [[[как правило]]] используются латинские A-F:
‘ГОСТ Р 54521-2011’[https://meganorm.ru/Data2/1/4293792/4293792019.pdf <- google:‘гост шестнадцатеричные цифры’] — см. Приложение А. Шестнадцатеричные коды символов (стр. 29).
‘ГОСТ 34.11-2018 (стр. 9)’[https://protect.gost.ru/v.aspx?control=8&baseC=-1&page=0&month=-1&year=-1&search=&RegNum=1&DocOnPageCount=15&id=224241&pageK=28E2F5A5-1518-4FD3-A4DF-4813AC3B0016 <- https://protect.gost.ru/v.aspx?control=8&baseC=-1&page=0&month=-1&year=-1&search=&RegNum=1&DocOnPageCount=15&id=224241 <- https://protect.gost.ru/v.aspx?control=7&id=232143 <- https://ru.wikipedia.org/wiki/Стрибог_(хеш-функция) <= https://ru.wikipedia.org/wiki/ГОСТ_Р_34.11-2012 <- https://ru.wikipedia.org/wiki/ГОСТ_Р_34.11-94 <- google:‘гост шестнадцатеричные цифры’]

Также в документах на русском языке, подписанных электронной подписью, [[[сама цифровая подпись использует]]]при записи цифр сертификата используются латинские A-F:
‘Графическое отображение ЭП. (штамп) - УЦ АЙТИКОМ’[https://uc-itcom.ru/help/docs/graficheskoe-otobrazhenie-ep-shtamp/ <- google-Картинки:‘документ подписанный электронной подписью’]:
Р‘./../shestnadtsatirichnye-i-dvoichnye-konstanty/image-9-624x257_cr.png’[[[<- https://wiki.itcomgk.ru/wp-content/uploads/2021/06/image-9-624x257.png <- https://uc-itcom.ru/help/docs/graficheskoe-otobrazhenie-ep-shtamp/]]]
[[[[https://oshkole.ru/news_system/7298.html][[[ <- google-Картинки:‘документ подписанный электронной подписью’]]]
]]]
И в целом я поддерживаю автора сайта, только считаю, что ориентироваться в данном случае нужно не на латинский алфавит, а на английский. Да, он полностью совпадает с латинским по написанию, но отличается по произношению. И так уж сложилось, что основоположниками [[[всего]]] современного IT являются американцы. И существующая запись шестнадцатеричных чисел — тоже их изобретение. (Согласно Википедии[https://en.wikipedia.org/wiki/Hexadecimal] эта запись стала фактически стандартом начиная с публикации [[[мануала/]]]руководства по языку Fortran IV для IBM System/360 в 1966 году.)
А американцы — носители английского языка, а не латинского. И мы же не говорим «язык Цэ плюс плюс».
Ну и, кроме того, буква Ц в качестве третьей шестнадцатеричной цифры выглядит как-то не очень.
Таким образом, вместо АБЦДЕФ я бы рекомендовал использовать АБСДЕФ, т.к. английская буква “c” читается как «си».

> «abcdef» -> «абцдеф». Полная калька исходной записи в кириллическом варианте. Транслит наоборот.
И, кстати, использовать при транслитерации в качестве замены для русской буквы «ц» одиночную латинскую “c” — не самая лучшая идея. Ведь тогда слово «царь» превратится в “car”. И любой, кто хоть немного знает английский, прочитает “car” как «ка[р]», что обозначает... ну вы сами знаете что.
Для буквы «ц» лучше использовать [[[диграф]]]двухбуквенное сочетание (“ts”, “tz”, “cs” или “cz”). Ведь для буквы «ч» же используется [[[диграф]]]сочетание “ch”, а буква «ч» встречается в русских текстах в 3 раза чаще буквы «ц» (см. Частотность[https://ru.wikipedia.org/wiki/Частотность]).
