Н‘‘Шестнадцатиричные и двоичные константы (ссылка на статью)’[http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php]’

Комментарии:
Т‘
‘‘*‘2019-08-12’ ~‘alextretyak’

Идеи занятные (и с кавычками и со скобками)...

В свою очередь, предлагаю [[[рассмотреть/]]]посмотреть на [[[мой ]]][[[вариант/]]]‘способ записи шестнадцатеричных чисел/констант в языке программирования 11l’[http://11l-lang.org/doc/ru/integer-literals].

А не думал ли кто-нибудь [[[о красивом синтаксисе]]]об обратной операции? [{Речь о конвертировании/преобразовании значения числовой переменной в произвольную систему счисления. Согласен, что она требуется гораздо реже и специальный синтаксис в языке для неё выделять — это излишество, но вот функцию добавить в стандартную библиотеку языка — почему бы и нет {на данный момент из популярных языков программирования такая функция есть лишь в Си (itoa), и то она нестандартна}.}]
А также о [[[синтаксисе]]]задаче преобразования числа из любой произвольной системы счисления в любую произвольную. Удивительно, но ни в одном языке программирования нет встроенной функции для такого преобразования.

> Иногда ещё 10, но в особых случаях.
Эм... не совсем понял данное предложение\sentence. [[[ИМХО]]]Насколько я вижу по реальным проектам, десятичная система счисления является самой востребованной в проектах любого рода. Затем идёт шестнадцатеричная[[[, а]]]. Двоичная и восьмеричная же практически не используются. [Или тут речь о явном указании на десятичную систему? Т.е. о записи 10'123 вместо просто 123? Такое, конечно, не востребовано, но имхо это просто какая-то глупость {это всё равно что добавить в язык префикс `0d` и писать 0d123 вместо 123}.]

Кстати, [[[я когда выбирал , смотрел примеры реальных программ (на Python и C/C++)]]]по хорошему, нужно смотреть примеры реальных проектов/программ, чтобы понять насколько будет удачно/красиво выглядеть тот или иной вариант синтаксиса. {Кстати, давно у меня зреет идея [[[мега/]]]большого проекта по формированию базы хорошего/красивого кода (в т.ч. псевдокода). Не интересует ли автора сайта работа в этом направлении, в формировании такой базы? [А то мне и самому, признаться, надоело уже быть голословным — хочется бац, и дать ссылку на результат анализа всего хорошего кода на планете, "результат" — в смысле, например, процентное соотношение используемых числовых констант различных систем счисления.]}
’’
‘‘*‘2019-08-14’ ~‘Автор сайта’

Не понятно, что у Вас является признаком шестнадцатеричного числа. Апостроф? Нет, иначе бы 255\\\'000 не было бы десятичным числом.
> Кстати, по хорошему, нужно смотреть примеры реальных проектов/программ, чтобы понять насколько будет удачно/красиво выглядеть тот или иной вариант синтаксиса. {Кстати, давно у меня зреет идея большого проекта по формированию базы хорошего/красивого кода (в т.ч. псевдокода). Не интересует ли автора сайта работа в этом направлении, в формировании такой базы? ...}
Читал я Вашу дискуссию с читателями статьи «Каркас нового языка программирования». Вам заметили, что предлагать новый язык программирования имеет смысл, если в этом языке есть новые концепции. Вы ответили, что желание улучшить синтаксис достаточно для того, что новый язык имел право на существование.

В принципе, с Вами можно было бы согласиться, вот только «пространства» для улучшения синтаксиса всё меньше и меньше. Число комбинаций одного и того же набора символов ограничено. Так что без новых концепций новым языкам трудно пробиться.

Вот вам пример лаконичного и красивого синтаксиса. Допустим, в нижеприведённом коде переменной «текущая координата» присвоено значение функции, читающей положение курсора мыши:
#‘
текущие координаты = читать координаты курсора ()
’
А если мы хотим установить новые координаты? Обычно это делается так
#‘
записать координаты курсора (новые координаты)
’
Если язык поддерживает перезагрузку имён функций, то это может выглядеть короче:
#‘
текущие координаты = координаты курсора ()  // чтение
координаты курсора (новые координаты)       // запись
’
Выше две разных функции с одинаковым именем имеют разную семантику. Моя идея заключается в том, что эти одноимённые функции могут менять семантику в зависимости от местоположения:
#‘
текущие координаты = координаты курсора ()  // чтение
координаты курсора () = новые координаты    // запись
’
’’
‘‘*‘2019-08-15’ ~‘alextretyak’

> Непонятно, что у Вас является признаком шестнадцатеричного числа. Апостроф? Нет, иначе бы 255\\\'000 не было бы десятичным числом.
3 обратных слэша тут лишние, верно?
А признак очень простой — *‘количество’ цифр, разделённых апострофом. Если 1, 2 или 4, тогда число шестнадцатеричное. Если 3, либо если нет разделителей[[[/апострофов]]], то число десятичное. Если оканчивается на ‘b’ или русскую ‘д’, тогда двоичное. Если оканчивается на ‘o’, тогда восьмеричное.

Но благодарю за Вашу реакцию — я подумаю над тем, чтобы [[[дописать/]]]добавить это пояснение в документацию языка.

> Читал я Вашу дискуссию с читателями статьи «Каркас нового языка программирования»...
Ну, со времени написания той статьи много воды утекло.[[[ С тех пор, я больше структурировал информацию, написал документацию к языку, пересмотрел своё]]] [И с тех пор я [[[по многим вопросам]]]во многом поменял своё мнение, в частности, я решил делать больше упор на анализ существующих языков программирования, а также на формирование рационального/логического обоснования для элементов синтаксиса языка[[[ программирования]]], нежели на массовое [и в [[[подавляющем ]]]большинстве случаев — не аргументированное] мнение по тем или иным вопросам, так как мнение любого человека слишком уж завязано на его привычки, и непривычные вещи априори будут [[[приниматься со скрипом]]]восприниматься с отторжением.]

Предлагаю познакомиться с новой статьёй {теперь статью можно скачать отсюда[http://forum.11l-lang.org/threads/Разработка-когнитивно-эргономического-синтаксиса-для-нового-аппаратно-ориентированного-языка-программирования.8/#post-11]}, черновик которой я отправил Вам на почту [можете высказать свои соображения по [[[данной/]]]этой статье здесь же (если это будет уместно), или прошу на форуме[http://forum.11l-lang.org/threads/Разработка-когнитивно-эргономического-синтаксиса-для-нового-аппаратно-ориентированного-языка-программирования.8/] (можете написать и эл. письмо, но предупреждаю заранее, что я оставляю за собой право разместить его текст [или его часть] на форуме[[[время кулуарных обсуждений прошло, только открытые дискуссии!]]])].

> вот только «пространства» для улучшения синтаксиса всё меньше и меньше. ... Так что без новых концепций новым языкам трудно пробиться.
Полностью с Вами согласен.
Вот только число новых/нереализованных значимых/существенных концепций, по-моему, ‘уже близко к [абсолютному] нулю’/‘ещё меньше, чем улучшений синтаксиса’.
Поэтому [[[данный/]]]новый язык [в идеале] должен включить в себя все оставшиеся удачные/подходящие нереализованные идеи по улучшению синтаксиса.[[[ И это реально трудная задача. [[[Но улучшить/‘создать новую’ концепцию — задача нереально трудная.]]]]]] А также взять концепции, лучшие из существующих[[[ (по моему мнению, это смесь С++, Rust[[[‘lifetimes’]]] и Swift[[[‘ARC, `&`’]]] [[а также щепотка Go[[[‘-‘concurrency’[https://habr.com/ru/post/464741/]:‘Golang is well known for the coroutine’’]]], D[[[‘templates/metaprogramming’]]], Nim[[[‘AST based macroses, metaprogramming’]]], Nemerle[[[‘type params infered from usage’]]], C# и Kotlin[[[‘как улучшение Java’]]]/Java]])]]].[[[ В данный момент её можно выразить словами Juarez: ]]]

> Моя идея заключается в том, что эти одноимённые функции могут менять семантику в зависимости от местоположения
Так ведь это уже есть в C++[[[ Да в C++ всё уже есть. Он такой крутой, что даже/уже не интересно. :)(:]]]. Оператор `[]` в `std::vector<bool>` (который на самом деле не массив из `bool`, а битовый массив) возвращает прокси объект, который можно читать (за счёт [[[перегруженного/]]]перегрузки operator `bool`), и в который можно писать (за счёт перегрузки оператора [[[равенства/]]]равно). Чтобы понять как устроен оператор `[]` в `std::vector<bool>` изнутри, можно [[[по шагам ]‘по шагам — это F10, а тут имеется в виду F11 (а впрочем, F11 в MSVC называется ‘Шаг с заходом’ — т.е. тоже ‘шаг’ как-никак)’]]по шагам пройти в отладчике такой код:
#(C++)‘
std::vector<bool> v(1);
v[0] = true;
bool b = v[0];
’

И хочу ещё [[[сделать замечание]]]высказаться [[[на тему]]]по поводу возможности разделения идентификаторов пробелом. Лично мне, [[[также ]]]как и автору, тоже не нравится, [[[как/]]]что символы подчёркивания бросаются в глаза в именах. Но я вижу другое решение этой проблемы — в IDE/‘среде разработки’ отображать символы подчёркивания в идентификаторах немного по-другому, в таком виде, который не так бросается в глаза:
Р‘https://habrastorage.org/webt/gw/kz/es/gwkzes4_vqnxphhxqspvgzitw-i.png’[[[
nesting_level (стандартный Courier New 10)

nesting_level (подчёркивание приподнято на 2 пикселя и сокращено слева и справа на 1 пиксель)

nesting_level (аналогично предыдущему, только подчёркивание полупрозрачно (opacity: 0.5))
]]][[[P‘./[c.txt]/9.08.14/nesting_level.png’]]][[[Если автор опять заменит это на текст ссылки на картинку, попрошу его: ‘А почему Вы не хотите заменять ссылки на картинку тегом <img src="ссылка-на-картинку" />? Она [эта картинка] ведь совсем небольшая. [[[И/]]]А руками копировать ссылку в адресную строку, чтобы посмотреть на [[[неё/]]]картинку, очень неудобно.’]]]

А если разрешить пробелы в идентификаторах, то, боюсь, [[[что будет конфликтовать]]]будет конфликт с ключевыми словами. Например, у меня в парсере есть переменная #‘type_name’. Но #‘type name’ написать уже не получится, так как это корректное объявление нового типа. [Впрочем, об этом автор уже писал[http://compiler.su/utilita-transliteratsii-russkogo-Si-SiPlusPlus-v-standartnyj.php], только там [[[был/]]]приводится пример с ‘int’.]

И к тому же, слышал ли автор[[[ну не люблю я обращение на Вы с большой буквы]]] что-нибудь про "poetry mode" в Ruby? Там можно написать такое:
#(Ruby)‘
puts value
# или даже так:
puts Integer value
’
что является сокращённой записью такого кода:
#(Ruby)‘
puts(value)
puts(Integer(value))
’

P.S. Кстати, синтаксис форматирования сообщений/отзывов, [[[выбранный/]]]разработанный автором, очень даже [[[недурен/]]]неплох[[[ [по мне так даже [[[чем-то/в чём-то ]]]лучше, чем Markdown!]]]].
Единственное, для текста программ я бы выбрал (##символы решётки##) или (0‘``обратные апострофы``’), а не знаки равенства (равенство больше подходит для обозначения двойного зачёркивания).[[[

P.P.S. И ещё маленькое замечание. Такая запись
(&#61;&#61;
код
&#61;&#61;)
не должна генерировать пустую строку вначале.[[[А то получается:
┌──────────────────┐
│                  │
│ код              │
└──────────────────┘
]]]]]]
’’
‘‘*‘2019-08-16’ ~‘Автор сайта’

>‘alextretyak’:‘А признак очень простой — количество цифр’
Так признак, на мой взгляд, не так уж и прост. Но всё относительно. Вы субъективны в своих оценках, а я в своих. ~‘«Каждый пишет, как он слышит. Каждый слышит, как он дышит».’

По поводу статьи я выскажусь чуть позже. Просто пока что зреют мысли.

> число новых/нереализованных значимых/существенных концепций, по-моему, «уже близко к абсолютному нулю»
Не хотите ли Вы сказать, что уже ничто не ново, всё Вам настолько знакомо, что в каждом новом языке Вы видите отголоски старых?

> Так ведь это уже есть в C++.
Ну так приведите пример. Как я должен определить функцию `func`, чтобы я мог записать:
#‘
func() = 123;
’

Спрятать символ подчёркивания, чтобы он не так бросался в глаза... Зачем? Лучше, если программист увидит «честный» текст. Но пробелы внутри идентификаторов — это вызов, это головоломка для лексического/синтаксического анализа. И тут у каждого простого решения есть свои минусы.

> я бы выбрал (##символы решётки##)
Я думал ещё и об эргономике. Хотелось, чтобы символы форматирования были на обеих раскладках клавиатуры на одинаковых клавишах. Остался только «!», но это НЗ на тот случай, когда ещё что-то захочется.
’’
‘‘*‘2019-08-18’ ~‘alextretyak’

> Не хотите ли Вы сказать, что уже ничто не ново
Ну... я бы немного по-другому сказал. Всё новое — довольно[[[/достаточно]]] спорно. Взять тот же Rust с его lifetimes/borrowing (я, кстати, до сих пор не могу найти пример хорошего кода на Rust, где эти lifetimes оправданны, [[[другими словами — я не понимаю, чем эта модель лучше C++]]]все приводимые примеры в статьях по Rust либо надуманны, либо их можно [[[спокойно/]]]легко переписать на C++ безо всяких lifetimes).[[[Или нововведения в C++ (привет ‘export import’).]]]

> всё Вам настолько знакомо, что в каждом новом языке Вы видите отголоски старых?
Отчасти и это тоже.
Но если посмотреть на эволюцию естественных языков, то можно заметить, например, что русский язык [[[почти]]]существенно не менялся уже более ста лет с реформы 1918 года, и практически/фактически не менялся с 1956 года. А с наступлением цифровой эпохи ни русский, ни английский, никакие другие естественные языки, скорее всего, меняться уже [[[практически ]]]не будут. И я боюсь, что языки программирования постигнет та же участь — [[[с некоторого момента]]]они "заморозятся" и их эволюция завершится (также как когда-то завершилась эволюция чисел [ведь, никто не будет спорить с тем, что числа больше не будут эволюционировать? и не только/просто числа, а язык математики, скорее всего, тоже не будет больше эволюционировать![[[ (кто не согласен — попробуйте привести новшества[?] в математике за последние лет 30[?])]]]]).

> Ну так приведите пример. Как я должен определить функцию `func`, чтобы я мог записать: `func() = 123;`
#(C++)‘
#include <iostream>

void func(int i) { std::cout << i; }

class Proxy
{
public:
    void operator=(int i) { func(i); }
    operator int() {
        int r;
        std::cin >> r;
        return r;
    }
};

Proxy func() { return Proxy(); }

int main()
{
    func() = 123;   // заменяется на func(123)
    int i = func(); // возвращает число из cin
}
’

> Хотелось, чтобы символы форматирования были на обеих раскладках клавиатуры на одинаковых клавишах.
А я использую AutoHotkey и у меня в обеих раскладках одинаковое поведение при наборе [[[спец]]]символов (например, Shift+2 — это всегда @, Alt+2 — это всегда кавычка ", Shift+3 — это всегда решётка #, а Alt+3 — это всегда № и т.д.).
Соответствующий скрипт можно посмотреть тут: [http://pqmarkup.org/ru] → «‘Советы по набору’/‘способы набора’ символов одиночных парных кавычек ‘ и ’...» → «В этот же файл-скрипт можно дополнительно ещё добавить:».

И, если честно, я считаю проблему переключения раскладок [[[— ]]]несколько надуманной. Также [[[как и]]]весьма сомнительным считаю чрезмерное стремление повысить скорость набора кода [речь про слепую печать и т.д.[[[т.д. — это [[[минимизация переключений раскладки](уже упоминается в этом предложении)]]макросы, горячие клавиши, автодополнение[‘это удобно само по себе, а не с целью повышения скорости набора’]]]]]. На первом месте должно быть *‘качество’ кода или текста, а не его количество. Причём я [[[зачастую]]] наблюдал[[[ именно]]] такую картину, что чем больше программист пишет кода, тем менее он качественный[[[не обижайся Заккер, но код Саши Котляра мне больше нравится]]].
Вот пример из Вашей же статьи[https://habr.com/ru/post/208474/]:
> Ховик Меликян приводит пример, когда программа из 80000 строк кода на Си++ и 55000 строк кода на VB заменялась 10 строками на шелл-скрипте.

И чтобы получить более качественный текст [[[сообщений]]][комментариев или писем], лично я использую два приёма:
1. Откладываю его отправку примерно на одни сутки[[[ [в течение этого срока подсознание наиболее[?] активно[?] присылает мысли по улучшению текста комментария]]]].
2. Периодически перечитываю этот текст. Суммарно получается больше 10 раз точно. Ну и к чему мне эта пресловутая скорость набора, если на ревью и обдумывание/придумывание[[[/составление]]] текста я трачу времени гораздо больше?

А что касается кириллицы в программировании, то, как можно видеть, например в языке КуМир ([http://bsosh6.shkola.hc.ru/teachers_pashut/tuzov/kumir/manual.pdf]) хотя и используются кириллические ключевые слова, но математические функции оставлены на английском (например, sqrt или sin[[[или sin — на уроках математики мы же пишем `sin x`, а не `син х` и ничего, к тому же это слово не английское, а латинское[[[[[а для sqrt можно ввести синоним `квкорень`]]]]]]]] {на уроках математики мы же пишем `sin x`, а не `син х` и ничего}). И я считаю это [[[правильным/]]]оправданным.

>‘... который не так бросается в глаза:
https://habrastorage.org/webt/gw/kz/es/gwkzes4_vqnxphhxqspvgzitw-i.png’
А почему Вы не хотите заменять ссылку на картинку тегом <img src="ссылка-на-картинку" />? Она [эта картинка] ведь совсем небольшая. [[[И/]]]А руками копировать ссылку в адресную строку, чтобы посмотреть на [[[неё/]]]картинку, очень неудобно.
’’
’
