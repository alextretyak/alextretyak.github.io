<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3><a href="http://compiler.su/o-nepravomernom-dostupe-k-pamyati-cherez-ukazateli.php">О неправомерном доступе к памяти через указатели (ссылка на статью)</a></h3>
<br />
Комментарии:<br />
<hr />
2024-02-13 <i><b>veector</b></i><br />
<br />
<blockquote>Если Вы посмотрите, какой ассемблерный код генерируется для ссылок и указателей при вызове функций, то будете удивлены: он одинаков в обоих случаях.</blockquote>
Например, если брать gcc x86 (я использовал mingw в составе code::blocks), то отличия начинаются в более сложных функциях. Дело в том, что в gcc принято передавать все параметры через стек, поэтому, ваши простые функции имеют одинаковый "прототип" на ассемблере и машинных кодах, т.к. gcc нечего "сокращать" используя логику ссылок, по сравнению с логикой указателей. Но, когда появляются более сложные конструкции, тогда применение ссылок начинает влиять на код.<br />
<br />
Пример, в котором бинарный/ассемблерный коды функций F1() и F2() отличаются, также отличаются и их "прототипы" вызова в машинных кодах.<br />
<pre class="code_block">
#include &lt;iostream>

using namespace std;

typedef int&amp; IntRef_t;
typedef int* IntPtr_t;

void F1(IntPtr_t* IntPtrPtr)
{
    int IntValue = ++(**IntPtrPtr);
    printf("F1 = %i\n", IntValue);
}

void F2(IntRef_t&amp; IntRefRef)
{
    int IntValue = ++IntRefRef;
    printf("F2 = %i\n", IntValue);
}

int main()
{
    int D[2] = {0, 0};
    IntPtr_t IntPtr;

    IntPtr = &amp;D[0];
    F1(&amp;IntPtr);
    IntRef_t IntRef1 = D[1];
    F2(IntRef1);

    printf("D[0] = %i, D[1] = %i\n", D[0], D[1]);
    return 0;
}
</pre><!--[[[
Еще хотел уточнить, что собирать пример стоит с максимально отключенной оптимизацией. Иногда, программисты воспринимают сокращение кода из-за применения ссылок как оптимизацию, хотя это не так. Ссылки позволяют компилятору делать оптимальный код ещё на уровне непосредственной интерпретации кода программы, до начала работы различных механизмов оптимизации.]]]-->
<hr />
2024-02-16 <i><b>alextretyak</b></i><br />
<br />
Поддерживаю автора сайта. Метод <b>end()</b>, который возвращает "фейковый" итератор (который запрещено разыменовывать) — это вообще какой-то бред.<!--[[[ (И чем больше я пишу на C++, тем больше я в этом убеждаюсь. Причём в комитете по C++ похоже начинают понимать это, т.к. в C++17 в цикл по диапазону[https://ru.cppreference.com/w/cpp/language/range-for] добавили такую фишку, что метод *‘end()’ у итерируемого объекта больше не обязан возвращать такой же тип, какой возвращает *‘begin()’. Это позволяет упростить код: возвращать в методе *‘end()’ специальный объект-заглушку-пустышку, и добавить перегрузку оператора *‘!=’, где типом аргумента является эта заглушка.)](эта фишка не настолько уж важная — всегда можно просто добавить bool поле в итератор)]]--> Проблема усугубляется тем, что по стандарту должно быть возможно через <b>−−end()</b> получить итератор на последний элемент контейнера. А если кто пробовал самостоятельно реализовать <!--[[[контейнер ]]]-->двусвязный<!--[[[ или односвязный]](итератор односвязного списка не поддерживает операцию `--`)]--> список, тот знает, что в последнем узле списка в поле <b>next_node</b> удобно хранить просто нулевой указатель, который и является признаком окончания списка. Но если следовать стандарту C++, то <b>end()</b> не может возвращать просто нулевой итератор, т.к. к нему невозможно применить операцию ‘<b><!--[[[end() ]]]-->−−</b>’. Из-за этого приходится извращаться с <!--[[[всякими]]]-->каким-нибудь sentinel node, который например в реализации от Microsoft выделяется <a href="https://devblogs.microsoft.com/oldnewthing/20230804-00/?p=108547" title="<- google:‘stl list end implementation’">динамически</a> в конструкторе списка, что приводит к нехорошим последствиям: <!--[[[например]]]-->к примеру, <!--[[[move конструктор может бросить исключение или, что ещё хуже, ]]]-->массив из миллиона пустых <b>std::list</b>-ов потребует миллион вызовов оператора <b>new</b> для выделения памяти под sentinel nodes.<br />
<!--[[[Ну/]]]--><span class="sq"><span class="sq_brackets">[</span>Хотя, насчёт невозможности применить операцию ‘<b>−−</b>’ к нулевому итератору я несколько преувеличил: в итераторе можно хранить не только указатель на узел, но ещё и указатель на сам объект-список. <!--[[[Но[[[ даже]]] в таком случае следует ещё добавить в итератор [[[булеву/]]]bool переменную для того, чтобы отличать:
(..нулевой указатель, ссылающийся на узел списка, "расположенный" после последнего узла и..)
(..нулевой указатель, ссылающийся на узел списка, "расположенный" перед начальным узлом списка...)
[Первый нужен для *‘end()’, а второй — для *‘rend()’ (ведь необходимо поддерживать обход списка в обратном порядке — от *‘rbegin()’ до *‘rend()’).]]]]--> Но всё равно получается излишнее усложнение реализации для соответствия принятому стандарту.<span class="sq_brackets">]</span></span><br />
<br />
И даже сама терминология итераторов в C++ абсолютно <!--[[[идиотская/]]]-->бестолковая<!--[[[ да, итераторы в C++ позволяют более comprehensive реализовать алгоритмы, но на практике это не используется, поэтому решение C++ можно рассматривать как эксперимент, эксперимент оказался неудачным]]]-->. О чём красноречиво говорит такой факт, что итераторов в стиле C++ больше нет <b>ни в одном</b> языке программирования.<br />
<!--[[[Посмотрите]]]-->Мне нравится, как итераторы реализованы в Python<!--[[[, а]]]--> и почти также в Rust<!--[[[ и других современных языках]]]-->:<br />
У контейнеров есть метод <b>iter()</b>, который возвращает итератор по этому контейнеру. У итератора есть метод <b>next()</b>, который выполняет переход к следующему элементу итерируемого контейнера и как-то сигнализирует о том, что элементов в контейнере больше нет (т.е. текущий элемент был последний) — в Python это делается через <b>raise StopIteration</b>, <!--[[[а ]]]-->в Rust через возврат <b>None</b><!--[[[ в методе *‘next()’]]]-->.<br />
На <a href="https://youtu.be/d3qY4dZ2r4w?si=z0-QayzWZ4MbBEhY&amp;t=2674">этом слайде</a> презентации есть сравнительная таблица итераторов в C++, D, C#, Rust, Python и Java. Как видно из этой таблицы, лишней сущности <b>last</b> <span class="sq"><span class="sq_brackets">[</span>точнее after_last, он же end<span class="sq_brackets">]</span></span> нет ни в <!--[[[одном языке]]]-->D, ни в C#, ни в Rust, ни в Java, ни в Python. И только <!--[[[в ]]]-->C++ идёт своим особым путём, трактуя понятие "итератор" как навороченный указатель. Во всех <s>нормальных</s> остальных языках программирования под <i>итератором</i> понимается сущность, которая обеспечивает возможность обхода контейнера или какого-либо итерируемого объекта.<!--[[[ Для получения итератора по контейнеру в Python необходимо вызвать *‘iter(container)’, а в Rust — *‘container.iter()’.]]]--><!--[[[ [А то, что называется итератором в C++ правильнее было бы назвать ~‘курсором’[[[
>[https://forum.dlang.org/post/diexjstekiyzgxlicnts@forum.dlang.org]:‘"iterators" that I called cursors.’
]]].]]]]--><br />
<!--[[[
Чем больше я пишу на C++, тем больше я убеждаюсь в порочности принятого соглашения обходить итерируемые объекты от begin до end.
В наивной реализации двусвязного списка [[[для обхода списка достаточно]]]в последнем элементе списка указатель next [[[является/]]]равен nullptr. Но корректная реализация std::list не может просто возвращать нулевой итератор в методе end(), т.к. в таком случае нельзя получить последний элемент списка через end() - 1. Из-за чего приходится извращаться с [[[всякими]]]каким-нибудь sentinel node, который например в реализации от Microsoft выделяется динамически[https://devblogs.microsoft.com/oldnewthing/20230804-00/?p=108547 <- google:‘stl list end implementation’], что приводит к нехорошим последствиям: например, move конструктор может бросить исключение или, что ещё хуже, массив из миллиона пустых std::list-ов потребует миллион вызовов оператора new для выделения памяти под sentinel nodes.
]]]--><br />
<b>veector</b><br />
<blockquote>Пример, в котором бинарный/ассемблерный коды функций F1() и F2() отличаются, также отличаются и их "прототипы" вызова в машинных кодах.</blockquote>
Ваш пример некорректен.<br />
Функция F2 у вас на самом деле принимает обычную одиночную ссылку на int. Т.к. в данном случае имеет место т.н. "reference collapsing", а именно срабатывает правило <a href="https://leimao.github.io/blog/CPP-Reference-Collapsing/" title="<- google:‘&quot;c++ reference collapsing&quot;’ <- https://mainfunda.com/what-is-reference-collapsing/ <- google:‘c++ &quot;reference to reference&quot;’">‘T&amp; &amp; → T&amp;’</a>. В этом легко убедиться, если попытаться добавить перегруженную функцию <b>void F2(IntRef_t IntRef)</b> — в этом случае компилятор выдаст ошибку "C2084: function 'void F2(IntRef_t)' already has a body". (Дело в том, что в C++ нет такого понятия, как ссылка на ссылку, поэтому то в C++11 <!--[[[запись *‘&&’ означает особый новый тип ссылок — rvalue reference]]]-->для обозначения нового типа ссылок <span class="sq"><span class="sq_brackets">[</span>rvalue references<span class="sq_brackets">]</span></span> ввели запись <b>&amp;&amp;</b>, т.к. в С++03 она не имела смысла, и ваш пример, кстати, не скомпилируется с опцией -std=c++03 — <a href="https://godbolt.org/z/c9ddPsqz3">https://godbolt.org/z/c9ddPsqz3</a>, т.к. "reference collapsing" появился только в C++11.)<br />
А функция F1 <!--[[[у вас ]]]-->принимает <!--[[[не указатель на int, а ]]]--><b>двойной</b> указатель (т.е. указатель на указатель на int). Если это <a href="https://godbolt.org/z/j9GzMqbdo">исправить</a>, то генерируемый ассемблерный/машинный код для F1 и F2 будет полностью совпадать (за исключением адреса строкового литерала "F2 = %i\n").<br />
<br />
<b>Автор сайта</b><br />
<blockquote>А Си накладывает ограничения: нельзя с помощью goto перейти на переменную или запрыгнуть внутрь цикла. Выпрыгнуть из цикла — пожалуйста, а внутрь — ни-ни.</blockquote>
Вообще-то, в Си можно запрыгнуть внутрь цикла. :)(: Вот пример: <a href="https://godbolt.org/z/4xqeM7Kxq">https://godbolt.org/z/4xqeM7Kxq</a>.<br />
И даже в C++ <a href="https://godbolt.org/z/je7nz8c91">можно</a>. При условии, что goto не пропускает объявления переменных. (Но, разумеется, делать так не следует — оба приведённых мной примера являются UB и <!--[[[странно, что компилятор даже warning не выдаёт]]]-->компилятор выдаёт предупреждение об использовании неинициализированной переменной.)<br />
<hr />
2024-02-16 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b>, все так. Я выбрал тот стандарт и то свойство, которые были удобны для демонстрации.<br />
<br />
Я не знаком с Rust, но у меня есть к вам вопрос по теме итераторов.<br />
<blockquote>У контейнеров есть метод <b>iter()</b>, который возвращает итератор по этому контейнеру. У итератора есть метод <b>next()</b>, который выполняет переход к следующему элементу итерируемого контейнера и как-то сигнализирует о том, что элементов в контейнере больше нет (т.е. текущий элемент был последний)</blockquote>
Зачастую, нужно несколько одновременно работающих итераторов с одной таблицей. Из-за этого, приходится делать отдельные объекты типа итератор и создавать их столько раз, сколько нужно. Вот этот метод <b>iter()</b> у контейнеров, он позволяет сделать несколько разных итераторов, работающих независимо, или это посто один итератор встроенный в класс контейнера?<br />
<hr />
2024-02-16 <i><b>Автор сайта</b></i><br />
<br />
<b>veector</b><br />
<blockquote>целых три, на мой взгляд, важных нюанса: Шаренная память ... звуковые карты, видео адаптеры ...<br />
Нет никакого смысла инициализировать данные кучи или программного стека</blockquote>
Первые два нюанса действительно особый случай. Настолько особый, что и дисциплина обращений к такой памяти особая. Чтение такой памяти привносит недетерминизм, то есть непредопределённость, по-русски говоря. А запись в такую память имеет побочные эффекты. Соответственно функции, читающие из такой памяти, обладают недетерминизмом, а записывающие обладают побочным эффектом.<br />
<br />
А вот с третьим перечисленным Вами нюансом я не согласен. В чём смысл вывода типов? Фишка в том, что переменная не создаётся то тех пор, пока в неё что-то не записали. Ведь это правильно — читать только тогда, когда в неё что-то записали. А запись — это вычисление значение этой переменной — до того, как она понадобилась для чтения. Поэтому неважно, где такая переменная находится: в статической ли памяти, в стеке или куче. Важно, что чтению должна предшествовать запись, а если первым всё-таки идёт чтение, то имеем непредсказуемое значение.<br />
<br />
А если переменная не записывалась и не читалась, то она просто не нужна. Компилятор языка, где нет вывода типов, должен потрудиться, чтобы выявить такие переменные и выдать предупреждение. А вывод типов просто на автомате не создаёт таких переменных. Компилятор упрощается: ему не надо искать неиспользуемые переменные.<br />
<br />
Третий Ваш нюанс имеет совсем другой нюанс. Если ОС выделяет программе физическую память, как она есть, то чтение неинициализированной памяти помогает хакерам узнавать всякие пароли, ключи шифрования и прочие чувствительные вещи. Поэтому современные ОС выделяемую память прописывают чем-нибудь, чаще нулями. Это замедляет работу, но повышает безопасность.<br />
<br />
<b>alextretyak</b><!--[[[
Завидую Вашей энергии, которая подвигла Вас на столь тщательное и подробное изложение материала на серьёзном теоретическом уровне [[[(]]]:) Надеюсь, и на остальные дела Вам хватает энергии и любопытства [[[(]]]:)]]]--><br />
<blockquote>Вообще-то, в Си можно запрыгнуть внутрь цикла.</blockquote>
Надо попробовать. А то прочитал когда-то, принял это для себя как аксиому. А может, аксиома касалась не Си, а другого языка? Запросто могло так быть.<br />
<hr />
2024-02-17 <i><b>alextretyak</b></i><br />
<br />
<b>veector</b><br />
<blockquote>т.к. универсальных языков нет.</blockquote>
Я бы уточнил: «на данный момент/пока ещё нет». Но это не означает, что такой язык невозможно создать в принципе.<br />
<!--[[[Собственно я и занимаюсь разработкой такого языка.]]]-->И работы в этом направлении <!--[[[уже ]]]-->активно ведутся: Mojo, daslang.org. (Это примеры из совсем новых языков, хотя, разумеется, попытки создания универсальных языков были и раньше.)<br />
Собственно, и я тоже занимаюсь разработкой такого языка. (<!--[[[Можете глянуть мою последнюю статью]]]-->Вот моя последняя статья на эту тему: <a href="https://habr.com/ru/articles/784294/">https://habr.com/ru/articles/784294/</a>, хотя <!--[[[там/]]]-->она больше про компилятор, но в конце есть <!--[[[немножко/]]]-->немного и про язык.)<br />
Все эти языки без сборщика мусора и поддерживают <!--[[[голые/]]]-->низкоуровневые указатели, поэтому вполне пригодны для системного программирования, обладая при этом синтаксисом скриптов<!--[[[оподобн]]]-->ых языков.<br />
<br />
<blockquote>Инициализация — это же чисто человеческое понятие.<br />
Значение, которым нужно проинициализировать какую-то переменную, зависит от решаемой человеком задачи.</blockquote>
А разве бывают решаемые человеком задачи, в которых было бы допустимо использование неинициализированных переменных?<br />
Неинициализированными можно оставить только такие переменные, к которым вообще не происходит обращения, что случается довольно <!--[[[нечасто/]]]-->редко.<br />
<br />
<blockquote>Автоматически компилятором вставлять код, что бы все переменные инитить согласно их типу, или заставить инитить человека, не допуская переменных без инициализации, ну, это такое себе, спорное решение.</blockquote>
Нормальное решение, которого придерживаются практически все современные языки программирования. И во многих реализована оптимизация удаления кода "излишних" инициализаций (например, в <b>auto i = 0; i = 1;</b> присваивание <!--[[[переменная *‘i’ будет проинициализирована единицей]]]-->нулю будет отброшено <span class="cu_brackets" onclick="return spoiler(this, event)"><span class="cu_brackets_b">{</span><span>…</span><span class="cu" style="display: none">в данном примере первая инициализация <span class="sq"><span class="sq_brackets">[</span>присвоение нулю<span class="sq_brackets">]</span></span> нужна для вывода типа <span class="sq"><span class="sq_brackets">[</span>переменной <b>i</b><span class="sq_brackets">]</span></span></span><span class="cu_brackets_b">}</span></span>).<br />
К тому же, инициализация<!--[[[ она]]]--> бывает разная.<br />
Например, в таком коде:<br />
<pre class="code_block">
int i;
if (flag)
    i = 1;
else
    i = 2;
printf("%i", i);
</pre>
переменную <b>i</b> можно считать корректно проинициализированной. Суть в том, чтобы компилятор делал проверку того, что на всех возможных путях выполнения кода переменная инициализируется перед тем, как она используется.<br />
Заметьте, что <!--[[[даже]]]-->хотя C++ допускает<!--[[[прекрасно]]]--> неинициализированные переменные на уровне языка, некоторые компиляторы C++ (Clang, MSVC<!--[[[ почему не упомянул GCC: в данном примере (если одну из веток if оставить пустой) он никак не хочет выдавать предупреждение]]]-->) выдают предупреждение об использовании потенциально неинициализированных переменных. Моя позиция (и насколько я понимаю позиция автора сайта) заключается<!--[[[ лишь]]]--> в том, чтобы это предупреждение сделать ошибкой компиляции.<br />
<br />
<blockquote>Ибо, например, реальное ОЗУ подставится в момент первого обращения к данному адресному пространству.</blockquote>
И что же будет находиться по этому адресному пространству? Какой-то неизвестный мусор? Память, заполненная какими-то данными от других процессов (в которой могут оказаться пароли, ключи шифрования и прочее)? Ничего подобного. Практически все операционные системы <!--[[[гарантируют ]]]-->обеспечивают защиту от возможности получения мусорных страниц памяти от других процессов путём их зануления. Да, фактически такое зануление не выполняется сразу же. Можно <!--[[[выделить]]]-->запросить 1 гигабайт памяти и не <!--[[[бояться]]]-->опасаться того, что операционная система будет забивать этот гигабайт нулями <!--[[[сразу же]]]-->немедленно. Но! Можно полагаться на тот факт, что при первом обращении к любой странице памяти из запрошенного гигабайта, содержимое этой страницы памяти будет гарантированно <!--[[[инициализировано нулями]]]-->обнулено. Таким образом, хотя <i>реально</i> в выделенном блоке памяти находится (точнее <i>будет</i> находиться, т.к. физические страницы назначаются по мере обращения к виртуальным) какой-то мусор (возможно, с информацией из других процессов), но <i>виртуально</i> запрошенный блок памяти уже полностью проинициализирован нулями. И этим можно пользоваться. Вот пример такого использования:<br />
<a href="https://fortran-lang.discourse.group/t/why-is-this-fortran-code-so-much-faster-than-its-c-counterpart/3746" title="<- https://www.reddit.com/r/cpp_questions/comments/1046m1o/is_stdvector_inherently_slow_to_initiate/ <- google:‘resize_for_overwrite vector’">https://fortran-lang.discourse.group/t/why-is-this-fortran-code-so-much-faster-than-its-c-counterpart/3746</a><br />
(<!--[[[Здесь]]]-->Там человек спрашивает, почему одинаковый по смыслу<!--[[[аналогичный]]]--> код в Фортране работает намного быстрее, чем в C++.)<br />
Обратите внимание на строку <b>allocate(x(n), source = 0d0)</b>.<br />
Здесь производится выделение массива из 3 миллиардов вещественных чисел, <i>проинициализированных</i> нулями. И компилятор Фортрана догадывается <!--[[[вызвать/]]]-->использовать в данном случае calloc(), который в свою очередь полагается на поведение операционной системы и не делает явного зануления всех байт выделенного блока памяти.<br />
<!--[[[Почему такой трюк не может повторить компилятор C++? Просто потому, ]]]-->Но компилятор C++ не может повторить такой трюк, т.к. контейнеры STL не обращаются к malloc() напрямую, а используют глобальный <!--[[[(или определённый в соответствующем классе) ]]]-->operator new, который может быть переопределён, а потому, полагаться на то, что полученная им память будет заполнена нулями, не получится.<br />
<br />
<blockquote>Влияет и очень существенно.<br />
Например, на скорость работы программы, что особенно заметно на большом объеме обрабатываемых данных (это не обязательно большие массивы, а может быть очень много маленьких).</blockquote>
С большими массивами, которые имеет смысл оставлять неинициализированными, программист имеет дело очень редко. В остальном же коде<!--[[[,]]]--> наличие неинициализированных переменных приводит (либо может привести) к ошибкам в работе программы, и от этих ошибок, в первую очередь, и должен защищать компилятор. А когда действительно нужен непроинициализированный массив, можно <!--[[[добавить в язык]]]-->использовать специальные средства в языке программирования: в языке D это <a href="https://dlang.org/library/std/array/uninitialized_array.html" title="<- google:‘dlang create uninilialized array’">uninitializedArray</a>, а также <a href="https://dlang.org/spec/declaration.html#void_init" title="<- https://forum.dlang.org/thread/pvhvqinxnhzklkvktirh@forum.dlang.org <- google:‘dlang uninilialized void’">void initializers</a>. В языке C++20 это std::make_unique_for_overwrite, а также предлагаемый string::resize_and_overwrite.<br />
<br />
<blockquote>у меня есть к вам вопрос по теме итераторов.<br />
Зачастую, нужно несколько одновременно работающих итераторов с одной таблицей.</blockquote>
<!--[[[Такое нужно раз в 100 лет, а страдает наиболее часто используемый случай.
]]]-->Во-первых, я не очень понимаю, что вы имеете в виду под таблицей. Хеш-таблицу?<br />
Просто "таблицы" есть, насколько мне известно, только в языке Lua и являются гибридом хэш-таблицы и массива.<!--[[[ Хотя ещё в Nim есть[https://nimbyexample.com/tables.html <- google:‘nim tables’ <- ‘Nim Table, type iterators and lent type’[https://forum.nim-lang.org/t/9641] <- google:‘nim iter’].]]]--><br />
<br />
Во-вторых, давайте попробуем <!--[[[исправить/]]]-->устранить путаницу в терминологии, которую внёс C++. <!--[[[Итератор в C++ — это совсем ]]]-->То, что в C++ принято называть итератором, в других языках называют чаще <i>курсором</i> <span class="sq"><span class="sq_brackets">[</span>и работают с ним несколько по-другому<!--[[[узловой курсор, в отличие от итератора C++, знает о том, указывает он на валидный узел или нет]]]--><span class="sq_brackets">]</span></span>. А итератор лишь обеспечивает возможность обхода итерируемого объекта. Его можно получить напрямую у контейнера методом iter() (в этом случае будет производиться обход по всем элементам этого контейнера). Его <span class="sq"><span class="sq_brackets">[</span>итератор<span class="sq_brackets">]</span></span> возвращают методы наподобие reversed() <span class="sq"><span class="sq_brackets">[</span>позволяет обойти все элементы контейнера в обратном порядке<span class="sq_brackets">]</span></span><!--[[[, slice() [позволяет обойти какой-то поддиапазон элементов контейнера]]]]-->, filter() <span class="sq"><span class="sq_brackets">[</span>обходит только элементы, удовлетворяющие определённому условию<span class="sq_brackets">]</span></span> и т.п.<br />
<!--[[[
В-третьих, уточните какую именно задачу вы решаете, как вы работаете с вашими "итераторами"? Ещё лучше будет, если вы приведёте конкретный пример кода[[[ и[[[ли хотя бы]]] набор входных данных]]].
]]]--><br />
<blockquote>Вот этот метод iter() у контейнеров, он позволяет сделать несколько разных итераторов, работающих независимо, или это посто один итератор встроенный в класс контейнера?</blockquote>
Каждый вызов метода iter() создаёт новый независимый объект-итератор. В документации <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html#the-iterator-trait-and-the-next-method">приводится</a> пример "ручной" работы с итератором.<br />
А вот пример получения двух независимых итераторов от одного контейнера и такой же "ручной" работы с ними:<br />
<pre class="code_block">
fn main() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();
    let mut v2_iter = v1.iter();

    print!("{}", v1_iter.next().unwrap());
    print!("{}", v1_iter.next().unwrap());
    print!("{}", v2_iter.next().unwrap());
}
</pre>
<!--[[[
Я правда не очень понимаю, зачем такое может понадобиться.
]]]-->Но вообще-то, так итераторы обычно не используют. Методы iter() и next() нужны не для явного вызывания, а для неявного:<br />
<pre class="code_block">
fn main() {
    let v1 = vec![1, 2, 3];

    for val in v1 { // методы iter() и next() вызываются компилятором неявно
        println!("Got: {}", val);
    }
}
</pre>
<hr />
2024-02-18 <i><b>Автор сайта</b></i><br />
<br />
Ваш код<br />
<pre class="code_block">
int i;
if (flag)
    i = 1;
else
    i = 2;
printf("%i", i);
</pre>
я бы написал по-другому. Вывод типов, а следовательно и объявление переменной, и её инициализация, может делаться и условным выражением, что лаконичнее и элегантнее (последнее зависит от вкусов).<br />
<pre class="code_block">
а = (если б &lt; в
    0
     иначе
    1.0)
</pre>
или<br />
<pre class="code_block">
а = (если б &lt; в; 0; иначе 1.0)
</pre>
И не только условным выражением, но и переключателем. При этом выбирается:<br />
<ul>
<li>такой тип, который исключает искажение значения,</li>
<li>достаточный тип, то есть наименьший из возможных, которые не искажают значение.</li>
</ul>
Если же в ветвях условного выражения встречаются несовместимые типы, то это ошибка.<br />
<br />
<blockquote>Но! Можно полагаться на тот факт, что при первом обращении к любой странице памяти из запрошенного гигабайта, содержимое этой страницы памяти будет гарантированно обнулено.</blockquote>
В программе на Вашем языке, как и на моём, это действительно будет так. Но мир состоит не только из честных людей. Оставшиеся люди выберут другой язык, чтобы иметь доступ к неинициализированной памяти. Увы, но ОС вынуждена всё-таки обнулять память.<br />
<hr />
2024-02-19 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b><br />
Спасибо за пояснения про итераторы в Rust, все понятно, вопросов нет, сделано хорошо.<br />
<br />
<blockquote>Каждый вызов метода iter() создаёт новый независимый объект-итератор.</blockquote>
По поводу "инициализации", вы же сами и написали, что "К тому же, инициализация бывает разная. Например, в таком коде:" — как вы это будете "занулять" на автомате? Я уже не говорю про переменную flag, значение которой, по вашей с <b>Автором сайта</b> логики автоматической инициализации, тоже ведь кто-то когда-то должен быть записать.<br />
<br />
<blockquote>И что же будет находиться по этому адресному пространству? Какой-то неизвестный мусор?</blockquote>
Как я уже замечал ранее, современная тенденция в разработке аппаратуры — проецировать в адресное пространство процессоров не только ОЗУ, а вообще все на свете. Например, там может быть ПЗУ со значением серийного номера процессора или MAC-адресом для встроенной сетевой карты по умолчанию. Применений очень много, и если вы с ними не сталкиваетесь, то не значит, что этого нет.<br />
<br />
Специально и умышленно пользоваться неинициализированным участком памяти, никто в здравом уме не будет. Автоинициализация призвана лишь повысить надежность готовой программы, даже если в её коде есть ошибка, связанная с забывчивостью программиста задать корректное начальное значение.<br />
<br />
По поводу "автозануления" ОЗУ операционными системами, скажу так, что когда на кону стоит скорость обработки, то "автозануление" не используется. Ну и зависит это от много, включая от настроек ядер операционных систем, вот тут как раз об этом же и написали в самом конце: <a href="https://fortran-lang.discourse.group/t/why-is-this-fortran-code-so-much-faster-than-its-c-counterpart/3746/12">https://fortran-lang.discourse.group/t/why-is-this-fortran-code-so-much-faster-than-its-c-counterpart/3746/12</a><br />
<blockquote>In this particular case, the system calloc implementation did better than C++'s operator new + memset. But as others have shown, you cannot generalize this to all platforms (OS's, architectures).</blockquote>
<hr />
2024-02-20 <i><b>alextretyak</b></i><br />
<br />
<b>Автор сайта</b><br />
<blockquote>я бы написал по-другому. Вывод типов...</blockquote>
<!--[[[Нет. Тут фишка в другом. ]]]-->Да, вывод типов, а также выражение «<!--[[[if-else]]]-->если-иначе» — это всё хорошо, но я хотел сделать акцент на другом. А именно, на случаях очень сложных инициализаций.<br />
Допустим нам необходимо посчитать число <b>n</b>, которое в дальнейшем будет использоваться как <!--[[[число/]]]-->количество итераций некоторого цикла. Если написать так:<br />
<pre class="code_block">
auto n = 0;
if (flag1) {
    if (flag2) {
        n = 1;
    }
    else {
        n = 2;
    }
    if (flag3)
        n++;
}
else {
    if (flag4) {
        n = 3;
    }
    else {
        ... // здесь забыли проинициализировать `n`
    }
}
// ... `n` используется где-то ниже
</pre>
то в случае, когда выполнение кода пойдёт по пути, <!--[[[при/]]]-->в котором <b>n</b> не инициализируется, в <b>n</b> окажется начальное значение <b>0</b>, и при этом возможно возникновение очень трудно уловимой ошибки.<br />
<br />
Если же вместо <b>auto n = 0;</b> написать <b>int n;</b> <span class="sq"><span class="sq_brackets">[</span>я использую здесь синтаксис C++ просто чтоб было понятнее<span class="sq_brackets">]</span></span>, то это будет предписывать компилятору, что <b>n</b> инициализируется где-то дальше, и компилятор должен проверить, что <b>n</b> действительно инициализируется перед использованием (ведь с записью <b>auto n = 0;</b> такую проверку компилятор делать не будет). Так программист может написать <b>int n;</b> в случае, когда ему необходимо проверить, что <b>n</b> инициализируется на всех путях выполнения. Язык с более продвинутым выводом типов может разрешить даже запись <b>auto n;</b> вместо <b>int n;</b>.<br />
<br />
<blockquote>В программе на Вашем языке, как и на моём, это действительно будет так. Но мир состоит не только из честных людей. Оставшиеся люди выберут другой язык, чтобы иметь доступ к неинициализированной памяти.</blockquote>
Если честно, не очень понимаю, что вы имели в виду. Я говорил как раз о том, чтобы, наоборот, не занулять явно память полученную от систем<!--[[[ных вызовов ]]]-->ы, т.к. это повышает производительность программы.<br />
<br />
<blockquote>Увы, но ОС вынуждена всё-таки обнулять память.</blockquote>
Верно. Поэтому какой бы язык программирования не выбрал программист (да хоть даже ассемблер), он не сможет получить "мусорные" данные от других процессов. При всём желании. Т.к. смотрим, что написано в документации наиболее распространённых операционных систем: Windows (если говорить про desktop) и Linux (если говорить про серверный <!--[[[рынок]]]-->сегмент).<br />
В Windows любая аллокация памяти (malloc, HeapAlloc или самописный аллокатор памяти — неважно) в итоге приводит к системному вызову VirtualAlloc, в <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">документации к которому</a> написано просто и понятно:<br />
<blockquote>Memory allocated by this function is automatically initialized to zero.</blockquote>
В Linux аналогично: в <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">документации к mmap</a> сказано:<br />
<blockquote><b>MAP_ANONYMOUS</b><br />
The mapping is not backed by any file; its contents are initialized to zero.</blockquote>
Да, есть ещё флаг <b>MAP_UNINITIALIZED</b>, но он требует включения специальной опции при сборке ядра и на практике используется только в мире embedded-устройств.<br />
<br />
P.S. <!--[[[Хотя]]]-->Да, разумеется, гарантированно зануляет память не каждая операционная система, но <!--[[[я почему-то ]]]-->давайте <!--[[[быть/]]]-->будем честными: кто из нас писал программы под операционные системы, которые этого не делают? Я вот не писал, и, возможно, никогда и не буду. Так зачем мне об этом думать? Думать о том, что мой язык программирования будет неэффективно работать на системах, <!--[[[на которых]]]-->под которые практически никто не пишет. Пусть те, кто <!--[[[на]]]-->под них пишет, выбирают другой язык программирования (если для них это настолько критично), <!--[[[дабы/]]]-->благо выбрать есть из чего.<br />
Причём заметьте, я сказал «будет неэффективно работать», а не «вообще не будет работать» <span class="sq"><span class="sq_brackets">[</span>на таких системах<span class="sq_brackets">]</span></span>. Ибо, когда из исходного кода компилятор <!--[[[собирает/]]]-->генерирует исполняемый двоичный файл, это всегда производится для <i>конкретной</i> архитектуры процессора и для <i>конкретной</i> операционной системы. <span class="sq"><span class="sq_brackets">[</span>Даже если взять платформы наподобие .NET Framework, где приложения распространяются на некоем промежуточном языке, то в конечном счёте для выполнения программы должен получиться машинный код под конкретную архитектуру и операционную систему.<span class="sq_brackets">]</span></span> Таким образом, компилятор в любом случае знает, будет ли полученная от системы память гарантированно занулена или не будет, и во втором случае просто добавит <pre class="inline_code">memset(mem, 0, size)</pre> и программа будет корректно работать, пусть и не так эффективно (особенно<!--[[[, если выделяется огромный блок]]]--> в случае выделения огромного блока памяти, который будет использоваться лишь частично).<br />
<hr />
2024-02-20 <i><b>veector</b></i><br />
<br />
<blockquote>... но давайте быть честными: кто из нас писал программы под операционные системы, которые этого не делают?</blockquote>
Например, я, причем это 99% моей непосредственной работы.<br />
<hr />
2024-02-20 <i><b>Автор сайта</b></i><br />
<br />
<blockquote>выражение «если-иначе» — это всё хорошо, но я хотел сделать акцент на другом. А именно, на случаях очень сложных инициализаций.</blockquote>
Думаю, при должной старательности сложные инициализации можно упростить. Или даже выделить инициализацию в отдельную функцию, ведь return не может возвратить неинициализированное значение. В примерах выше условный оператор был превращён в условное выражение, то есть конструкцию, возвращающую аргумент. Можно подумать над тем, чтобы и цикл что-то возвращал, тогда он будет не оператором цикла, а выражением цикла.<br />
<br />
<blockquote>в n окажется начальное значение 0, и при этом возможно возникновение очень трудно уловимой ошибки.</blockquote>
А если нулём прописывается указатель, то вообще беда.<br />
<br />
<blockquote>необходимо проверить, что n инициализируется на всех путях выполнения</blockquote>
Вот поэтому проще сделать единственное инициализирующее выражение, пусть и с сложными выражениями и циклами, чем что-то отслеживать.<br />
<br />
<blockquote>Если честно, не очень понимаю, что вы имели в виду. Я говорил как раз о том, чтобы, наоборот, не занулять явно память полученную от системы</blockquote>
Имел в виду не «занулять» (в том числе и бессмысленно, лишь бы чем-то проинициализировать), а присваивать осмысленное значение, вытекающее из логики алгоритма.<br />
<br />
<blockquote>какой бы язык программирования не выбрал программист (да хоть даже ассемблер), он не сможет получить "мусорные" данные от других процессов. При всём желании.</blockquote>
Чтобы бороться с преступниками, надо думать как преступники. Вообразите, что вам надо украсть миллиард с банковского счёта. Вы и операционку пропатчите, чтобы она не обнуляла память при выделении, и язык себе выберете без гарантированной инициализации.<br />
<br />
<blockquote>кто из нас писал программы под операционные системы, которые этого не делают?</blockquote>
Я писал! При этом я писал под Windows. По-моему (но могу ошибиться), Windows XP ещё не обнуляла память, а началось это с Vista. Иногда сталкивался с тем, что программа начинает вести себя по-другому просто от добавления ещё одной переменной. Тогда понимаешь, в чём дело, и ищешь: где это я забыл проинициализировать? Изменение поведения от того, что не может поменять поведение, как раз и было признаком невыполненной инициализации.<br />
<br />
<blockquote>мой язык программирования будет неэффективно работать на системах, под которые практически никто не пишет.</blockquote>
ОС РВ — вполне себе достойная уважения ниша. Имеют право не обнулять память потому, что перечень установленных программ там заранее зафиксирован.<br />
<br />
<blockquote>я сказал «будет неэффективно работать»</blockquote>
Неэффективность будет связана с двукратной записью в одни и те же участки памяти: сперва нуля, а потом собственно значения. Но не трёх и более кратной записью. Так что максимальное торможение — максимум в 2 раза. В реальности меньше, потому что есть ещё статическая память, операции регистр-регистр, есть кэш процессора и т.д. Кстати, в ОС жёсткого реального времени динамического выделения памяти нет. Память выделяется статически. Там эта тема не актуальна.<br />
<hr />
2024-02-22 <i><b>alextretyak</b></i><br />
<br />
<b>veector</b><br />
<blockquote>Например, я, причем это 99% моей непосредственной работы.</blockquote>
Было бы интересно увидеть больше конкретики. Что за операционная система(-ы), что за архитектура процессора, <!--[[[где можно]]]-->есть ли возможность посмотреть документацию онлайн...<br />
<!--[[[
Не обижайтесь, но [[[по вашим ответам]]]от ваших ответов, как бы это сказать... веет дилетантством.
[[[
если бы вы действительно имели опыт низкоуровневого программирования.]]]
> Как я уже замечал ранее, современная тенденция в разработке аппаратуры — проецировать в адресное пространство процессоров не только ОЗУ, а вообще все на свете.
А я вижу обратную тенденцию: пихать даже в простейшие контроллеры[?] современные ARM процессоры.
]]]--><!--[[[
2024-02-21 08:04:15
Сообщение не отправил, т.к. будильник в телефоне не сработал и даже телефон был выключен в 7:30 [у меня настроено автовключение в 6:00].
]]]--><br />
<b>Автор сайта</b><br />
<blockquote>Чтобы бороться с преступниками, надо думать как преступники. Вообразите, что вам надо украсть миллиард с банковского счёта. Вы и операционку пропатчите, чтобы она не обнуляла память при выделении, и язык себе выберете без гарантированной инициализации.</blockquote>
Патчить ядро Windows для доступа к чужой памяти? Зачем ломать стену, когда рядом есть дверь? :)(:<br />
Помнится, ещё <!--[[[на]]]-->в Windows <!--[[[XP]]]-->95 или 98 я использовал программу ArtMoney для получения бесконечных <!--[[[жизней/]]]-->денег в играх. Когда узнал, как она работает, был весьма удивлён — штатными средствами WinAPI (а именно, функциями ReadProcessMemory/WriteProcessMemory) можно получить доступ к памяти любого другого процесса. Хотя, начиная с Vista эти функции требуют <!--[[[админских]]]-->административных привелегий.<br />
<br />
<blockquote>По-моему (но могу ошибиться), Windows XP ещё не обнуляла память, а началось это с Vista.</blockquote>
Обнуляла<!--[[[ [начиная как минимум с Windows NT]]]]-->. Но<!--[[[, [[[ещё раз ]]]обратите внимание, я говорил]]]--> речь только про системную функцию VirtualAlloc. Она обнуляла память всегда с момента своего появления в Windows NT, вот только <!--[[[я очень сомневаюсь что вы ра]]]-->в прикладных программах эта функция непосредственно, как правило, не используется, т.к. она выделяет только блоки размером кратным 64Кб. В программах на Си чаще всего используется библиотечная функция malloc(), а в C++ — оператор new, который стандартно реализован через вызов того же malloc(). А вот память, которую вернул malloc(), далеко не всегда занулена (собственно, поэтому есть отдельная функция — calloc(), которая возвращает занулённый блок памяти): во-первых, в Debug-сборках реализация malloc() перед тем как вернуть указатель заполняет каждый байт выделенного блока памяти значением 0xCD (как раз таки для обнаружения обращений к неинициализированным данным). И, во-вторых, malloc() может вернуть блок памяти, который был ранее освобождён функцией free(), и в этом блоке <!--[[[останется]]]--> будут "мусорные" данные, вот только не от других процессов, а от <!--[[[данного]]]-->этого же процесса, записанные им в свою память <!--[[[в процессе]]]-->во время его предыдущей работы.<br />
<hr />
2024-02-22 <i><b>veector</b></i><br />
<br />
<b>alextretyak</b>, много всяких разных, наверное, всё, что придумается в embedded сфере, причем, всевозможных версий.<br />
Более подробно, увы, не скажу.<br />
</div>
</body>
</html>