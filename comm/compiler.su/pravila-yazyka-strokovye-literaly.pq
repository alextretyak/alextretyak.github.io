Н‘‘Правила языка: строковые литералы (ссылка на статью)’[http://compiler.su/pravila-yazyka-strokovye-literaly.php]’

Комментарии:
---
2023-05-22 ~‘*‘kt’’

Я бы ещё добавил коэффициент повторения для текстовых констант, аналогично PL/1, например:
#‘
dcl x bit(64) static init('1'(64)b); // все единицы 
’
#‘
put skip list('='(50),'Начало','='(50)); // заголовок из равенств
’
---
2023-05-23 ~‘*‘Автор сайта’’

Думал над этой фичей, но простых вариантов в голову не пришло. Решил, что лучше обойтись (Си обходится же), сделать язык сложным успеется всегда. Впрочем, можно использовать строковую функцию с условным названием «размножить», которая ‘с константными аргументами отработает во время компиляции’[http://compiler.su/makrosy-eto-chistye-funktsii-ispolnyaemye-vo-vremya-kompilyatsii.php], результат будет таким же.

Но ничто не мешает вернуться к этому вопросу. Лексический анализатор хоть и в основном написан, но дополнить его можно в любое время.
---
2023-05-29 ~‘*‘alextretyak’’

А чем не устраивает решение как в Python, а именно оператор умножения (*)?
#(Python)‘
s = 5 * '-' # равнозначно s = '-----'
’
---
2023-05-29 ~‘*‘Автор сайта’’

Философия Питона предполагает принцип наименьшего удивления. Однако ожидания прикладных программистов на Питоне не совпадает с ожиданиями системных программистов на Си или Rust. Системные программисты помнят, что литера '-' соответствует числу 45. Поэтому ~‘*‘5 * '-'’’ эквивалентно ~‘*‘5 * 45’’ и даёт 225. Если Вы попробуете, то убедитесь в этом.

Допустим, мы поменяем '-' на "-", чтобы иметь дело не с отдельной литерой, а со строкой, длина которой 1. Но что такое 5 умножить на число n? Это сложить 5 с самой собой n раз. Но как сложить 5 с самой собой "-" раз? Ведь "-" не является числом.

Было бы логичнее записать ~‘*‘"-" * 5’’, тогда бы это значило ~‘*‘"-" + "-" + "-" + "-" + "-"’’. Это уже ближе к истине, если рассматривать операцию «+» как склейку строк. Но в любом случае надо 7 раз отмерить. Пока что острой необходимости в этом в первой версии нет, торопиться не будем.

Посмотрел раздел «Строковые литералы» на Вашем сайте, там эта тема не затронута :([[[)]]]
---
2023-05-31 ~‘*‘alextretyak’’

> литера '-' соответствует числу 45. Поэтому ~‘*‘5 * '-'’’ эквивалентно ~‘*‘5 * 45’’ и даёт 225.
Да, верно.
А я уже и забыл про такую особенность языка Си.
Но дело в том, что на практике такая "особенность" никогда не требуется {
Здесь ‘я имею в виду’/речь только про умножение символьного литерала на число [или умножение числа на символьный литерал], т.к. сложение символьного литерала с числом имеет практическое применение (например: *‘'0' + i’ для получения символа-цифры *‘i’ [при этом *‘i’ должно быть от 0 до 9] или *‘'a' + n’ для получения *‘n’-ной буквы латинского алфавита).
}, и связана[[[ лишь]]] скорее всего с тем, что в Си было невозможно ввести [отдельный/]полноценный тип для символа (который было бы запрещено умножать на число), поэтому тип *‘char’ по факту совпадает с типом *‘int8_t’. Такую "фичу" я бы смело добавил в ‘«Признаки устаревшего языка»’[http://compiler.su/priznaki-ustarevshego-yazyka.php].
[[[
> не совпадает с ожиданиями системных программистов на Си или Rust. ... Если Вы попробуете, то убедитесь в этом.
Ну вот в Rust, кстати, такое не прокатывает: умножение символьного литерала на число приводит[https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ab079d95b778081bb189569d91561730] к ошибке компиляции.
]]]
> В Rust нет такого автоматического преобразования. Приведение типов надо делать явно.
Да, а вот в Java и C#, на удивление, оставлено поведение Си (могли бы хоть warning\предупреждение выдавать в таких случаях).

> Посмотрел раздел «Строковые литералы» на Вашем сайте, там эта тема не затронута :([[[)]]]
Не затронута, т.к. конструкции вида *‘5 * "-"’ не являются строковыми литералами [также как *‘5 * 45’ не является целочисленным литералом, хотя и является целочисленным константным выражением (integral constant expression) и может использоваться везде[‘например, выражения в метках `case`, размер[[[ность]]] статических массивов, значения перечислителей\enumerators’], где могут использоваться только целочисленные константы[‘константные выражения’]/литералы].
В 11l, так[[[ ]]]же как в Python, можно умножать число на строку (в т.ч. на строковый литерал).

[[[Вообще]]]И хочу добавить, что разделение символьных и строковых литералов мне категорически не нравится {например тем, что можно написать `s.find('\n')`, а можно `s.find("\n")`, что даёт одинаковый результат, но при этом первая запись [[[будет ]]][[[значительно]/]]будет эффективнее}. Поэтому в 11l такого разделения нет, а есть "сырые" (например `‘\’`) и "не сырые" (например `"\\"` [что равнозначно `‘\’`]) строковые литералы, фактический тип которых (*‘Строка’ либо *‘Символ’) определяется при компиляции в зависимости от контекста использования этого литерала:
#(11l)‘
пер м1 = [‘а’, ‘б’, ‘в’] // это массив символов
пер м2 = [‘а’, ‘бб’, ‘в’] // а это массив строк

пер с = ‘-’ // это строка; если требуется символ, то следует писать пер с = Символ(‘-’)
вывод(‘-’.код) // выведет 45 (в таком контексте ‘-’ считается символом, а не строкой)

пер м3 = [Строка(‘а’), ‘б’, ‘в’] // это массив строк
’

Вообще, я подумываю над тем, чтобы строковые литералы, состоящие всего из одного символа [т.е. длина которых равна 1], всегда преобразовывались в тип *‘Символ’ [в таком случае вместо *‘пер с = ‘-’’ в примере выше придётся писать *‘пер с = Строка(‘-’)’ или *‘Строка с = ‘-’’], но для принятия [однозначного/]окончательного [[[вывода/]]]решения мне пока ещё [[[нужно больше]/]]не хватает данных.

> Пока что острой необходимости в этом в первой версии нет
Да, умножение числа на строку требуется достаточно редко, но вот аналогичное умножение булевой переменной/выражения на строку нужно намного чаще (например, в коде[https://sourceforge.net/p/pqmarkup/code/ci/default/tree/pqmarkup.py] моей реализации pqmarkup оно встречается 15 раз).
[[[
> Но что такое 5 умножить на число n? Это сложить 5 с самой собой n раз. Но как сложить 5 с самой собой "-" раз? Ведь "-" не является числом.
Следуя такой логике: ~‘5x’ означает сложить 5 с самой собой ~‘x’ раз. Но если ~‘x = 1.5’, то как сложить 5 с самой собой 1.5 раз? А вот сложить 1.5 с самой собой 5 раз прекрасно получается.
]]]
