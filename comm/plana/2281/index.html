<html>
<head>
<meta charset="utf-8" />
<base target="_blank">
<script type="text/javascript">
function spoiler(element, event)
{
    if (event.target.nodeName == 'A' || event.target.parentNode.nodeName == 'A' || event.target.onclick)//чтобы работали ссылки в спойлерах и спойлеры2 в спойлерах
        return;
    var e = element.firstChild.nextSibling.nextSibling;//element.getElementsByTagName('span')[0]
    e.previousSibling.style.display = e.style.display;//<span>…</span> must have inverted display style
    e.style.display = (e.style.display == "none" ? "" : "none");
    element.firstChild.style.fontWeight =
    element. lastChild.style.fontWeight = (e.style.display == "" ? "normal" : "bold");
    event.stopPropagation();
    //[-Чтобы была возможность выделять текст внутри раскрытого ‘скрытого текста’/спойлера, необходимо [скрытие/]закрытие спойлера делать не просто по нажатию левой кнопки мыши, а по отпусканию левой кнопки мыши при условии отсутствия движения курсора [мыши] после того, как была нажата левая кнопка мыши.-]
}
function spoiler2(element, event)
{
    element.nextSibling.style.display = (element.nextSibling.style.display == "none" ? "" : "none");
}
</script>
<style type="text/css">
div#main, td {
    font-size: 14px;
    font-family: Verdana, sans-serif;
    line-height: 160%;
    text-align: justify;
}
span.cu_brackets_b {
    font-size: initial;
    font-family: initial;
    font-weight: bold;
}
a {
    text-decoration: none;
    color: #6da3bd;
}
a:hover {
    text-decoration: underline;
    color: #4d7285;
}
h1, h2, h3, h4, h5, h6 {
    margin: 0;
    font-weight: 400;
}
h1 {font-size: 200%; line-height: 130%;}
h2 {font-size: 180%; line-height: 135%;}
h3 {font-size: 160%; line-height: 140%;}
h4 {font-size: 145%; line-height: 145%;}
h5 {font-size: 130%; line-height: 140%;}
h6 {font-size: 120%; line-height: 140%;}
span.sq {color: gray; font-size: 0.8rem; font-weight: normal; /*pointer-events: none;*/}
span.sq_brackets {color: #BFBFBF;}
span.cu_brackets {cursor: pointer;}
span.cu {background-color: #F7F7FF;}
abbr {text-decoration: none; border-bottom: 1px dotted;}
pre {margin: 0;}
pre, code {font-family: 'Courier New'; line-height: normal}
ul, ol {margin: 11px 0 7px 0;}
ul li, ol li {padding: 7px 0;}
ul li:first-child, ol li:first-child {padding-top   : 0;}
ul  li:last-child, ol  li:last-child {padding-bottom: 0;}
table {margin: 9px 0; border-collapse: collapse;}
table th, table td {padding: 6px 13px; border: 1px solid #BFBFBF;}
span.spoiler_title {
    color: #548eaa;
    cursor: pointer;
    border-bottom: 1px dotted;
}
div.spoiler_text {
    /*border: 1px dotted;*/
    margin: 5px;
    padding: 3px;
}
blockquote {
    margin: 0 0 7px 0;
    padding: 7px 12px;
}
blockquote:not(.re) {border-left:  0.2em solid #90ddaa; background-color: #fbfffb;}
blockquote.re       {border-right: 0.2em solid #90ddaa; background-color: #f4fff8;}
div.note {
    padding: 18px 20px;
    background: #ffffd7;
}
pre.code_block {padding: 6px 0;}
pre.inline_code {
    display: inline;
    padding: 0px 3px;
    border: 1px solid #E5E5E5;
    background-color: #FAFAFA;
    border-radius: 3px;
}
img {vertical-align: middle;}

div#main {width: 100%;}
@media screen and (min-width: 1050px) {
    div#main {width: 1024px;}
}
</style>
</head>
<body>
<div id="main" style="margin: 0 auto">
<h3>Ivan (ИванАс) хвалится достижениями, но не показывает исходники <a href="http://plana.mybb.ru/viewtopic.php?id=2281">(ссылка на тему)</a></h3>
<br />
<hr />
2024-09-14 <i><b>alextretyak</b></i><br />
<br />
А вы случайно не <a href="http://compiler.su/entuziasty-razrabotchiki-kompilyatorov-i-ikh-proekty.php#96">тот самый Иван Горчаков</a>, разработчик языка программирования GAZ?<br />
<br />
<blockquote><i>Ivan</i>:<br />
Как плохо что вы не программируете, а то можно было что-то вместе сделать, а так -  нет.</blockquote>
Совместная работа над программным проектом (даже совсем небольшим, состоящим из одного исходного файла) в 2024 году предполагает обязательное использование системы управления версиями (например, Git). Вы же её используете?<br />
И я согласен с Лисом в том, что исходный код имеет смысл открыть, иначе желающих подключиться к вашему проекту для совместной работы попросту не будет.<br />
<br />
Но ладно, это дело ваше <span class="sq"><span class="sq_brackets">[</span>открывать код или нет<span class="sq_brackets">]</span></span>.<br />
<br />
А я хочу предложить вам поучаствовать в смежном проекте — составлении русскоязычной документации по архитектуре x86-64 с точки зрения машинных команд <a href="https://ru.wikipedia.org/wiki/Защищённый_режим">защищённого режима</a>.<br />
Т.к. вы в эту тему (кодирование инструкций x86) погрузились недавно и воспоминания у вас пока ещё свежие (допрашивать разработчиков какого-либо завершённого ассемблера, например Томаша Грыштара (создателя <a href="https://ru.wikipedia.org/wiki/Fasm">fasm</a>) смысла мало — им это уже не интересно и подробностей от них не добиться).<br />
Меня интересуют детали того, как именно кодируются инструкции, с самого начала. Например, почему <pre class="inline_code">mov al, bl</pre> кодируется как <pre class="inline_code">8A C3</pre>? <a href="https://www.felixcloutier.com/x86/mov">Отсюда</a> можно понять, что 8A — это опкод, а C3 как получилось? Судя по всему, это <a href="https://en.wikipedia.org/wiki/ModR/M">ModR/M-байт</a>. Но где про это подробно написано, какую документацию вы используете?<br />
Если постараться, то найти такую информацию и собрать по крупицам, конечно, можно. Но на это лично у меня времени нет. И хотелось бы сэкономить время, не только моё, но и других потенциальных разработчиков русского ассемблера.<br />
<br />
P.S. И насчёт обозначения шестнадцатеричных цифр кириллицей. Почему вам не понравился <a href="http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php">вариант Юрия</a> «abcdef» -> «абцдеф»? (Можно ещё рассмотреть «абсдеф».) Просто из-за того, что в «абвгде» и «abcdef» буква «е» обозначает различные цифры, может возникнуть путаница в процессе коммуникации — опкод 8Е может быть неверно истолкован как 8F. А на данном этапе полностью отказаться от латинских букв всё равно не получится.<br />
<hr />
2024-09-14 <i><b>ИванАс</b></i><br />
<br />
<blockquote>А вы случайно не тот самый Иван Горчаков, разработчик языка программирования GAZ?</blockquote>
Нет, я другой "Иван" <!--[[[(:]]]-->:)<br />
<br />
<blockquote>Совместная работа над программным проектом (даже совсем небольшим, состоящим из одного исходного файла) в 2024 году предполагает обязательное использование системы управления версиями (например, Git). Вы же её используете?</blockquote>
Использую <a href="https://github.com/tigertv/bk0010-01">https://github.com/tigertv/bk0010-01</a><br />
<br />
<blockquote>И я согласен с Лисом в том, что исходный код имеет смысл открыть, иначе желающих подключиться к вашему проекту для совместной работы попросту не будет.</blockquote>
Пока не вижу в этом необходимости, у меня много проектов на гитхабе, но даже с исходными кодами не особо много людей подлючилось. В первую очередь нужно чтобы подлючились пользователи.<br />
<br />
<blockquote>Но ладно, это дело ваше <span class="sq"><span class="sq_brackets">[</span>открывать код или нет<span class="sq_brackets">]</span></span>.</blockquote>
В том то и дело что мое, но почему то тут кто-то настаивает открыть исходники, при этом не хотя заляпаться своими лапками в коде. <br />
<br />
<blockquote>А я хочу предложить вам поучаствовать в смежном проекте — составлении русскоязычной документации по архитектуре x86-64 с точки зрения машинных команд защищённого режима.</blockquote>
Спасибо, за предложение, но пока занят этим проектом.<br />
<br />
<blockquote>Меня интересуют детали того, как именно кодируются инструкции, с самого начала. Например, почему mov al, bl кодируется как 8A C3? Отсюда можно понять, что 8A — это опкод, а C3 как получилось? Судя по всему, это ModR/M-байт. Но где про это подробно написано, какую документацию вы используете?<br />
Если постараться, то найти такую информацию и собрать по крупицам, конечно, можно. Но на это лично у меня времени нет. И хотелось бы сэкономить время, не только моё, но и других потенциальных разработчиков русского ассемблера.</blockquote>
Так в это же общедоступная информация, вот к примеру <a href="https://i.sstatic.net/VTxd0.jpg">https://i.sstatic.net/VTxd0.jpg</a><br />
<br />
<blockquote>P.S. И насчёт обозначения шестнадцатеричных цифр кириллицей. Почему вам не понравился вариант Юрия «abcdef» -> «абцдеф»?</blockquote>
Траслитерация. Не особо что-то меняется, да и проще кодировать - не нужно вводить дополнительную строку для кодирования. Хотя я в принципе не цепляюсь к синтаксису и все обсуждаемо.<br />
<br />
<blockquote>А на данном этапе полностью отказаться от латинских букв всё равно не получится.</blockquote>
Можно попробывать. Мне это интересно с точки зрения экзотики, посмотреть по новому на привычные вещи.<br />
<hr />
2024-09-14 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Спасибо, за предложение, но пока занят этим проектом.</blockquote>
Так в том то и дело, что заниматься такой документацией нужно не вместо вашего проекта, а параллельно!<br />
Т.е. я ни в коем случае не предлагаю вам забрасывать ваш проект, наоборот.<br />
Работа по генерации машинного кода из языка ассемблера включает в себя получение большого количества специфических знаний и документация нужна, чтобы эти знания не потерялись.<br />
Вот есть у нас готовые ассемблеры, даже исходники есть (fasm, nasm). Ну и что толку? Разобраться в них стороннему человеку очень трудно. Проще написать с нуля свою реализацию генерации маш. кода на основе информации из Интернета и официальной документации Intel.<br />
<br />
<blockquote>Так в это же общедоступная информация, вот к примеру https://i.sstatic.net/VTxd0.jpg</blockquote>
Хе. Ясно, что общедоступная. Проблема в том, что этой "общедоступной информации" слишком много! (И большая её часть нерелевантна искомому запросу.)<br />
Нет, если всё бросить и заниматься одной только этой проблемой (генерации маш. кода x86), то может оно и нормально, но я ищу более лёгкий путь.<br />
<br />
Вот дали вы ссылку на эту картинку.<br />
Ну да, картинка красивая, и что? Как с её помощью мне получить машинный код инструкции <pre class="inline_code">lea edx, [eax + ebx*2]</pre>?<br />
А <pre class="inline_code">lea edx, [eax + ebx*2 + 8]</pre>?<br />
А <pre class="inline_code">lea edx, [ebx*2 + 8]</pre>?<br />
А <pre class="inline_code">lea edx, [ebx*2]</pre>?<br />
А <pre class="inline_code">lea rdx, [ebx*2]</pre>?<br />
А <pre class="inline_code">lea rdx, [rbx*2]</pre>?<br />
И т.д. и т.п. (но последние три особенно интересны).<br />
<br />
Узнать опкод нужной инструкции — это элементарно. Для этого красивая таблица не нужна. А вот понимание нюансов, принципы формирования режимов адресации — вот что нужно.<br />
<hr />
2024-09-14 <i><b>ИванАс</b></i><br />
<br />
<blockquote>Так в том то и дело, что заниматься такой документацией нужно не вместо вашего проекта, а параллельно!<br />
Т.е. я ни в коем случае не предлагаю вам забрасывать ваш проект, наоборот.</blockquote>
Дополнительные накладные расходы, есть много информации по кодам, это не так как было доинтернетовскую эпоху когда чтобы получить какую-то информацию, нужно ходить в библиотеку и выписывать журналы.<br />
<br />
<blockquote>Работа по генерации машинного кода из языка ассемблера включает в себя получение большого количества специфических знаний и документация нужна, чтобы эти знания не потерялись.</blockquote>
Возможно, но они уже не становятся специфичными если уже это проходил когда-то.<br />
<br />
<blockquote>Хе. Ясно, что общедоступная. Проблема в том, что этой "общедоступной информации" слишком много! (И большая её часть нерелевантна искомому запросу.)</blockquote>
Информации много, и надо уметь ее находить.<br />
<br />
<blockquote>Ну да, картинка красивая, и что? Как с её помощью мне получить машинный код инструкции <pre class="inline_code">lea edx, [eax + ebx*2]</pre>?</blockquote>
Там внизу описание опкода есть, там SIB байт есть.<br />
Простой способ берешь компилятор ассемблера и компилируешь и получаешь маш.код, конечно компилятор ассемблера из 2 вариантов представления выбирает один, но это нюансы.<br />
<hr />
2024-09-17 <i><b>alextretyak</b></i><br />
<br />
<blockquote>конечно компилятор ассемблера из 2 вариантов представления выбирает один, но это нюансы.</blockquote>
Можете уточнить, что это за 2 варианта представления?<br />
<hr />
2024-09-17 <i><b>ИванАс</b></i><br />
<br />
<blockquote>Можете уточнить, что это за 2 варианта представления?</blockquote>
Я не так сильно много лазил в машинном коде, но такую штуку я знаю:<br />
<pre class="code_block">
    1018:   89 c1                   mov    %eax,%ecx
    101a:   8b c8                   mov    %eax,%ecx
</pre>
Cмотрите на биты:<br />
1000 1001 11 000 001<br />
1000 1011 11 001 000<br />
<hr />
2024-09-17 <i><b>Лис</b></i><br />
<br />
В коде команды (первом байте) есть "бит направления пересылки".<br />
А в байте mod R/M кодируются два регистра - откуда и куда, или куда и откуда.<br />
А в текстовой записи порядок операндов только один (для конкретного синтаксиса).<br />
<br />
Судя по приведённому примеру - это бит, следующий за младшим (т.е. второй, с индексом 1 если считать с нуля)<br />
<blockquote>Cмотрите на биты:<br />
10001001 11000001<br />
100010<b>1</b>1 11001000</blockquote>
<hr />
2024-09-20 <i><b>alextretyak</b></i><br />
<br />
<blockquote><i>Ivan</i>:<br />
Простой способ берешь компилятор ассемблера и компилируешь и получаешь маш.код</blockquote>
А как вы смотрите машинный код, соответствующий определённой инструкции?<br />
Я знаю несколько способов, но вдруг ваш способ более удобный.<br />
<hr />
2024-09-20 <i><b>ИванАс</b></i><br />
<br />
Смотрю через objdump.<br />
<br />
На входе .s файл:<br />
<pre class="code_block">
 15 mov %eax, %ecx
 16 .byte 0x8b, 0xc8
</pre>
В objdump:<br />
<pre class="code_block">
    1000:   89 c1                   mov    %eax,%ecx
    1002:   8b c8                   mov    %eax,%ecx
</pre>
<hr />
2024-09-20 <i><b>alextretyak</b></i><br />
<br />
<blockquote>Смотрю через objdump.</blockquote>
А с какими ключами вы его запускаете?<br />
Я пробовал разные: и -s, и -d, и без параметров. И у меня всегда выдаёт:<br />
<pre class="code_block">
objdump: test.s: File format not recognized
</pre>
<br />
objdump же вроде как принимает только машинный код (исполняемые файлы или объектные <pre class="inline_code">.o</pre>). Разве ему можно скормить <pre class="inline_code">.s</pre> файл?<br />
<hr />
2024-09-20 <i><b>ИванАс</b></i><br />
<br />
.s файл компилируется, получается исполнимый или объектный файл. Его и смотришь в objdump.<br />
К примеру так<br />
objdump -d ./main<br />
Вообще, есть описание для objdump, запускается просто:<br />
man objdump<br />
<br />
Не понимаю почему у вас возникают с этим сложности?<br />
<hr />
2024-09-20 <i><b>alextretyak</b></i><br />
<br />
<blockquote>.s файл компилируется</blockquote>
Почему "компилируется"? Правильнее сказать "ассемблируется", вы же используете <pre class="inline_code">as</pre> или чем вы <pre class="inline_code">.s</pre> файл "компилируете"?<br />
<br />
<blockquote>Не понимаю почему у вас возникают с этим сложности?</blockquote>
Не то, чтобы сложности. Просто опыта работы в Linux у меня немного. И мой вопрос был про другое: получить машинный код, соответствующий определённой инструкции, <b>один раз</b> — это не проблема, даже если это займёт несколько минут. Но когда нужно проделать это десятки (а то и сотни) раз, то хочется максимально упростить этот процесс. Пока что, на основе вашего предложения я составил такую составную команду:<br />
<pre class="code_block">
echo mov %eax, %ecx | as &amp;&amp; objdump -d a.out
</pre>
<br />
Это для AT&amp;T-синтаксиса, который мне очень не нравится. Поэтому, вот вариант для Intel-синтаксиса:<br />
<pre class="code_block">
echo mov ecx, eax | as -msyntax=intel -mnaked-reg &amp;&amp; objdump -d a.out
</pre>
<br />
Вот примерно такой ответ я и ожидал получить. Или вы всё это делаете руками каждый раз заново (редактируете <pre class="inline_code">.s</pre> файл, затем запускаете <pre class="inline_code">as</pre>, а потом <pre class="inline_code">objdump</pre>)?<br />
<hr />
2024-09-20 <i><b>ИванАс</b></i><br />
<br />
<blockquote>Правильнее сказать "ассемблируется", вы же используете as или чем вы .s файл "компилируете"?</blockquote>
Причем тут правильность? Я вам мысль доношу. Конечно на этой почве можно холивар устроить, но зачем?<br />
Вики:<br />
<blockquote class="re">Компиля́тор — программа, переводящая написанный на языке программирования текст в набор машинных кодов</blockquote>
В чем противоречие у вас? Есть много различных слов описывающее тоже самое. "Правильность" определяйте сами, мне не интересно опускаться до этих деталей.<br />
<br />
<blockquote>Но когда нужно проделать это десятки (а то и сотни) раз, то хочется максимально упростить этот процесс. Пока что, на основе вашего предложения я составил такую составную команду:</blockquote>
Делайте как можете, все зависит от ваших задач.<br />
<br />
<blockquote>Вот примерно такой ответ я и ожидал получить. Или вы всё это делаете руками каждый раз заново (редактируете .s файл, затем запускаете as, а потом objdump)?</blockquote>
Я делаю как мне удобно. Если у вас уже есть ответ, то тогда зачем спрашивать? Мы же не играем игру "экзаменатор-проверяемый".<br />
<hr />
2024-09-20 <i><b>Лис</b></i><br />
<br />
Ответ немного слишком резкий. Но в целом мы поняли, что задачи различаются у разных разработчиков<br />
и поэтому кто-то хочет сделать что-то одно, кто-то другое и ему не надо делать так, как это пытается сделать другой (первый) разработчик.<br />
<hr />
2024-09-20 <i><b>ИванАс</b></i><br />
<br />
<blockquote>Ответ немного слишком резкий.</blockquote>
Ответ справедливый.<br />
<hr />
2024-09-21 <i><b>alextretyak</b></i><br />
<br />
<b>Ivan</b><br />
<blockquote>Причем тут правильность?</blockquote>
Притом, что в командной строке нельзя написать "скомпилируй test.s".<br />
<!--[[[
#rec##audio#[REC_0003364.wav][по дороге к СвН собору]
А вот если бы вы сказали "ассемблируется .s файл", тогда это бы сподвигло меня к поиску хотя бы.
]]]-->Если бы вы сказали ".s файл ассемблируется", тогда это бы сподвигло к поиску хотя бы.<br />
<!--[[[
И если лично для вас фраза ".s файл компилируется, получается исполнимый или объектный файл" очевидна, то для меня [и многих других читателей этого форума] — нет.
Вообще, под эту фразу больше подходит команда gcc -c test.s (которая равнозначна as test.s).
]]]--><br />
И вы зря недооцениваете правильность. <!--[[[То]]]-->От того, что лично вы сэкономили себе пару минут на выборе наиболее подходящего слова/термина, собеседник потратит десятки минут, пытаясь понять, что же вы имели в виду. И в результате, всё равно поймёт вас неправильно, и всё это выльется в нелепую перебранку.<br />
Так что, выбор подходящих слов очень важен при совместной работе и вообще при любой коммуникации.<!--[[[ А если вам не нужна коммуникация, почему тогда вы ведёте эту тему на публичном форуме, а не в личном блоге с отключенными комментариями?]]]--><br />
<br />
<blockquote>Компиля́тор — программа, переводящая написанный на языке программирования текст в набор машинных кодов</blockquote>
И всё же, никто не называет утилиту <pre class="inline_code">as</pre> компилятором, это ассемблер.<br />
<br />
<blockquote>Я делаю как мне удобно.</blockquote>
Да, пожалуйста, делайте. Но от того, что вы поделитесь информацией с другими, знаний у вас меньше не станет, верно?<br />
Такова особенность информации, в отличие от каких-либо материальных вещей — при передаче вещи у её прежнего владельца вещь пропадает, а при передаче информации происходит её копирование.<br />
<br />
<blockquote>Если у вас уже есть ответ, то тогда зачем спрашивать?</blockquote>
Затем, что ваш ответ может оказаться лучше, чем мой. "Лучше" в данном случае — более удобная/короткая команда, более удобный формат вывода.<br />
Я, кстати, своим ответом не удовлетворён (и поэтому не считаю, что у меня "уже есть ответ"). Мне бы хотелось видеть только машинный код, без лишней информации, которую выдаёт objdump.<br />
<br />
<blockquote>Мы же не играем игру "экзаменатор-проверяемый".</blockquote>
Очень жаль, что вы это так восприняли.<br />
Я написал эту <!--[[[составную ]]]-->команду не для того, чтобы <!--[[["]]]-->похвастаться<!--[[["]]]--> или показать "правильный вариант ответа". А для того, что вдруг она окажется полезной (если не вам, то кому-нибудь из читателей этого форума). А также <!--[[[для того, чтобы]]]-->на случай если кто-то увидит её и при этом знает способ лучше, чтобы он мог об этом сообщить.<br />
<br />
Выбор удобных инструментов очень важен для продуктивной работы. И совместно <!--[[[выработать/]]]-->подобрать оптимальный набор инструментов проще, чем по одиночке. У каждого из нас есть пробелы в знаниях. Я вполне могу знать то, чего не знаете вы. А вы — знать то, чего не знаю я.<br />
</div>
</body>
</html>