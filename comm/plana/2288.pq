Н‘статья "Симкод — современный язык ассемблера" ‘(ссылка на тему)’[http://plana.mybb.ru/viewtopic.php?id=2288]’

---
2024-09-01 ~‘*‘Лис’’

[https://habr.com/ru/articles/840070/]

«Начну с определений»

А надо бы было с аннотации, практической значимости работы, целей и юзкейсов.

«с Си-подобным синтаксисом»

Не хотим знать Си, он вражеский.

«ассемблерной команде add rax, rbx»

Ой, всё. ‘Марков, Андрей Андреевич’[https://ru.wikipedia.org/wiki/Марков,_Андрей_Андреевич_(младший)] не стеснялся математические множества русскими буквами называть.

«завершённого и проработанного проекта я не встречал»

И это не он (проработанный проект). Надо ведь будет всё что там на питоне переписать на ассемблере,
иначе не будет бутстрапа. И надо всё это разъяснить, потому что питон тоже не все знают. Разные цели.

«довольно много неактуальных и ненужных терминов и понятий (и, кстати, в IT-отрасли в целом, как я считаю)»

И прямо в статье вводятся новые понятия с новыми определениями. Прям первыми строками (0‘`Симкод`, `Симкоманда`’)

Ну допустим, что это такой макроассемблер. Как мне его интегрировать поверх своего, что для такой интеграции заготовлено?
---
2024-09-01 ~‘*‘ИванАс’’

Тоже полезно.
Практическая работа.
---
2024-09-12 ~‘*‘alextretyak’’

*‘Лис’
Если вы это всерьёз, то грустно как-то получается, товарищи. (Когда не видят/не понимают [[[самых/]]][[[достаточно/]]]вполне[[[/совсем]]] очевидных вещей. [[[Но]]]Имея при этом имперские[http://plana.mybb.ru/viewtopic.php?id=2303#p10469] амбиции.)
Нет, я не обижаюсь. И разъяснения мне дать нетрудно. Вопрос только, [[[какой ]]]будет ли в этом толк...

>‘Лис’:‘«Начну с определений»

А надо бы было с аннотации, практической значимости работы, целей и юзкейсов.’
Статья начинается с заголовка. Вы его точно читали? :)(:
Напомню: "Симкод — современный *‘язык ассемблера’".
И этим всё сказано. Тут вам и практическая значимость, и цели, и варианты/сценарии использования. Или вы не знаете, что такое «язык ассемблера» и для чего он нужен?

Язык ассемблера нужен для наглядного представления результатов компиляции языка программирования высокого уровня в машинный код, проще говоря: чтобы убедиться в том, что компилятор не выдал какую-то пургу. Анализировать современный машинный код x86-64 на порядок-два труднее, чем код на языке ассемблера.
(Также настоятельно рекомендую прочесть ‘этот мой комментарий’[https://habr.com/ru/articles/840070/comments/#comment_27233752] к статье и ‘сравнение симкода с C--’[https://github.com/symasm/ru/issues/1].)

Чем не устраивает/плох традиционный язык ассемблера для x86?
1. Раньше, когда различных инструкций в типичных программах использовалось мало, он был хорош, но сейчас всё изменилось. Современная система команд x86-64 с расширениями включает в себя свыше 1000[https://www.felixcloutier.com/x86/] мнемоник и более 6000[https://fgiesen.wordpress.com/2016/08/25/how-many-x86-instructions-are-there/ <- https://www.reddit.com/r/hardware/comments/9bqk8s/how_many_x86_instructions_are_there/ <- google:‘how many x86 instructions’] различных инструкций (если считать по опкодам). Более того, если раньше отличия в мнемониках были хорошо заметны (например, ADD, SUB, CMP), то теперь многие [[[инструкции/]]]мнемоники отличаются лишь в одной букве: VADDSD осуществляет скалярное сложение, а VADDPD — векторное; VCVTSI2SS воспринимает регистр-источник как целое число, а VCVTSD2SS — как вещественное двойной точности ([[[и ]]]обе эти инструкции преобразуют исходное значение в вещественное одинарной точности).
2. Слишком сильно привязан к английскому языку. Если избавиться от мнемоник, то перевести с английского достаточно только имена регистров.

И т.к. в настоящее время на языке ассемблера код уже не пишут (кроме очень редких случаев), и язык ассемблера сейчас [[[нужен]]]используют только для [[[удобного ]]]чтения сгенерированного машинного кода, то современный язык ассемблера имеет смысл ориентировать именно на [[[чтение]]]максимальную читаемость кода. И симкод претендует на то, чтобы быть таким [[[современным ]]]языком.

>‘«довольно много неактуальных и ненужных терминов и понятий (и, кстати, в IT-отрасли в целом, как я считаю)»

И прямо в статье вводятся новые понятия с новыми определениями. Прям первыми строками (0‘`Симкод`, `Симкоманда`’)’
[[[
#rec##audio#[REC_0003354.wav][вышел из Овита на 100лет 68а]
Симкод — это не термин, это название языка ассемблера. Также как C++ — это не термин, и Python — это не термин, 11l — это не термин.
]]]Симкод — это не термин/понятие, это название языка ассемблера. Также как C++ — это не термин, и Python — это не термин.
Если вас интересует более детальное [чем в данной статье] обоснование выбора такого названия, то симкод в чём-то созвучен понятию автокод[https://ru.wikipedia.org/wiki/Автокод] и по задумке будет:
. си*‘м’код — символьный *‘м’ашинный код (язык ассемблера, т.е. язык самого низкого уровня) и
. си*‘п’код — символьный *‘п’ромежуточный код (аналог языка LLVM IR, т.е. язык промежуточного представления, который, как можно догадаться, основан на символьной записи, в отличие от языка LLVM, который основан на мнемониках).
(И для обоих «си-кодов» планируется поддержка русского языка.)

>‘«ассемблерной команде add rax, rbx»

Ой, всё. Марков, Андрей Андреевич не стеснялся математические множества русскими буквами называть.’
Как я уже писал в статье: «у меня уже есть достаточно хороший вариант перевода [всего симкода, в т.ч. всех регистров x86-64, разумеется]. Но пока что разглашать я его не буду.»
Не буду до тех пор, пока не выскажутся все заинтересованные в таком переводе.
Вас, кстати, я тоже приглашаю поучаствовать (в самом конце статьи есть ссылки на текстовый файл варианта перевода на 5-ти различных платформах). Но пока что, желающих поучаствовать, увы, не нашлось.

>‘«с Си-подобным синтаксисом»

Не хотим знать Си, он вражеский.’
Поддерживаю (про «вражескость» Си), но прямо написать об этом в статье на Хабре я не мог, вы же понимаете?
Заодно отвечу здесь на ‘вопрос Юрия’[http://compiler.su/o-russkom-assemblere.php#217]:
> Первое возражение: ничего не имею против символа ^ в качестве xor. Ну так сложилось в Си. Ведь симкод — он же на основе Си?
Нет. Симкод не основан на Си. Он основан на 11l[https://11l-wikipedia.github.io/ru]. Именно из него и был позаимствован оператор `(+)`.
И если учить[[[в значении «учить кого-то»]]] язык программирования с нуля (что 11l, что симкод, при этом совсем не зная до этого язык Си и другие Си-подобные языки), то [[[я не смог]]]очень сложно дать разумное обоснование выбор[[[у]]]а символа карет (^) для операции «исключающего ИЛИ». [[[(]]]А обоснование выбора `(+)` достаточно логично, и оно приводится в статье про симкод и в ‘документации к 11l’[https://11l-lang.org/doc/ru/operators].[[[)]]]

>‘«завершённого и проработанного проекта я не встречал»

И это не он (проработанный проект). Надо ведь будет всё что там на питоне переписать на ассемблере,
иначе не будет бутстрапа. И надо всё это разъяснить, потому что питон тоже не все знают.[[[ Разные цели.]]]’
Давайте всё же мухи отдельно, котлеты отдельно.
1. Если вы не согласны с тезисом про завершённость и проработанность, то покажите конкретный пример более завершённого и проработанного проекта [[[символьного ]]]языка ассемблера x86 с символьной записью. Я уже упоминал в статье terse[http://www.terse.com/] и HLA[http://webster.cs.ucr.edu/], которые ‘не поддерживают’[https://masm32.com/board/index.php?topic=286.0 <- google:‘hla x64’] даже x86-64, не говоря про AVX.
2. Реализация симкода написана не на «питоне», а на «компилируемом Python» — подмножестве Python, котор[[[ый]]]ое компилируется в нативный код посредством ‘транспайлера Python → 11l → C++’[https://codeforces.com/blog/entry/103733?locale=ru]. Писать реализацию симкода на самом симкоде (и не важно на английской его версии или на русской) — это глупость и безумие, т.к. симкод вообще не предназначен для написания на нём кода, это во-первых; во-вторых, трудоёмкость[[[ же]]] написания на любом языке ассемблера выше трудоёмкости писания на Python на один[[[/полтора]]]-два порядка, таким образом если текущая реализация (которая переводит только в одну сторону — в симкод) заняла у меня 3 месяца работы, на языке ассемблера это заняло бы *‘минимум’ 30[[[/90]]] месяцев работы (но как человек, который имеет практический опыт написания кода на языке ассемблера, я бы не взялся за такую работу даже за очень хорошие деньги); и в-третьих, использование «компилируемого Python» даёт две "уберфичи": [[[(]]]1) утилита доступна онлайн в браузере благодаря Brython вообще без какой-либо адаптации исходного кода и [[[(]]]2) исходный код утилиты русифицируется буквально на раз-два — сначала посредством транспайлера Python → 11l получается полностью человекочитаемый код на 11l (транспайлер специально разрабатывался так, чтобы сгенерированный им код был почти такой, как если бы он изначально писался не на Python, а на 11l; поэтому я хоть и выбираю для большинства своих проектов язык Python, фактически они получаются уже написанными на 11l; просто Python удобнее отлаживать и запускать, пока не готов полноценный компилятор 11lc). Это раз. И два — путём запуска простенького скрипта (наподобие этого[https://github.com/11l-lang/_11l_to_cpp/blob/master/russian_to_english.py]) из английского кода 11l получится код на русском 11l.
А бутстрап тоже будет, но на уровне 11lc (который будет написан на 11l). Нет смысла бутстрапать симкод.

> Разные цели.
Не торопитесь с выводами. Цели у нас во многом похожи. Во всяком случае, больше, чем кажется на первый взгляд.
---
2024-09-12 ~‘*‘ИванАс’’

> Современная система команд x86-64 с расширениями включает в себя свыше 1000 мнемоник
> Если избавиться от мнемоник,
А каким образом вы хотите от них избавится?
---
2024-09-12 ~‘*‘alextretyak’’

> А каким образом вы хотите от них избавится?
Предложение «Если избавиться от мнемоник, то перевести с английского достаточно только имена регистров.» не нужно понимать буквально как стремление к полному отказу от мнемоник. Это я говорил образно, гиперболизированно.

Если же хотите увидеть, что конкретно я предлагаю, достаточно просто открыть ‘веб-версию консольной утилиты symasm’[http://symasm.org] и вбить команды
#‘
VADDSD xmm0, xmm1, xmm2
VADDPD xmm0, xmm1, xmm2
VCVTSD2SS xmm0, xmm0, xmm1
’
---
2024-09-13 ~‘*‘MihalNik’’

>‘Лис’:‘Не хотим знать Си, он вражеский’
Смотрите шире: там математические знаки.
А Лисы "2+7" читают через "плюс" или "да"?

>‘alextretyak’:‘Если вы это всерьёз, то грустно как-то получается, товарищи.’
Тут надо понимать что в лисопланах сплошь исторические реконструкции и бюрократия ради бюрократии, а у Вас *‘современный’ язык ассемблера.

> Язык ассемблера нужен для наглядного представления результатов компиляции языка программирования высокого уровня в машинный код, проще говоря: чтобы убедиться в том, что компилятор не выдал какую-то пургу
Цель определена верно, работа проделана большая и в духе наших традиций (восходящих к Utkin'у и Юрию) - язык для чтения, словарик, математические знаки.

> Вас, кстати, я тоже приглашаю поучаствовать (в самом конце статьи есть ссылки на текстовый файл варианта перевода на 5-ти различных платформах). Но пока что, желающих поучаствовать, увы, не нашлось.
И это тоже требует немало усилий и времени.
---
2024-10-01 ~‘*‘alextretyak’’

Решил выложить сюда подробное, по пунктам, моё разъяснение того, почему нет смысла делать реализацию [[[симкода/]]]сим-ассемблера (ассемблера симкода) на самом симкоде:
1. Невероятно высокая сложность программирования/реализации на языке ассемблера крупных проектов (а ассемблер для любой современной архитектуры неизбежно будет являться крупным проектом банально по причине большого количества существующих инструкций в современных процессорах).
2. Традиционные языки ассемблера [[[значительно/]]]существенно проще парсить, чем симкод. [[[Синтаксис симкода достаточно непростой[?].]]][[[#rec##audio#[REC_0003374.wav][спускаюсь в лифте дома]]]]Таким образом, реализовать сим-ассемблер ещё сложнее [чем традиционный ассемблер].
3. [[[Код получается write-only и разобраться в нём]]]Разобраться в написанном ассемблерном коде может только тот, кто его написал. Если посмотреть на страницы проектов fasm[https://github.com/tgrysztar/fasm/graphs/contributors], fasm2[https://github.com/tgrysztar/fasm2/graphs/contributors] и fasmg[https://github.com/tgrysztar/fasmg/graphs/contributors], то видно, что [[[у них лишь один контрибьютор — ]]]Томаш Грыштар является *‘единственным’ контрибьютором у этих проектов. И это при том, что fasm является [[[достаточно/]]]всемирно известным проектом и существует много-много лет. После ухода из жизни Томаша, очевидно, никто не возьмётся поддерживать разработку fasm (т.к. существует много других ассемблеров, написанных на Си и более высокоуровневых языках). Томаш совершил подвиг. Но повторять этот подвиг уже нет никакого смысла.
4. Для того, чтобы [[[сохранить/]]]иметь хоть какую-то возможность использовать язык ассемблера [[[в крупном проекте]]]для разработки крупного проекта, приходится использовать макросы. Тот же fasm имеет очень мощный макропроцессор. Я же не вижу смысла делать такую штуку для симкода вообще — макросы используются для написания кода (а симкод нужен для чтения) и это ещё один "недоязык", плодить которые я не хочу.
5. [[[И самое главное. ]]]Код, написанный на языке ассемблера, жёстко привязан к одной архитектуре процессора. Даже если x86 останется с нами навсегда, тот факт, что fasm работает только на одной архитектуре x86 уже сейчас неудобен — на ARM или RISC-V процессоре напрямую запустить fasm не получится. (Да, fasmg может производить машинный код для различных процессорных архитектур, но сам то он работает только на x86.)

В принципе, если поставить задачу реализации только минимального набора ассемблерных инструкций, необходимых для раскрутки ассемблера, то эта задача существенно проще реализации полноценного ассемблера типа fasm, поддерживающего все инструкции архитектуры[[[ набора команд]]] x86. Вот только какое практическое применение у такого "урезанного" ассемблера? Ведь кроме компиляции самого себя он ни на что не пригоден. Чтобы его можно было практически использовать, необходимо добавить поддержку [[[огромного/]]]большого количества инструкций, используемых компиляторами языков высокого уровня. А для реализации такого проекта использовать язык ассемблера абсолютно нецелесообразно (по причинами, которые я только что перечислил [кроме разве что 2-й, которая специфична для сим-ассемблера]). Значит, для реализации полноценного ассемблера [[[необходимо/]]]придётся использовать какой-то более высокоуровневый язык программирования, и необходимо будет переписать[[[ его]]] реализацию ассемблера уже на этом языке. Но тогда возникает вопрос[[[,]]]: а что делать с исходным кодом уже написанного "урезанного" ассемблера? Выкинуть? Ведь ничего другого по сути и не остаётся. Тогда зачем его вообще [[[писать/]]]реализовывать [этот "урезанный" ассемблер]?
