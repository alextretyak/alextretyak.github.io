Н‘Ivan (ИванАс) хвалится достижениями, но не показывает исходники ‘(ссылка на тему)’[http://plana.mybb.ru/viewtopic.php?id=2281]’

---
2024-09-14 ~‘*‘alextretyak’’

А вы случайно не ‘тот самый Иван Горчаков’[http://compiler.su/entuziasty-razrabotchiki-kompilyatorov-i-ikh-proekty.php#96], разработчик языка программирования GAZ?

>‘Ivan’:‘Как плохо что вы не программируете, а то можно было что-то вместе сделать, а так -  нет.’
Совместная работа над программным проектом (даже совсем небольшим, состоящим из одного исходного файла) в 2024 году предполагает обязательное использование системы управления версиями (например, Git). Вы же её используете?
И я согласен с Лисом в том, что исходный код имеет смысл открыть, иначе желающих подключиться к вашему проекту для совместной работы попросту не будет.

Но ладно, это дело ваше [открывать код или нет].

А я хочу предложить вам поучаствовать в смежном проекте — составлении русскоязычной документации по архитектуре x86-64 с точки зрения машинных команд ‘защищённого режима’[https://ru.wikipedia.org/wiki/Защищённый_режим].
Т.к. вы в эту тему (кодирование инструкций x86) погрузились недавно и воспоминания у вас пока ещё свежие (допрашивать разработчиков какого-либо завершённого ассемблера, например Томаша Грыштара (создателя fasm[https://ru.wikipedia.org/wiki/Fasm]) смысла мало — им это уже не интересно и подробностей от них не добиться).
Меня интересуют детали того, как именно кодируются инструкции, с самого начала. Например, почему `mov al, bl` кодируется как `8A C3`? Отсюда[https://www.felixcloutier.com/x86/mov] можно понять, что 8A — это опкод, а C3 как получилось? Судя по всему, это ModR/M-байт[https://en.wikipedia.org/wiki/ModR/M]. Но где про это подробно написано, какую документацию вы используете?
Если постараться, то найти такую информацию и собрать по крупицам, конечно, можно. Но на это лично у меня времени нет. И хотелось бы сэкономить время, не только моё, но и других потенциальных разработчиков русского ассемблера.

P.S. И насчёт обозначения шестнадцатеричных цифр кириллицей. Почему вам не понравился ‘вариант Юрия’[http://compiler.su/shestnadtsatirichnye-i-dvoichnye-konstanty.php] «abcdef» -> «абцдеф»? (Можно ещё рассмотреть «абсдеф».) Просто из-за того, что в «абвгде» и «abcdef» буква «е» обозначает различные цифры, может возникнуть путаница в процессе коммуникации — опкод 8Е может быть неверно истолкован как 8F. А на данном этапе полностью отказаться от латинских букв всё равно не получится.
---
2024-09-14 ~‘*‘ИванАс’’

> А вы случайно не тот самый Иван Горчаков, разработчик языка программирования GAZ?
Нет, я другой "Иван" [[[(:]]]:)

> Совместная работа над программным проектом (даже совсем небольшим, состоящим из одного исходного файла) в 2024 году предполагает обязательное использование системы управления версиями (например, Git). Вы же её используете?
Использую [https://github.com/tigertv/bk0010-01]

> И я согласен с Лисом в том, что исходный код имеет смысл открыть, иначе желающих подключиться к вашему проекту для совместной работы попросту не будет.
Пока не вижу в этом необходимости, у меня много проектов на гитхабе, но даже с исходными кодами не особо много людей подлючилось. В первую очередь нужно чтобы подлючились пользователи.

> Но ладно, это дело ваше [открывать код или нет].
В том то и дело что мое, но почему то тут кто-то настаивает открыть исходники, при этом не хотя заляпаться своими лапками в коде.

> А я хочу предложить вам поучаствовать в смежном проекте — составлении русскоязычной документации по архитектуре x86-64 с точки зрения машинных команд защищённого режима.
Спасибо, за предложение, но пока занят этим проектом.

>‘Меня интересуют детали того, как именно кодируются инструкции, с самого начала. Например, почему mov al, bl кодируется как 8A C3? Отсюда можно понять, что 8A — это опкод, а C3 как получилось? Судя по всему, это ModR/M-байт. Но где про это подробно написано, какую документацию вы используете?
Если постараться, то найти такую информацию и собрать по крупицам, конечно, можно. Но на это лично у меня времени нет. И хотелось бы сэкономить время, не только моё, но и других потенциальных разработчиков русского ассемблера.’
Так в это же общедоступная информация, вот к примеру [https://i.sstatic.net/VTxd0.jpg]

> P.S. И насчёт обозначения шестнадцатеричных цифр кириллицей. Почему вам не понравился вариант Юрия «abcdef» -> «абцдеф»?
Траслитерация. Не особо что-то меняется, да и проще кодировать - не нужно вводить дополнительную строку для кодирования. Хотя я в принципе не цепляюсь к синтаксису и все обсуждаемо.

> А на данном этапе полностью отказаться от латинских букв всё равно не получится.
Можно попробывать. Мне это интересно с точки зрения экзотики, посмотреть по новому на привычные вещи.
---
2024-09-14 ~‘*‘alextretyak’’

> Спасибо, за предложение, но пока занят этим проектом.
Так в том то и дело, что заниматься такой документацией нужно не вместо вашего проекта, а параллельно!
Т.е. я ни в коем случае не предлагаю вам забрасывать ваш проект, наоборот.
Работа по генерации машинного кода из языка ассемблера включает в себя получение большого количества специфических знаний и документация нужна, чтобы эти знания не потерялись.
Вот есть у нас готовые ассемблеры, даже исходники есть (fasm, nasm). Ну и что толку? Разобраться в них стороннему человеку очень трудно. Проще написать с нуля свою реализацию генерации маш. кода на основе информации из Интернета и официальной документации Intel.

> Так в это же общедоступная информация, вот к примеру https://i.sstatic.net/VTxd0.jpg
Хе. Ясно, что общедоступная. Проблема в том, что этой "общедоступной информации" слишком много! (И большая её часть нерелевантна искомому запросу.)
Нет, если всё бросить и заниматься одной только этой проблемой (генерации маш. кода x86), то может оно и нормально, но я ищу более лёгкий путь.

Вот дали вы ссылку на эту картинку.
Ну да, картинка красивая, и что? Как с её помощью мне получить машинный код инструкции `lea edx, [eax + ebx*2]`?
А `lea edx, [eax + ebx*2 + 8]`?
А `lea edx, [ebx*2 + 8]`?
А `lea edx, [ebx*2]`?
А `lea rdx, [ebx*2]`?
А `lea rdx, [rbx*2]`?
И т.д. и т.п. (но последние три особенно интересны).

Узнать опкод нужной инструкции — это элементарно. Для этого красивая таблица не нужна. А вот понимание нюансов, принципы формирования режимов адресации — вот что нужно.
---
2024-09-14 ~‘*‘ИванАс’’

>‘Так в том то и дело, что заниматься такой документацией нужно не вместо вашего проекта, а параллельно!
Т.е. я ни в коем случае не предлагаю вам забрасывать ваш проект, наоборот.’
Дополнительные накладные расходы, есть много информации по кодам, это не так как было доинтернетовскую эпоху когда чтобы получить какую-то информацию, нужно ходить в библиотеку и выписывать журналы.

> Работа по генерации машинного кода из языка ассемблера включает в себя получение большого количества специфических знаний и документация нужна, чтобы эти знания не потерялись.
Возможно, но они уже не становятся специфичными если уже это проходил когда-то.

> Хе. Ясно, что общедоступная. Проблема в том, что этой "общедоступной информации" слишком много! (И большая её часть нерелевантна искомому запросу.)
Информации много, и надо уметь ее находить.

> Ну да, картинка красивая, и что? Как с её помощью мне получить машинный код инструкции `lea edx, [eax + ebx*2]`?
Там внизу описание опкода есть, там SIB байт есть.
Простой способ берешь компилятор ассемблера и компилируешь и получаешь маш.код, конечно компилятор ассемблера из 2 вариантов представления выбирает один, но это нюансы.
---
2024-09-17 ~‘*‘alextretyak’’

> конечно компилятор ассемблера из 2 вариантов представления выбирает один, но это нюансы.
Можете уточнить, что это за 2 варианта представления?
---
2024-09-17 ~‘*‘ИванАс’’

> Можете уточнить, что это за 2 варианта представления?
Я не так сильно много лазил в машинном коде, но такую штуку я знаю:
#‘
    1018:   89 c1                   mov    %eax,%ecx
    101a:   8b c8                   mov    %eax,%ecx
’
Cмотрите на биты:
1000 1001 11 000 001
1000 1011 11 001 000
---
2024-09-17 ~‘*‘Лис’’

В коде команды (первом байте) есть "бит направления пересылки".
А в байте mod R/M кодируются два регистра - откуда и куда, или куда и откуда.
А в текстовой записи порядок операндов только один (для конкретного синтаксиса).

Судя по приведённому примеру - это бит, следующий за младшим (т.е. второй, с индексом 1 если считать с нуля)
>‘Cмотрите на биты:
10001001 11000001
100010*‘1’1 11001000’
---
2024-09-20 ~‘*‘alextretyak’’

>‘Ivan’:‘Простой способ берешь компилятор ассемблера и компилируешь и получаешь маш.код’
А как вы смотрите машинный код, соответствующий определённой инструкции?
Я знаю несколько способов, но вдруг ваш способ более удобный.
---
2024-09-20 ~‘*‘ИванАс’’

Смотрю через objdump.

На входе .s файл:
#‘
 15 mov %eax, %ecx
 16 .byte 0x8b, 0xc8
’
В objdump:
#‘
    1000:   89 c1                   mov    %eax,%ecx
    1002:   8b c8                   mov    %eax,%ecx
’
---
2024-09-20 ~‘*‘alextretyak’’

> Смотрю через objdump.
А с какими ключами вы его запускаете?
Я пробовал разные: и -s, и -d, и без параметров. И у меня всегда выдаёт:
#‘
objdump: test.s: File format not recognized
’

objdump же вроде как принимает только машинный код (исполняемые файлы или объектные `.o`). Разве ему можно скормить `.s` файл?
---
2024-09-20 ~‘*‘ИванАс’’

.s файл компилируется, получается исполнимый или объектный файл. Его и смотришь в objdump.
К примеру так
objdump -d ./main
Вообще, есть описание для objdump, запускается просто:
man objdump

Не понимаю почему у вас возникают с этим сложности?
---
2024-09-20 ~‘*‘alextretyak’’

> .s файл компилируется
Почему "компилируется"? Правильнее сказать "ассемблируется", вы же используете `as` или чем вы `.s` файл "компилируете"?

> Не понимаю почему у вас возникают с этим сложности?
Не то, чтобы сложности. Просто опыта работы в Linux у меня немного. И мой вопрос был про другое: получить машинный код, соответствующий определённой инструкции, *‘один раз’ — это не проблема, даже если это займёт несколько минут. Но когда нужно проделать это десятки (а то и сотни) раз, то хочется максимально упростить этот процесс. Пока что, на основе вашего предложения я составил такую составную команду:
#‘
echo mov %eax, %ecx | as && objdump -d a.out
’

Это для AT&T-синтаксиса, который мне очень не нравится. Поэтому, вот вариант для Intel-синтаксиса:
#‘
echo mov ecx, eax | as -msyntax=intel -mnaked-reg && objdump -d a.out
’

Вот примерно такой ответ я и ожидал получить. Или вы всё это делаете руками каждый раз заново (редактируете `.s` файл, затем запускаете `as`, а потом `objdump`)?
---
2024-09-20 ~‘*‘ИванАс’’

> Правильнее сказать "ассемблируется", вы же используете as или чем вы .s файл "компилируете"?
Причем тут правильность? Я вам мысль доношу. Конечно на этой почве можно холивар устроить, но зачем?
Вики:
< Компиля́тор — программа, переводящая написанный на языке программирования текст в набор машинных кодов
В чем противоречие у вас? Есть много различных слов описывающее тоже самое. "Правильность" определяйте сами, мне не интересно опускаться до этих деталей.

> Но когда нужно проделать это десятки (а то и сотни) раз, то хочется максимально упростить этот процесс. Пока что, на основе вашего предложения я составил такую составную команду:
Делайте как можете, все зависит от ваших задач.

> Вот примерно такой ответ я и ожидал получить. Или вы всё это делаете руками каждый раз заново (редактируете .s файл, затем запускаете as, а потом objdump)?
Я делаю как мне удобно. Если у вас уже есть ответ, то тогда зачем спрашивать? Мы же не играем игру "экзаменатор-проверяемый".
---
2024-09-20 ~‘*‘Лис’’

Ответ немного слишком резкий. Но в целом мы поняли, что задачи различаются у разных разработчиков
и поэтому кто-то хочет сделать что-то одно, кто-то другое и ему не надо делать так, как это пытается сделать другой (первый) разработчик.
---
2024-09-20 ~‘*‘ИванАс’’

> Ответ немного слишком резкий.
Ответ справедливый.
---
2024-09-21 ~‘*‘alextretyak’’

*‘Ivan’
> Причем тут правильность?
Притом, что в командной строке нельзя написать "скомпилируй test.s".
[[[
#rec##audio#[REC_0003364.wav][по дороге к СвН собору]
А вот если бы вы сказали "ассемблируется .s файл", тогда это бы сподвигло меня к поиску хотя бы.
]]]Если бы вы сказали ".s файл ассемблируется", тогда это бы сподвигло к поиску хотя бы.
[[[
И если лично для вас фраза ".s файл компилируется, получается исполнимый или объектный файл" очевидна, то для меня [и многих других читателей этого форума] — нет.
Вообще, под эту фразу больше подходит команда gcc -c test.s (которая равнозначна as test.s).
]]]
И вы зря недооцениваете правильность. [[[То]]]От того, что лично вы сэкономили себе пару минут на выборе наиболее подходящего слова/термина, собеседник потратит десятки минут, пытаясь понять, что же вы имели в виду. И в результате, всё равно поймёт вас неправильно, и всё это выльется в нелепую перебранку.
Так что, выбор подходящих слов очень важен при совместной работе и вообще при любой коммуникации.[[[ А если вам не нужна коммуникация, почему тогда вы ведёте эту тему на публичном форуме, а не в личном блоге с отключенными комментариями?]]]

> Компиля́тор — программа, переводящая написанный на языке программирования текст в набор машинных кодов
И всё же, никто не называет утилиту `as` компилятором, это ассемблер.

> Я делаю как мне удобно.
Да, пожалуйста, делайте. Но от того, что вы поделитесь информацией с другими, знаний у вас меньше не станет, верно?
Такова особенность информации, в отличие от каких-либо материальных вещей — при передаче вещи у её прежнего владельца вещь пропадает, а при передаче информации происходит её копирование.

> Если у вас уже есть ответ, то тогда зачем спрашивать?
Затем, что ваш ответ может оказаться лучше, чем мой. "Лучше" в данном случае — более удобная/короткая команда, более удобный формат вывода.
Я, кстати, своим ответом не удовлетворён (и поэтому не считаю, что у меня "уже есть ответ"). Мне бы хотелось видеть только машинный код, без лишней информации, которую выдаёт objdump.

> Мы же не играем игру "экзаменатор-проверяемый".
Очень жаль, что вы это так восприняли.
Я написал эту [[[составную ]]]команду не для того, чтобы [[["]]]похвастаться[[["]]] или показать "правильный вариант ответа". А для того, что вдруг она окажется полезной (если не вам, то кому-нибудь из читателей этого форума). А также [[[для того, чтобы]]]на случай если кто-то увидит её и при этом знает способ лучше, чтобы он мог об этом сообщить.

Выбор удобных инструментов очень важен для продуктивной работы. И совместно [[[выработать/]]]подобрать оптимальный набор инструментов проще, чем по одиночке. У каждого из нас есть пробелы в знаниях. Я вполне могу знать то, чего не знаете вы. А вы — знать то, чего не знаю я.
